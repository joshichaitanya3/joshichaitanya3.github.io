<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Design document for the Morpho Gmsh Extension</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">2.</strong> Installation Instructions</a></li><li class="chapter-item expanded "><a href="anatomy_of_extension.html"><strong aria-hidden="true">3.</strong> Anatomy of the Gmsh Extension</a></li><li class="chapter-item expanded "><a href="gmsh_api.html"><strong aria-hidden="true">4.</strong> The Gmsh API</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="gmshApi/gen.html"><strong aria-hidden="true">4.1.</strong> gen.py</a></li><li class="chapter-item expanded "><a href="gmshApi/genApi.html"><strong aria-hidden="true">4.2.</strong> genApi.py</a></li></ol></li><li class="chapter-item expanded "><a href="api_autogeneration.html"><strong aria-hidden="true">5.</strong> API auto-generation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="apiAutogeneration/skeleton.html"><strong aria-hidden="true">5.1.</strong> Skeleton of a Morpho wrapper extension</a></li><li class="chapter-item expanded "><a href="apiAutogeneration/arg.html"><strong aria-hidden="true">5.2.</strong> The arg class</a></li><li class="chapter-item expanded "><a href="apiAutogeneration/capturing_inputs.html"><strong aria-hidden="true">5.3.</strong> Capturing inputs</a></li><li class="chapter-item expanded "><a href="apiAutogeneration/capturing_and_returning_outputs.html"><strong aria-hidden="true">5.4.</strong> Capturing and returning the C outputs</a></li><li class="chapter-item expanded "><a href="apiAutogeneration/autodoc.html"><strong aria-hidden="true">5.5.</strong> Auto-generating inline documentation</a></li><li class="chapter-item expanded "><a href="apiAutogeneration/write_module.html"><strong aria-hidden="true">5.6.</strong> Writing it all to the files</a></li></ol></li><li class="chapter-item expanded "><a href="gmsh_in_morpho.html"><strong aria-hidden="true">6.</strong> Implementation of the Gmsh Module in Morpho</a></li><li class="chapter-item expanded "><a href="to_dos.html"><strong aria-hidden="true">7.</strong> Some To-do's</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Design document for the Morpho Gmsh Extension</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/joshichaitanya3/gmsh-design-docs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This is a design document for creating an extension that enables the use of the open-source mesh generation library <a href="%22https://gmsh.info/%22"><code>gmsh</code></a> in <a href="%22https://github.com/Morpho-lang/morpho%22">Morpho</a>.</p>
<p>The extension is available <a href="https://github.com/Morpho-lang/morpho-gmsh">here</a> and works with Morpho version 0.6.0. The version of Gmsh used at the time of writing is 4.12.2.</p>
<h2 id="example-use"><a class="header" href="#example-use">Example use</a></h2>
<p>Here is an example of how the <code>gmsh</code> module can be used.</p>
<pre><code class="language-javascript">import gmsh

var gm = GmshLoader("t1.msh") // Load a .msh (gmsh's format) file in Gmsh
gm.launch() // Launch the Gmsh app, where the mesh can now be modified
gm.exportToMorpho("t1Modified.mesh") // Save the modified mesh in Morpho's .mesh format
</code></pre>
<p><em>Excerpt from <code>examples/fromFile.morpho</code></em></p>
<p>The Morpho Gmsh API itself can be used by importing the <code>gmshapi</code> module:</p>
<pre><code class="language-javascript">import gmshapi
import plot

gmshInitialize(0,0,0)
var coneHeight = 1
var coneRadius = 1
var coneTag = gmshModelOccAddCone(0,0,0, 0,0,coneHeight, coneRadius,0, -1, 2*Pi)
gmshModelOccSynchronize()
gmshOptionSetNumber("Mesh.MeshSizeMax", 0.2)
gmshModelMeshGenerate(3)
var m = GmshLoader().buildMorphoMesh()
Show(plotmesh(m, grade=1))
gmshFinalize()
</code></pre>
<p><em>Excerpt from <code>examples/occ.morpho</code></em></p>
<p>This allows for a different implementation of the <code>gmsh</code> module or other functionalities.</p>
<h2 id="organization"><a class="header" href="#organization">Organization</a></h2>
<p>The installation instructions are in <a href="installation.html">Chapter 2</a>. A simple example of a Morpho wrapper extension is discussed in <a href="anatomy_of_extension.html">Chapter 3</a>. The structure of the Gmsh API is discussed in <a href="gmsh_api.html">Chapter 4</a>. The creation of Morpho bindings for the Gmsh API is discussed in <a href="api_autogeneration.html">Chapter 5</a>. In <a href="gmsh_in_morpho.html">Chapter 6</a>, we will discuss the implementation of the <code>gmsh</code> module in Morpho, which will use the Morpho Gmsh API to generate higher-level functionality. While this could also have been auto-generated similar to the Python API, we create this manually in a "Morphonic" object-oriented style. We document some to-do's in <a href="to_dos.html">Chapter 7</a>.</p>
<h2 id="acknowledgements"><a class="header" href="#acknowledgements">Acknowledgements</a></h2>
<p>The design of this Morpho-specific binding was improved by inspirations from a <a href="https://github.com/Ehtycs/haskell-gmsh/">Haskell Binding to the Gmsh API by Antero Marjamäki</a>.</p>
<p><em>This is a pretty unusual piece of code for me, which required understanding the organization of the parent <code>gmsh</code> codebase. This document is rather verbose, and is mostly so for my own benefit. Apologies if it beats around the bush too much!</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation-instructions"><a class="header" href="#installation-instructions">Installation instructions</a></h1>
<ol>
<li>
<p>This extension requires <code>gmsh</code> to be installed as a dynamic library. Download the source code of the latest stable release of gmsh from https://gitlab.onelab.info/gmsh/gmsh/-/releases.</p>
</li>
<li>
<p>Build gmsh from source with the dynamic build flag turned on:</p>
<pre><code class="language-bash">cd build
cmake -DENABLE_BUILD_DYNAMIC=1 ..
make
make install
</code></pre>
</li>
<li>
<p>In <code>apigenerator/generate.py</code>, set the correct version of gmsh that you have downloaded by modifying line 7:</p>
<pre><code class="language-python">api_version = "gmsh_4_12_2" # For example
</code></pre>
</li>
<li>
<p>Run the file:</p>
<pre><code class="language-bash">python generate.py
</code></pre>
</li>
<li>
<p>Navigate to <code>morpho-gmsh</code></p>
</li>
<li>
<p>Build the extension by running the following:</p>
<pre><code class="language-bash">mkdir build
cd build
cmake -DCMAKE_BUILD_TYPE=Release ..
make install
</code></pre>
</li>
<li>
<p>Add the extension path to <code>~/.morphopackages</code>:</p>
<pre><code class="language-bash">cd ..
pwd &gt;&gt; ~/.morphopackages
</code></pre>
</li>
<li>
<p>Try out the test example</p>
<pre><code class="language-bash">cd examples
morpho6 testgmshapi.morpho
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="anatomy-of-the-gmsh-extension"><a class="header" href="#anatomy-of-the-gmsh-extension">Anatomy of the Gmsh Extension</a></h1>
<p>As is described in the devguide, a <em>Morpho</em> extension can either be</p>
<ol>
<li>Simply a <code>.morpho</code> file that we want to be able to import from anywhere, or</li>
<li>An added functionality written in C and loaded as a shared library (imported the same way as a <code>.morpho</code> extension), or</li>
<li>A combination of both.</li>
</ol>
<p>Normally, we would have used the Gmsh C API to write an extension, hand-picking the functionality we most desire (category #2 above). But we are in luck, as the original Gmsh API is auto-generated, and the code to do that renders itself well to a better approach: creating a <em>Morpho</em> API for Gmsh (by auto-generating Morpho bindings code in C), which we can then use to create a Gmsh module for Morpho written in Morpho itself.</p>
<p>We use Gmsh's own API generator code to create low-level Morpho bindings to the Gmsh functions (loaded as <code>gmshapi</code>). Higher-level functionality, including exporting to a Morpho mesh, is then implemented in a Morpho module (loaded as simply <code>gmsh</code>). Ideally, the end-user should only need to import the <code>gmsh</code> module, but the <code>gmshapi</code> module is also available for those who want to use the low-level Gmsh API directly (via <code>import gmshapi</code>).</p>
<p>Thus, our Gmsh extension is an example of category #3: a C extension that wraps the Gmsh C API, and a <code>.morpho</code> file that uses this extension to create the <code>gmsh</code> module.</p>
<h2 id="directory-structure"><a class="header" href="#directory-structure">Directory Structure</a></h2>
<p>Here is the directory structure of the Gmsh extension:</p>
<pre><code>.
├── CMakeLists.txt
├── LICENSE
├── README.md
├── apigenerator
│   ├── api
│   │   ├── GenApi.py
│   │   └── gen.py
│   └── generate.py
├── examples
│   ├── fromFile.morpho
│   ├── occ.morpho
│   ├── ...
├── lib
│   └── gmshapi.so
├── share
│   ├── help
│   │   ├── gmsh.md
│   │   └── gmshapi.md
│   └── modules
│       └── gmsh.morpho
└── src
    ├── gmshapi.c
    └── gmshapi.h
</code></pre>
<p>The <code>.morpho</code> extension file(s) go in the <code>share/modules</code> directory. The C source and header files go in the <code>src</code> directory. The shared library (which will be generated upon compiling the C source) goes in the <code>lib</code> directory. The documentation to be made available for inline help goes in the <code>share/help</code> directory. This should follow the <em>Morpho</em> inline documentation Markdown format (see the devguide). The documentation for the higher level <code>gmsh</code> module is in <code>gmsh.md</code>, and the documentation for the low level <code>gmshapi</code> module is in <code>gmshapi.md</code> (which is auto-generated).</p>
<p>The <code>apigenerator</code> directory contains the scripts used to generate the Morpho API from the Gmsh C API. The <code>generate.py</code> script is used to generate the Morpho API from the Gmsh C API. It downloads <code>gen.py</code> from a stable Gmsh release and runs it using our own <code>GenApi.py</code> file. This creates the following three files:</p>
<ol>
<li><code>src/gmshapi.c</code> (the C source file for the extension)</li>
<li><code>src/gmshapi.h</code> (the C header file for the extension)</li>
<li><code>share/help/gmshapi.md</code> (the inline documentation for the low level Morpho API)</li>
</ol>
<p>Building the project using Cmake generates the shared library <code>lib/gmshapi.so</code> from the C source file.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-gmsh-api"><a class="header" href="#the-gmsh-api">The Gmsh API</a></h1>
<p>Broadly, <code>gmsh</code> is divided into 4 components: geometry, mesh, solver and post-processing (see the Gmsh reference manual).</p>
<ol>
<li>
<p>Geomery: A model in Gmsh is defined using its Boundary Representation (BRep). This geometry is specified through a built-in kernel (<code>geo</code>) and/or an <em>OpenCASCADE</em> kernel (<code>occ</code>). This module allows us to define our domain and perform various operations like Boolean combinations, extrusions, translations etc. without actually meshing the domain.</p>
</li>
<li>
<p>Mesh: The mesh module provides various algorithms for generating conformal meshes for the domains. The basic entities used in Gmsh are lines, triangles, quadrangles, tetrahedra, prisms, hexahedra and pyramids, and the meshes are by default unstructured. This is great for Morpho since we can always generate a triangular (in 2D) or tetrahedral (in 3D) mesh from Gmsh and export to the Morpho Mesh format (this is done separately in the higher level module.)</p>
</li>
<li>
<p>Solver: The solver module allows exchange of data with external solvers or other clients through the ONELAB interface.</p>
</li>
<li>
<p>Post-processing: The post-processing module allows viewing scalar/tensorial field data on top of the meshes.</p>
</li>
</ol>
<p>Gmsh is written in C++, but provides APIs for several languages like C, Python, Julia and Fortran. In the API, the components mentioned above are organized into modules and submodules as follows:</p>
<ul>
<li><code>gmsh</code>
<ul>
<li><code>option</code></li>
<li><code>model</code>
<ul>
<li><code>mesh</code>
<ul>
<li><code>field</code></li>
</ul>
</li>
<li><code>geo</code>
<ul>
<li><code>mesh</code></li>
</ul>
</li>
<li><code>occ</code>
<ul>
<li><code>mesh</code></li>
</ul>
</li>
</ul>
</li>
<li><code>view</code>
<ul>
<li><code>option</code></li>
</ul>
</li>
<li><code>plugin</code></li>
<li><code>graphics</code></li>
<li><code>fltk</code></li>
<li><code>parser</code></li>
<li><code>onelab</code></li>
<li><code>logger</code></li>
</ul>
</li>
</ul>
<p>In the <code>C</code> API, the function names are given using the lower camel case. For example, the <code>addPoint</code> function in the <code>geo</code> submodule of <code>model</code> will be called <code>gmshModelGeoAddPoint</code>. We maintain the same call signature for the low-level Morpho API.</p>
<p>The APIs are auto-generated using two scripts:</p>
<ol>
<li><a href="%22https://gitlab.onelab.info/gmsh/gmsh/blob/master/api/gen.py%22"><code>gen.py</code></a>: This file defines all the modules and submodules of the Gmsh library as noted above, and adds each method with its input and output (handled by special objects), along with its documentation to an <code>API</code> object. This object then writes the API files for all the languages through methods like <code>write_julia()</code>, <code>write_c()</code>, etc. This <code>API</code> object is defined in the next file:</li>
<li><a href="%22https://gitlab.onelab.info/gmsh/gmsh/blob/master/api/GenApi.py%22"><code>GenApi.py</code></a>: This is where the bindings are generated. The <code>Module</code> object is defined, which holds the name, documentation and a list of submodules, and provides a method to add (sub)modules to it. The <code>API</code> object provides methods to add modules, write to files, and write language-specific APIs. It also defines the <code>arg</code> object that handles the nature of the input and output arguments, providing apparatus for various languages.</li>
</ol>
<p>In <code>morpho-gmsh</code>, we obtain <code>gen.py</code> from the stable version we desire, and provide our own <code>GenApi.py</code> that writes only the Morpho API. To use <code>gen.py</code> without modification, our <code>write_python()</code> does the job of producing the Morpho API, while the rest of them (<code>write_julia()</code>, etc) just <code>pass</code>.</p>
<p>Now, let's take a deep dive into these two files and see how we can use them to generate the Morpho API.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="genpy"><a class="header" href="#genpy"><code>gen.py</code></a></h2>
<p>This file, under <code>gmsh/api/gen.py</code>, has the following structure:</p>
<pre><code class="language-python">// gen.py
from GenApi import * # Contains all the relevant objects and methods
...
api = API(version_major, version_minor, version_patch)

gmsh = api.add_module('gmsh', 'top-level functions')

doc = '''Initialize the Gmsh API ... ''' 
gmsh.add('initialize', doc, None, iargcargv(), ibool('readConfigFiles', 'true', 'True', 'true'), ibool('run', 'false', 'False'))

doc = '''Return 1 if the Gmsh API is initialized, and 0 if not.'''
gmsh.add('isInitialized', doc, oint)
...
option = gmsh.add_module('option', 'option handling functions')

doc = ''' ... '''
option.add(...)
...
model = gmsh.add_module('model', ...)
...
model.add('add', doc, None, istring('name'))
...
mesh = model.add_module('mesh', 'mesh functions') # Submodule of 'model'
...
api.write_c()
api.write_python()
...
</code></pre>
<p><em>Outline of <code>gmsh/api/gen.py</code></em></p>
<p>The top level API object collects all the modules and submodules and writes them to various target languages. Its <code>add_module</code> method creates and returns a <code>Module</code> object, which has its own <code>add_module</code> method. The <code>add</code> method of the <code>Module</code> object takes in the name of the method, its documentation, the return type, and the input and output arguments. The I/O arguments are passed as objects of the <code>arg</code> class. Note that these are target-language agnostic (aside from providing default values for some languages), and the separate <code>write</code> methods of the <code>API</code> object handle the language-specific details. This allows <code>gen.py</code> to remain the same for all languages, and only the <code>GenApi.py</code> file needs to be modified for each language.</p>
<p>In light of this, we will aim to reuse the original <code>gen.py</code> <em>as is</em>, and only modify <code>GenApi.py</code> for our purposes.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="genapipy"><a class="header" href="#genapipy"><code>GenApi.py</code></a></h2>
<p>The language-agnostic nature of <code>gen.py</code>, while allowing itself to be clean and simple, transfers the complexity of the language-specific details to <code>GenApi.py</code>.</p>
<p>The original <code>gmsh</code> source code has a single <code>GenApi.py</code> file for all the target languages --- the <code>arg</code> objects have attributes for all the languages, and the <code>API</code> object has methods to write for each of them.</p>
<p>To see this, let's look at an easy example function,  <code>gmshModelSetCurrent</code>, which sets the name of the current model --- this function has one input, a <code>char *</code> array, and no output. Here is how it is added to the API in <code>gen.py</code>:</p>
<pre><code class="language-python">doc = '''Set the current model to the model with name `name'. If several models have the same name, select the one that was added first.'''
model.add('setCurrent', doc, None, istring('name'))

</code></pre>
<p><em>From <code>gmsh/api/gen.py</code></em></p>
<p>Here is what <code>GenApi.py</code>'s <code>write_c</code> method writes in the C header file for this function:</p>
<pre><code class="language-c">/* Set the current model to the model with name `name'. If several models have
 * the same name, select the one that was added first. */
GMSH_API void gmshModelSetCurrent(const char * name,
                                  int * ierr);
</code></pre>
<p><em>From <code>gmsh/api/gmshc.h</code></em></p>
<p>and here are the relevant snippets from <code>GenApi.py</code> that generate this code:</p>
<pre><code class="language-python">class arg:
    def __init__(self, name, value, python_value, julia_value, cpp_type,
                 c_type, out):
    ...
    # Note that self.c is generates the argument for the C function signature
    self.c = c_type + " " + name
    ...
...

def istring(name, value=None, python_value=None, julia_value=None):
    # Note that the arg is initialized with c_type = "const char *"
    a = arg(name, value, python_value, julia_value, "const std::string &amp;",
            "const char *", False)
    a.python_arg = "c_char_p(" + name + ".encode())"
    ...
    a.texi_type = "string"
    return a

...
class API:
    ...
    def write_c(self):
        ...
        def write_module(module, c_namespace, cpp_namespace, indent):
            ...
            # Note that arg.c is used here to write the C function signature
            self.fwrite(f, 
              fnameapi + (",\n" + ' ' * len(fnameapi)).join(
                list((a.c for a in args + (oint("ierr"), )))) + ");\n")
        ...
    ...
...
</code></pre>
<p><em>Snippets from <code>gmsh/api/GenApi.py</code></em></p>
<p>Let's start with the <code>istring</code> object. This is an object of the <code>arg</code> class. Note that in the initializer, the <code>c_type</code> passed is <code>"const char *"</code>. The <code>arg</code> initializer in turn uses this to set its attribute <code>c</code> to <code>c_type + " " + name</code>. This is used in the <code>write_c</code> method of the <code>API</code> object to write the call signature in the C header file. This is how the C function signature is written to the header file.</p>
<p>This procedure is followed for all input and output types. For example, there is an object <code>iint</code> for an input <code>int</code>, <code>ivectorsize</code> for a vector of <code>size_t</code>'s, etc. and similar for outputs, <code>ostring</code> for an output <code>char *</code> and so on. These objects have attributes that specify, among other things, the call signatures for various languages. For instance, if a function takes in an input vector of integers, then the <code>C</code> function needs <em>two</em> inputs, (<code>int * list, size_t list_n</code>), where <code>list_n</code> encodes the size of the list. The same goes for outputs.</p>
<p>We write our own <code>GenApi.py</code> that only writes the Morpho API, heavily adopting from the original. We will see how to do this in the next chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-auto-generation"><a class="header" href="#api-auto-generation">API auto-generation</a></h1>
<p>Now that we understand how the original Gmsh API is generated, let's work towards creating Morpho bindings for it. Since our Morpho API is going to be wrapping the <em>C</em> API functions around a Morpho veneer (as Morpho is written in C), our <code>GenApi.py</code> script will auto-generate the <em>veneers</em> for the C functions. (Since Morpho does not have a native Foreign Function Interface (FFI) yet, we will have to write the veneers in C. Although, the machinery we build here could be useful for building a future FFI for Morpho.) In addition, we also want inline documentation for the Morpho API, which should also be auto-generated from the original Gmsh API documentation.</p>
<p>Hence, our <code>GenApi.py</code> script will have to do the following tasks:</p>
<ol>
<li>Generate the Morpho veneers for the C functions.</li>
<li>Create the header file with the function names and error names for the Morpho API.</li>
<li>Generate the inline documentation for the Morpho API.</li>
</ol>
<p>In this chapter, we will first sketch out a simple example of how a veneer extension can be written for Morpho. Then we will discuss how we can auto-generate the veneers and the inline documentation for the Morpho using our <code>GenApi.py</code> script.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="skeleton-of-a-morpho-wrapper-extension"><a class="header" href="#skeleton-of-a-morpho-wrapper-extension">Skeleton of a Morpho wrapper extension</a></h1>
<p>To see how a simple wrapper extension can be written, let's assume we want to wrap a C function <code>integer_add</code> that adds two integers and returns the output as an integer. Here is how we would write the wrapper in C:</p>
<h2 id="c-file"><a class="header" href="#c-file">C file</a></h2>
<pre><code class="language-c">// intadd.c
#include &lt;stdio.h&gt;
#include &lt;morpho/morpho.h&gt;
#include &lt;morpho/builtin.h&gt;
#include "intadd.h"

// The C function we wish to wrap. This could be in a saparate file, in which case we would include its header file here, but we are keeping it simple for now.
int integer_add(int a, int b) {
    return a + b;
}

// The Morpho veneer function
value MorphoIntegerAdd(vm *v, int nargs, value *args) {
    // Check the number of arguments
    if (nargs != 2) {
        morpho_runtimeerror(v, INTADD_NARGS_ERROR);
        return MORPHO_NIL;
    }
    // Check the types of the arguments
    if (!MORPHO_ISINTEGER(args[0])) {
        morpho_runtimeerror(v, INTADD_TYPE_ERROR);
        return MORPHO_NIL;
    }
    if (!MORPHO_ISINTEGER(args[1])) {
        morpho_runtimeerror(v, INTADD_TYPE_ERROR);
        return MORPHO_NIL;
    }
    // Call the C function and return the result
    int a = MORPHO_GETINTEGERVALUE(args[0]);
    int b = MORPHO_GETINTEGERVALUE(args[1]);
    return MORPHO_INTEGER(integer_add(a, b));
}

void myextension_initialize(void) {
    builtin_addfunction(MORPHO_INTEGERADD_FUNCTION, MorphoIntegerAdd, BUILTIN_FLAGSEMPTY);
    morpho_defineerror(INTADD_NARGS_ERROR, ERROR_HALT, INTADD_NARGS_ERROR_MSG);
    morpho_defineerror(INTADD_ARGS_ERROR, ERROR_HALT, INTADD_ARGS_ERROR_MSG);
}

void myextension_finalize(void) {
    // Nothing to do here
}
</code></pre>
<p>The <code>value</code> object is the basic Morpho object that can hold any type of value like Lists, integers, floats, Strings, etc., even including <code>nil</code>. Every <em>Morpho</em> veneer function returns a <em>Morpho</em> <code>value</code> object. Further, <code>nargs</code> is the number of arguments supplied, and <code>args</code> is a list of Morpho <code>value</code>'s. We can see that we have performed type checking on the arguments and raised errors if the wrong number or type of arguments are supplied. We have also captured the arguments into C variables and called the C function. Finally, we have returned the result as a Morpho <code>value</code> object.</p>
<p>All <em>Morpho</em> extensions must provide an initialize function, named EXTENSIONNAME_initialize. In this function, the morpho API is used to define functions and/or classes implemented, and set up any global data as necessary. Since we will be wrapping functions, our extension does not have any classes. Here, we add a function to the runtime that will be visible to user code as <code>MORPHO_INTEGERADD_FUNCTION</code>. This is defined as a macro instead of hardcoding the function name to make it easier to change the function name in the future or use it elsewhere. The last argument to <code>builtin_addfunction</code> is a flag that tells the morpho runtime whether the function is a method or a standalone function. Since this is a standalone function, we pass <code>BUILTIN_FLAGSEMPTY</code>. Similarly, we define errors that will be raised in the veneer function, whose name and message are also macros.</p>
<p>The finalize function has a similar naming convention, and is not strictly necessary (as here). This function should deallocate or close anything created by your extension that isn’t visible to the morpho runtime: we will actually use it here to finalize gmsh itself.</p>
<p>The macros are defined in our extension's header file <code>intadd.h</code>:</p>
<h2 id="header-file"><a class="header" href="#header-file">Header File</a></h2>
<pre><code class="language-c">// intadd.h
#include &lt;stdio.h&gt;
#include &lt;morpho/morpho.h&gt;
#include &lt;morpho/builtin.h&gt;

#define INTADD_NARGS_ERROR "IntAddNArgsError"
#define INTADD_NARGS_ERROR_MSG "Wrong number of arguments supplied to integer_add"

#define INTADD_TYPE_ERROR "IntAddTypeError"
#define INTADD_TYPE_ERROR_MSG "integer_add requires two integer arguments"

#define MORPHO_INTEGERADD_FUNCTION "addInts"
</code></pre>
<p>Note that from the last line, the function is given the name <code>addInts</code>, so it would be called that <em>in Morpho</em>:</p>
<pre><code class="language-javascript">var a = 3;
var b = 4;
var c = addInts(a, b);
</code></pre>
<p>However, there is nothing stopping us from calling it <code>integer_add</code> itself. Having</p>
<pre><code class="language-c">#define MORPHO_INTEGERADD_FUNCTION "integer_add"
</code></pre>
<p>would make the last line</p>
<pre><code class="language-javascript">var c = integer_add(a, b);
</code></pre>
<p>This is in fact what we will do for our Gmsh extension. We will call the functions in the C API by the same names as in the original Gmsh API. This will make it easier for users to use the Morpho APIs without having new names.</p>
<p>Our extension is almost ready, save for documenting the function. This is done in Morpho using the Markdown format in the <code>share/help</code> directory. We will see how to do this in the next chapter. For our simple extension, it would look like this:</p>
<h2 id="help-file"><a class="header" href="#help-file">Help file</a></h2>
<pre><code class="language-markdown">[comment] # Path: share/help/intadd.md
[comment]: # (Intadd help)
[version]: # (0.1)

# Intadd

[tagIntadd]: # "Intadd"

The `intadd` extension provides a method to add two integers.

[showsubtopics]: # "subtopics"

## addInts

[tagaddints]: # "AddInts"

The `addInts` function adds two integers and returns the result.

    var c = addInts(1, 2)
    print c // 3
</code></pre>
<p>This makes it so that the user can access the help for this module in the REPL using</p>
<pre><code class="language-javascript">&gt;help intadd // or
&gt;help intadd.addInts // etc
</code></pre>
<p>This is how we will document our Gmsh extension as well. For every gmsh function, we need the veneer, the initialization, the header file declaration and the documentation. We will see how to do this in the next chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-arg-class"><a class="header" href="#the-arg-class">The arg class</a></h1>
<p>In the simple example in the last chapter, we saw the processing of the input and output arguments that we needed to do to create the veneer. In the Gmsh API generator, all arguments are initialized as the <code>arg</code> class or one of its subclasses. We simplify this object to strip off most of the boilerplate code for the other language APIs and add in attributes for the Morpho API. Our <code>arg</code> class has the following structure:</p>
<pre><code class="language-python"># Removing all the Python, Julia and Fortran related attributes, but
# keeping the function call signatures the same in order to use gen.py
# without editing.
class arg:
    """ Basic datatype of an argument. Every datatype inherits this constructor
    and also default behaviour from here.

    Compared to the original, this object only stores the C-related information (to actually call the C-API functions) and Morpho-specific information.

    Subclasses of this constructor will have methods for processing inputs/outputs, etc.

    """
    def __init__(self, name, value, python_value, julia_value, cpp_type,
                 c_type, out):
        self.c_type = c_type
        self.name = name
        if (name == "value"): # value is a builtin type in Morpho, so change it slightly
            self.name = "cvalue"
            name = "cvalue"
        if (name == "v"): # Similarly, v is used for the virtual machine (vm) in Morpho
            self.name = "cv"
            name = "cv"
        self.value = value
        self.out = out # Boolean to indicate if the argument is an output
        self.c = c_type + " " + name
        self.texi_type = ""
        self.texi = name + ""
        # self.morpho will be used in place of self.c while calling the C-API functions, since the inputs will be slightly different while calling from the Morpho wrappers.
        self.morpho = name
        # self.morpho_object specifies how to name the Morpho Objects corresponding to the args. For instance, a string would have morpho_object as name + "_str", so that it is declared as `objectstring * name_str = ...`
        self.morpho_object = name

</code></pre>
<p>As noted in the comments in the code, the <code>self.morpho</code> attribute will be used in place of <code>self.c</code> while calling the C-API functions, since the inputs will be slightly different while calling from the Morpho wrappers. The <code>self.morpho_object</code> attribute specifies how to name the Morpho Objects corresponding to the args. For instance, a string would have morpho_object as name + "_str", so that it is declared as <code>objectstring * name_str = ...</code>.</p>
<p>The original <code>GenApi.py</code> file creates all the objects as <em>instances</em> of the <code>arg</code> class, like so:</p>
<pre><code class="language-python"># Original GenApi.py
def iint(name, value=None, python_value=None, julia_value=None):
    a = arg(name, value, python_value, julia_value, "const int", "const int",
            False)
    a.python_arg = "c_int(" + name + ")"
    a.julia_ctype = "Cint"
    a.fortran_types = ["integer, intent(in)"]
    a.fortran_c_api = ["integer(c_int), value, intent(in)"]
    a.fortran_call = f"{name}=optval_c_int({value}, {name})" if value is not None else f"{name}=int({name}, c_int)"
    a.texi_type = "integer"
    return a
</code></pre>
<p>In contrast, we will create all other arguments as subclasses or sub-subclasses of this <code>arg</code> object. We will see in the next chapters that our way allows us to write additional <em>methods</em> to the subclasses to help write the Morpho API.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="capturing-morpho-inputs"><a class="header" href="#capturing-morpho-inputs">Capturing Morpho inputs</a></h2>
<p>To see how we handle inputs, let's continue with our example of the <code>gmshModelSetCurrent</code> function that we looked at in <a href="apiAutogeneration/../gmshApi/genApi.html">genApi.py</a>. This function takes in a <code>char</code> array containing the desired name for the current model and sets it internally, returning nothing. Hence, this function has one <code>String</code> input and no outputs. Below is its declaration in the C-API, <code>gmshc.h</code>:</p>
<pre><code class="language-c">/* Set the current model to the model with name `name'. If several models have
 * the same name, select the one that was added first. */
GMSH_API void gmshModelSetCurrent(const char * name,
                                  int * ierr);
</code></pre>
<p><em><code>gmsh/api/gmshc.h</code></em></p>
<p>(Note: the last argument for all the C-API functions is a reference to an integer. This stores the error code.) Here is how it is added to the API from <code>gen.py</code>:</p>
<pre><code class="language-python">doc = '''Set the current model to the model with name `name'. If several models have the same name, select the one that was added first.'''
model.add('setCurrent', doc, None, istring('name'))
</code></pre>
<p><em><code>gmsh/api/gen.py</code></em></p>
<p>In Morpho, we want a call signature like</p>
<pre><code class="language-javascript">gmshModelSetCurrent(name)
</code></pre>
<p>To execute this, we need to do a few things:</p>
<ol>
<li>Check that the number of arguments passed to the <em>Morpho</em> <code>gmshModelSetCurrent</code> method is 1. Otherwise, raise an error.</li>
<li>Then check that this argument is indeed a Morpho String. Otherwise, raise an error.</li>
<li>If all is well, then <em>capture the input</em> into a C-string, or a <code>char</code> array.</li>
<li>Only then can we actually call the C-function.</li>
<li>Return <code>nil</code> since this function doesn't output anything.</li>
</ol>
<p>Phew, that's a bunch! But we are going to automate this process.</p>
<p>Based on the list above, we want this method to be wrapped in Morpho something like this:</p>
<pre><code class="language-c">// myextension.c
#include &lt;stdio.h&gt;
#include &lt;morpho/morpho.h&gt;
#include &lt;morpho/builtin.h&gt;
// Let's not forget to include the gmsh C API header file!
#include &lt;gmshc.h&gt;
// Let's include our own header file
#include "gmshapi.h"

value MorphoGmshModelSetCurrent(vm *v, int nargs, value *args) {
    // Check whether only 1 argument is supplied and raise error if not
    if (nargs != 1) {
        morpho_runtimeerror(v, GMSH_NARGS_ERROR);
        return MORPHO_NIL;
    } 
    // Check whether the argument is a Morpho String and raise error if not
    if (!MORPHO_ISSTRING(MORPHO_GETARG(args, 0))) {
        morpho_runtimeerror(v, GMSH_ARGS_ERROR); 
        return MORPHO_NIL; 
    }
    // If we don't raise error up to this point, we have the right number and kind of input. Capture the input Morpho string into a char array.
    const char * name = MORPHO_GETCSTRING(MORPHO_GETARG(args, 0)); 
    // Actually call the C function
    int ierr;
    gmshModelSetCurrent(name,
                      &amp;ierr);
    // Since there is no output, we return nil
    return MORPHO_NIL;
}

</code></pre>
<p><em>A wrapper for <code>gmshMorphoSetCurrent</code></em></p>
<p>Let's see how we can automate this process. To check the number of arguments, we note that the arguments are collected by the <code>Module</code> object as a list:</p>
<pre><code class="language-python">class Module:
    def __init__(self, name, doc):
        self.name = name
        self.doc = doc
        self.fs = []
        self.submodules = []

    def add(self, name, doc, rtype, *args):
        self.fs.append((rtype, name, args, doc, []))
</code></pre>
<p><em>From <code>gmsh/api/GenApi.py</code></em></p>
<p>Further, all the output arguments have the <code>out</code> property set to <code>True</code> (this is the last argument to the <code>arg</code> and its subclasses' initializer). We can use this to grab and sort the arguments:</p>
<pre><code class="language-python">def write_morpho(self):
    ...
    def write_module(module, c_namespace):
        ...
        for rtype, name, args, doc, special in module.fs:

            iargs = list(a for a in args if not a.out)
            oargs = list(a for a in args if a.out)
</code></pre>
<p><em>From <code>gmsh/api/GenApi.py</code></em></p>
<p>Thus, the code for the number of arguments check is as simple as this:</p>
<pre><code class="language-python">nargsCheck =  INDENTL1 + f"if (nargs != {len(iargs)})"+ " {\n" \
            + INDENTL2 + "morpho_runtimeerror(v, GMSH_NARGS_ERROR);\n" \
            + INDENTL2 + "return MORPHO_NIL;\n" \
            + INDENTL1 + "} \n"
</code></pre>
<p>Here, the <code>GMSH_NARGS_ERROR</code> will be defined in the <code>gmshapi.h</code> header file, together with the error message <code>GMSH_NARGS_ERROR_MSG</code> like so:</p>
<pre><code class="language-c">// morpho-gmsh/src/gmshapi.h
#define GMSH_NARGS_ERROR "GmshNargsErr"
#define GMSH_NARGS_ERROR_MSG "Incorrect Number of arguments for Gmsh function. Check the help for this function."
</code></pre>
<p>The error itself will be initialized in the <code>gmshapi.c</code> file in the <code>gmshapi_initialize</code> function as follows:</p>
<pre><code class="language-c">// morpho-gmsh/src/gmshapi.c
morpho_defineerror(GMSH_NARGS_ERROR, ERROR_HALT, GMSH_NARGS_ERROR_MSG);
</code></pre>
<p>Now, for each input argument, we need to (a) check its type and (b) capture it into a C variable. We will do this by endowing all input arguments with a <code>capture_input</code> method that will return the C code to do this. To do this, we first make a subclass of <code>arg</code> called <code>inputArg</code> which defines this method:</p>
<pre><code class="language-python"># morpho-gmsh/api/GenApi.py
class inputArg(arg):
    """
    Basic datatype for an input argument, inherited from `arg`. Provides some extra attributes and methods to process the input.
    """
    def __init__(self, name, value, python_value, julia_value, cpp_type, c_type, out):
        super().__init__(name, value, python_value, julia_value, cpp_type, c_type, out)

        # C-code to generate specific runtime error if the arguments are not correct. To-do: Currently, all inputs return the same error. Change this so that the error is function-specific or more helpful in general.
        self.runTimeErr = " {morpho_runtimeerror(v, GMSH_ARGS_ERROR); return MORPHO_NIL; }\n"
        # morphoTypeChecker is the builtin (or otherwise) Morpho function to check whether the input value is of the correct type.
        self.morphoTypeCheker = "MORPHO_ISINTEGER" # For default, using the integer case
        # morphoToCConverter is the builtin (or otherwise) Morpho function to grab the correct C-type from the input Morpho value.
        self.morphoToCConverter = "MORPHO_GETINTEGERVALUE"


    def capture_input(self, i):
        """
        capture_input(i)

        Generates C-code to check the (i+1)th input argument to the Morpho function and convert it to an appropriate C-type.
        """
        
        # Here, we check for a single object as defualt, which can be reused for anything that's not a list: `iint`, `idouble, `istring`, etc.
        chk = INDENTL1 + f"if (!{self.morphoTypeCheker}(MORPHO_GETARG(args, {i}))) " + self.runTimeErr
        inp = INDENTL1 + f"{self.c_type} {self.name} = {self.morphoToCConverter}(MORPHO_GETARG(args, {i})); \n"
        return chk + inp

</code></pre>
<p>We see that in addition to the attributes of <code>arg</code>, we add two more: <code>morphoTypeChecker</code> and <code>morphoToCConverter</code>. These are the names of the Morpho functions that will check the type of the input and convert it to a C-type, respectively. The <code>capture_input</code> method then uses these to generate the C-code to do this.</p>
<p>While the default values for these are for an integer, we can override these in the subclasses. For example, the <code>istring</code> object is initialized as follows:</p>
<pre><code class="language-python"># morpho-gmsh/api/GenApi.py
class istring(inputArg):
    def __init__(self, name, value=None, python_value=None, julia_value=None, cpp_type="const std::string &amp;", c_type="const char *", out=False):
        super().__init__(name, value, python_value, julia_value, cpp_type, c_type, out)
        self.texi_type = "string"
        self.morphoTypeCheker = "MORPHO_ISSTRING"
        self.morphoToCConverter = "MORPHO_GETCSTRING"
</code></pre>
<p>More complex objects, like <code>ivectorint</code> (which captures a list of integers), will have a more complex <code>capture_input</code> method. This allows us just process all the inputs simply as:</p>
<pre><code class="language-python"># morpho-gmsh/api/GenApi.py
# Inside the `write_module` method

# Capture all the inputs
for i,iarg in enumerate(iargs):
    self.fwrite(f, iarg.capture_input(i))
</code></pre>
<p>In the next chapter, we will look at how we handle output arguments.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="capturing-and-returning-the-c-outputs"><a class="header" href="#capturing-and-returning-the-c-outputs">Capturing and returning the C outputs</a></h1>
<p>Handling outputs is going to be a <em>little</em> more involved than the inputs. We need to do three things:</p>
<ol>
<li>Initialize pointers to the outputs so that they can be passed to the <code>gmsh</code> C functions.</li>
<li>Capture the outputs from the C functions into a Morpho value format.</li>
<li>Return the captured outputs.</li>
</ol>
<p>Similar to the input, we create an <code>outputArg</code> object, inheriting from <code>arg</code>, that defines methods for each of these operations:</p>
<pre><code class="language-python"># GenApi.py
class outputArg(arg):
    """
    Basic datatype for an output argument, inherited from `arg`.
    Defines some extra methods to process the output.
    """

    # Initialize pointers to the outputs so that they can be passed to the gmsh C functions.
    def init_output(self):
        return str("")

    # Capture the outputs from the C functions into a Morpho value format.
    def capture_output(self):
        return str("")

    # Return the captured outputs.
    def return_output(self):
        return str("")
</code></pre>
<p>The specific output types then inherit from <code>outputArg</code> and override the corresponding methods.</p>
<p>We will again choose a simple function to illustrate this, albeit with a composite return object: a list of integers:</p>
<pre><code class="language-c">/* Get the list of all fields. */
GMSH_API void gmshModelMeshFieldList(int ** tags, size_t * tags_n,
                                     int * ierr);
</code></pre>
<p>Here, we have no inputs and a single output <code>tags</code> that's a list of integers. Here is how it is added to the API from <code>gen.py</code>:</p>
<pre><code class="language-python"># gen.py
doc = '''Get the list of all fields.'''
field.add('list', doc, None, ovectorint('tags'))
</code></pre>
<p>The <code>oarg</code> class is initialized with certain handy attributes to help with the output processing. In addition to the ones we have seen before, we add a new <code>self.cToMorphoConverter</code> attribute to help convert the C outputs to Morpho outputs. E.g.:</p>
<pre><code class="language-python"># GenApi.py
class ovectorint(oint):
    def __init__(self, name, value=None, python_value=None, julia_value=None):
        arg.__init__(self, name, value, python_value, julia_value, "std::vector&lt;int&gt; &amp;",
                "int **", True)
        self.c = "int ** " + self.name + ", size_t * " + self.name + "_n"
        self.morpho = "&amp;" + self.name + ", &amp;" + self.name + "_n"
        self.texi_type = "vector of integers"
        self.morpho_object = self.name + "_list"
        self.elementType = "int"
        self.cToMorphoConverter = "MORPHO_INTEGER"

</code></pre>
<p>The <code>init_output</code> method initializes pointers to the outputs so that they can be passed to the gmsh C functions:</p>
<pre><code class="language-python"># GenApi.py, class ovectorint
    def init_output(self):
        return INDENTL1 \
                + f"{self.elementType}* {self.name};\n" \
                + INDENTL1 \
                + f"size_t {self.name}_n;\n"
</code></pre>
<p>The above will generate the C code:</p>
<pre><code class="language-c">    int* tags;
    size_t tags_n;
</code></pre>
<p>The <code>capture_output</code> method captures the outputs from the C functions into a Morpho value format:</p>
<pre><code class="language-python"># GenApi.py, class ovectorint
    def capture_output(self):
        return INDENTL1 + f"value {self.name}_value[(int) {self.name}_n];\n" \
            + INDENTL1 + f"for (size_t j=0; j&lt;{self.name}_n; j++) " +"{ \n" \
            + INDENTL2 + f"{self.name}_value[j] = {self.cToMorphoConverter}({self.name}[j]);\n" \
            + INDENTL1 + "}\n" \
            + INDENTL1 + f"objectlist* {self.morpho_object} = object_newlist((int) {self.name}_n, {self.name}_value);\n"
</code></pre>
<p>The above will generate the C code:</p>
<pre><code class="language-c">    value tags_value[(int) tags_n];
    for (size_t j=0; j&lt;tags_n; j++) {
        tags_value[j] = MORPHO_INTEGER(tags[j]);
    }
    objectlist* tags_list = object_newlist((int) tags_n, tags_value);
</code></pre>
<p>The <code>return_output</code> method returns the captured outputs:</p>
<pre><code class="language-python"># GenApi.py, class ovectorint
    def return_output(self):
        return INDENTL1 + "value out;\n" \
            + INDENTL1 + f"if ({self.name}_list) " + "{\n" \
            + INDENTL2 + f"out = MORPHO_OBJECT({self.name}_list);\n" \
            + INDENTL2 + f"morpho_bindobjects(v, 1, &amp;out);\n" \
            + INDENTL1 + "}\n" \
            + INDENTL1 + "return out;\n"
</code></pre>
<p>which generates</p>
<pre><code class="language-c">    value out;
    if (tags_list) {
        out = MORPHO_OBJECT(tags_list);
        morpho_bindobjects(v, 1, &amp;out);
    }
    return out;
</code></pre>
<blockquote>
<p><strong>Note</strong>: A few Gmsh C functions have a non-void return type, and hence return &gt;something directly instead of through pointers. For example,</p>
<pre><code class="language-c">/* Return 1 if the Gmsh API is initialized, and 0 if not. */
GMSH_API int gmshIsInitialized(int * ierr);
</code></pre>
<p>These are handled directly while writing the module.</p>
</blockquote>
<div class="warning">
<p>The handling of cases where the function returns outputs both directly and via pointers is not implemented yet. But as of 4.12.2 (at the time of writing), there is only one function, <code>gmshFltkSelectEntities</code>, in the entire API that does this, and since it is an FLTK-related function, we will probably not use it through the API in Morpho. This should still be implemented in the future.</p>
</div>
<p>Here are the Morpho values types returned for the corresponding C types:</p>
<div class="table-wrapper"><table><thead><tr><th>C-Type</th><th>Morpho-Type</th></tr></thead><tbody>
<tr><td><code>int</code></td><td><code>MORPHO_INTEGER</code></td></tr>
<tr><td><code>size_t</code></td><td><code>MORPHO_INTEGER</code></td></tr>
<tr><td><code>double</code></td><td><code>MORPHO_FLOAT</code></td></tr>
<tr><td><code>char *</code></td><td><code>MORPHO_STRING</code></td></tr>
</tbody></table>
</div>
<p>All vector outputs are returned as Morpho <code>List</code>'s. For example, an <code>ovectordouble</code> would be returned as a Morpho <code>List</code> of Morpho <code>Float</code>s, <code>ovectorvectorint</code> would be <code>List</code> of <code>List</code> of <code>MORPHO_INTEGER</code>'s, and so on. For the list of lists, we need a separate operation to collect all the outputs and return it. We write functions for this inside our <code>write_morpho</code> method:</p>
<pre><code class="language-python">def collect_list_of_outputs(oargs):
    l = INDENTL1 + f"value outval[{len(oargs)}];\n"
    for j, oarg in enumerate(oargs):
        l += INDENTL1 + f"outval[{j}] = MORPHO_OBJECT({oarg.morpho_object});\n"
    l += INDENTL1 + f"objectlist* outlist = object_newlist({len(oargs)}, outval);\n"
    self.fwrite(f, l)
    return

def return_list_of_outputs():
    l = INDENTL1 + "value out;\n" \
      + INDENTL1 + f"if (outlist) " + "{\n" \
      + INDENTL2 + f"out = MORPHO_OBJECT(outlist);\n" \
      + INDENTL2 + f"morpho_bindobjects(v, 1, &amp;out);\n" \
      + INDENTL1 + "}\n" \
      + INDENTL1 + "return out;\n"
    self.fwrite(f, l)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="auto-generating-inline-documentation"><a class="header" href="#auto-generating-inline-documentation">Auto-generating inline documentation</a></h1>
<p>Morpho documentation is written in the Markdown format (see <a href="apiAutogeneration/./skeleton.html#help-file">the first section of this chapter</a>). The <code>gen.py</code> file already provides doc-strings for all the functions. In addition to writing them to our help file, we also write the call-signature and I/O parameters to the help file. This clarifies the order of the inputs since this information is not provided in the doc-strings.</p>
<p>Here is a sample output:</p>
<pre><code class="language-markdown">## gmshWrite

[taggmshWrite]: # "gmshWrite"

Call signature:
gmshWrite(fileName)

Arguments:
fileName (string)

Returns:
nil

Write a file. The export format is determined by the file extension.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-it-all-to-the-files"><a class="header" href="#writing-it-all-to-the-files">Writing it all to the files</a></h1>
<p>Now, we will see how the <code>write_module</code> method of the <code>write_morpho</code> method (actually called <code>write_python</code> to use <code>gen.py</code> as is) writes all the functions to the <code>.c</code>, <code>.h</code> and <code>.md</code> files.</p>
<p>The full structure, although long, is pretty straightforward:</p>
<pre><code class="language-python"># GenApi.py
class API:
    ...
    def write_python(self):
        """
        This method is actually `write_morpho`, but is named `write_python` so that
        we can run `gen.py` directly without modification.
        """

        method_names = [] # List to collect method names

        def collect_list_of_outputs(oargs):
            """
            Collect outputs in a Morpho list
            """

        def return_list_of_outputs():
            """
            Return the list of outputs
            """
        ...
        def write_module(module, c_namespace):

            # Collect all the inputs
            iargs = ...
            oargs = ...

            # Colelct all the outputs
            #
            # Create the Morpho function name
            # Write help for this function to the file
            fnamemorpho = ...
            method_names.append(fnamemorpho)
            # Write function definition to the C-file
            # Write checks for number and type of input arguments

            # Capture all the inputs
            for i,iarg in enumerate(iargs):
                self.fwrite(f, iarg.capture_input(i))

            # Initialize the outputs
            for i,oarg in enumerate(oargs):
                self.fwrite(f, oarg.init_output())

            # Create the C function call
            # Write the function call, accounting for direct return values if any.

            # Capture and return output
            # Write the return statement
            if len(oargs)==0 and not rtype: ## If there's nothing to return, return MORPHO_NIL
                self.fwrite(f, INDENTL1 + "return MORPHO_NIL;\n")
            elif len(oargs)==0 and rtype: ## If there are no outputs, but the function returns something, return the value
                self.fwrite(f, INDENTL1 + f"return {rtype.cToMorphoConverter}(outval);\n")
            for oarg in oargs: ## If there are outputs, we need to first capture them as Morpho values.
                self.fwrite(f, oarg.capture_output())
            if (len(oargs)==1): ## If there's only one output, return it
                self.fwrite(f, oargs[0].return_output())
            elif (len(oargs)&gt;1): ## If there are multiple outputs, collect them in a Morpho List and return it
                collect_list_of_outputs(oargs)
                return_list_of_outputs()

        # Recursively write all the submodules
        for m in module.submodules:
            write_module(m, c_namespace)


    # We will first write to the C and MD files simultaneously, and collect the function names, etc for writing the Header file
    # Simultanously open the C file and the help file as we need to add the methods one by one
    with open("../src/" + f"{EXTENSION_NAME}.c", "w") as f, \
         open("../share/help/" + f"{EXTENSION_NAME}.md", "w") as hlp:

         # Write header-material to the files

         # Write all the modules

         # Write the footer for the C file
         # Write the initialize method
         # Add all the functions
         for method in method_names:
             self.fwrite(f, INDENTL1 + f"builtin_addfunction({method.upper()}_FUNCTION, {method}, BUILTIN_FLAGSEMPTY);\n")
         # Add the error definitions.
         self.fwrite(f, cmorpho_error_def)
         self.fwrite(f, "\n}\n")
         # Write the finalize method
         self.fwrite(f, cmorpho_footer)

         # Now, write the header file
         with open("../src/" + f"{EXTENSION_NAME}.h", "w") as fh:
             # Write the header-material for the header file
             # This currently also defines the Errors.
             for method in method_names:
                 # Define all the function names

        # And that's it!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementation-of-the-gmsh-module-in-morpho"><a class="header" href="#implementation-of-the-gmsh-module-in-morpho">Implementation of the <code>gmsh</code> module in Morpho</a></h1>
<p><em>This section is a work in progress (see <a href="./to_dos.html">the to-do's</a>).</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="some-to-dos"><a class="header" href="#some-to-dos">Some To-do's</a></h1>
<p>Here are some desirable features not implemented yet.</p>
<h2 id="the-gmshapi-module"><a class="header" href="#the-gmshapi-module">The <code>gmshapi</code> module</a></h2>
<ol>
<li>The <code>ivoidstar</code> (pointer) input needs to be handled. This occurs only in one function as of version 4.12.2, the <code>gmshModelOccImportShapesNativePointer</code> method. As this is not implemented yet, we skip this method in the API.</li>
<li>Same as above, but for the <code>isizefun</code> input (a function input). This also occurs for one function, <code>gmshModelMeshSetSizeCallback</code>, that we skip currently.</li>
<li>The <code>ivoidstar</code> and <code>isizefun</code> need to be implemented also as subclasses of <code>inputArg</code>, so that we can skip any new function that has this input by looking for the input's class name. (or just finish 1. and 2.!)</li>
<li>Handle functions which return both directly (an <code>int</code>, for example, in <code>gmshIsInitialized</code>) and via pointers. Currently, we skip them (again, only one function in the FLTK module, so doesn't affect our use case all that much right now).</li>
<li>Add more specific <code>Error</code>'s. Currently, there is a single error for incorrect type of arguments, so it is not very helpful.</li>
<li>Currently, <em>all</em> the methods fall under <code>gmshapi</code>'s subtopics, whereas it would be nice if the help is also organized by the submodules. We need to add this functionality.</li>
</ol>
<h2 id="the-gmsh-module"><a class="header" href="#the-gmsh-module">The <code>gmsh</code> module</a></h2>
<p>The <code>gmsh</code> module needs to be made in a "Morphonic" way, in the style of Morpho's own <code>meshgen</code> module. This requires a considerable thought on the design, and remains to be implemented. Currently, the <code>gmsh</code> module simply provides <em>one</em> (pretty central) functionality: converting gmsh meshes to Morpho meshes!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
