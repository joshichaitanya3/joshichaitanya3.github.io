<!DOCTYPE HTML>
<html lang="es" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Morpho Manual</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/css/language-picker.css">

        <!-- MathJax -->
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({
            TeX: { 
                equationNumbers: { 
                    autoNumber: "AMS",
                }
            }
        });
        </script>
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="foreword.html">Introducción</a></li><li class="chapter-item "><a href="overview.html"><strong aria-hidden="true">1.</strong> Descripción general</a></li><li class="chapter-item "><a href="installing_morpho.html"><strong aria-hidden="true">2.</strong> Instalación de Morpho</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="installing/homebrew.html"><strong aria-hidden="true">2.1.</strong> Instalación via homebrew</a></li><li class="chapter-item "><a href="installing/source.html"><strong aria-hidden="true">2.2.</strong> Instalación con el código fuente</a></li><li class="chapter-item "><a href="installing/wsl.html"><strong aria-hidden="true">2.3.</strong> Windows a través del subsistema de Windows para Linux (WSL)</a></li><li class="chapter-item "><a href="installing/updating.html"><strong aria-hidden="true">2.4.</strong> Actualización de morpho</a></li><li class="chapter-item "><a href="installing/uninstalling.html"><strong aria-hidden="true">2.5.</strong> Desinstalación de morpho</a></li></ol></li><li class="chapter-item "><a href="using_morpho.html"><strong aria-hidden="true">3.</strong> Usando Morpho</a></li><li class="chapter-item "><a href="tutorial.html"><strong aria-hidden="true">4.</strong> Tutorial</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tutorial/importing_modules.html"><strong aria-hidden="true">4.1.</strong> Importación de módulos</a></li><li class="chapter-item "><a href="tutorial/morpho_language.html"><strong aria-hidden="true">4.2.</strong> El lenguaje Morpho</a></li><li class="chapter-item "><a href="tutorial/creating_the_initial_mesh.html"><strong aria-hidden="true">4.3.</strong> Creación de la malla inicial</a></li><li class="chapter-item "><a href="tutorial/selections.html"><strong aria-hidden="true">4.4.</strong> Selecciones</a></li><li class="chapter-item "><a href="tutorial/fields.html"><strong aria-hidden="true">4.5.</strong> Campos</a></li><li class="chapter-item "><a href="tutorial/defining_the_problem.html"><strong aria-hidden="true">4.6.</strong> Definición del problema</a></li><li class="chapter-item "><a href="tutorial/performing_the_optimization.html"><strong aria-hidden="true">4.7.</strong> Realizando la optimización</a></li><li class="chapter-item "><a href="tutorial/visualizing_the_results.html"><strong aria-hidden="true">4.8.</strong> Visualización de los resultados</a></li><li class="chapter-item "><a href="tutorial/refinement.html"><strong aria-hidden="true">4.9.</strong> Refinamiento</a></li><li class="chapter-item "><a href="tutorial/next_steps.html"><strong aria-hidden="true">4.10.</strong> Siguientes pasos</a></li></ol></li><li class="chapter-item "><a href="working_with_meshes.html"><strong aria-hidden="true">5.</strong> Trabajando con mallas</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="working_with_meshes/meshgen_module.html"><strong aria-hidden="true">5.1.</strong> El módulo meshgen</a></li><li class="chapter-item "><a href="working_with_meshes/meshtools_module.html"><strong aria-hidden="true">5.2.</strong> El módulo meshtools</a></li><li class="chapter-item "><a href="working_with_meshes/vtk_module.html"><strong aria-hidden="true">5.3.</strong> El módulo vtk</a></li><li class="chapter-item "><a href="working_with_meshes/merging_meshes.html"><strong aria-hidden="true">5.4.</strong> Uniendo mallas</a></li><li class="chapter-item "><a href="working_with_meshes/slicing_meshes.html"><strong aria-hidden="true">5.5.</strong> Seleccionando mallas</a></li></ol></li><li class="chapter-item "><a href="visualization.html"><strong aria-hidden="true">6.</strong> Visualización</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="visualization/plot_module.html"><strong aria-hidden="true">6.1.</strong> El módulo de visualización</a></li><li class="chapter-item "><a href="visualization/graphics_module.html"><strong aria-hidden="true">6.2.</strong> El módulo de gráficos</a></li><li class="chapter-item "><a href="visualization/povray_module.html"><strong aria-hidden="true">6.3.</strong> El módulo povray</a></li></ol></li><li class="chapter-item "><a href="examples.html"><strong aria-hidden="true">7.</strong> Ejemplos</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="examples/catenoid.html"><strong aria-hidden="true">7.1.</strong> Catenoide</a></li><li class="chapter-item "><a href="examples/cholesteric.html"><strong aria-hidden="true">7.2.</strong> Colestérico</a></li><li class="chapter-item "><a href="examples/cube.html"><strong aria-hidden="true">7.3.</strong> Cubo</a></li><li class="chapter-item "><a href="examples/delaunay.html"><strong aria-hidden="true">7.4.</strong> Delaunay</a></li><li class="chapter-item "><a href="examples/dla.html"><strong aria-hidden="true">7.5.</strong> DLA</a></li><li class="chapter-item "><a href="examples/electrostatics.html"><strong aria-hidden="true">7.6.</strong> Electrostática</a></li><li class="chapter-item "><a href="examples/implicitmesh.html"><strong aria-hidden="true">7.7.</strong> Implicitmesh</a></li><li class="chapter-item "><a href="examples/meshgen.html"><strong aria-hidden="true">7.8.</strong> Meshgen</a></li><li class="chapter-item "><a href="examples/meshslice.html"><strong aria-hidden="true">7.9.</strong> Meshslice</a></li><li class="chapter-item "><a href="examples/plot.html"><strong aria-hidden="true">7.10.</strong> Plot</a></li><li class="chapter-item "><a href="examples/povray.html"><strong aria-hidden="true">7.11.</strong> Povray</a></li><li class="chapter-item "><a href="examples/qtensor.html"><strong aria-hidden="true">7.12.</strong> QTensor</a></li><li class="chapter-item "><a href="examples/thomson.html"><strong aria-hidden="true">7.13.</strong> Thomson</a></li><li class="chapter-item "><a href="examples/wrap.html"><strong aria-hidden="true">7.14.</strong> Envolver</a></li></ol></li><li class="chapter-item "><a href="reference.html"><strong aria-hidden="true">8.</strong> Referencias</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/language.html"><strong aria-hidden="true">8.1.</strong> Idioma</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/nested/syntax.html"><strong aria-hidden="true">8.1.1.</strong> Sintaxis</a></li><li class="chapter-item "><a href="reference/nested/values.html"><strong aria-hidden="true">8.1.2.</strong> Valores</a></li><li class="chapter-item "><a href="reference/nested/variables.html"><strong aria-hidden="true">8.1.3.</strong> Variables</a></li><li class="chapter-item "><a href="reference/nested/controlflow.html"><strong aria-hidden="true">8.1.4.</strong> Flujo de control</a></li><li class="chapter-item "><a href="reference/nested/functions.html"><strong aria-hidden="true">8.1.5.</strong> Funciones</a></li><li class="chapter-item "><a href="reference/nested/classes.html"><strong aria-hidden="true">8.1.6.</strong> Clases</a></li><li class="chapter-item "><a href="reference/nested/modules.html"><strong aria-hidden="true">8.1.7.</strong> Módulos</a></li><li class="chapter-item "><a href="reference/nested/help.html"><strong aria-hidden="true">8.1.8.</strong> Ayuda</a></li><li class="chapter-item "><a href="reference/nested/errors.html"><strong aria-hidden="true">8.1.9.</strong> Errores</a></li><li class="chapter-item "><a href="reference/nested/builtin.html"><strong aria-hidden="true">8.1.10.</strong> Funciones integradas</a></li></ol></li><li class="chapter-item "><a href="reference/data_types.html"><strong aria-hidden="true">8.2.</strong> Tipos de datos</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/nested/array.html"><strong aria-hidden="true">8.2.1.</strong> Array</a></li><li class="chapter-item "><a href="reference/nested/complex.html"><strong aria-hidden="true">8.2.2.</strong> Complejo</a></li><li class="chapter-item "><a href="reference/nested/list.html"><strong aria-hidden="true">8.2.3.</strong> Lista</a></li><li class="chapter-item "><a href="reference/nested/matrix.html"><strong aria-hidden="true">8.2.4.</strong> Matriz</a></li><li class="chapter-item "><a href="reference/nested/range.html"><strong aria-hidden="true">8.2.5.</strong> Rango</a></li><li class="chapter-item "><a href="reference/nested/sparse.html"><strong aria-hidden="true">8.2.6.</strong> Sparse</a></li><li class="chapter-item "><a href="reference/nested/string.html"><strong aria-hidden="true">8.2.7.</strong> Cuerda (String)</a></li><li class="chapter-item "><a href="reference/nested/tuple.html"><strong aria-hidden="true">8.2.8.</strong> Tupla</a></li></ol></li><li class="chapter-item "><a href="reference/computational_geometry.html"><strong aria-hidden="true">8.3.</strong> Geometría Computacional</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/nested/field.html"><strong aria-hidden="true">8.3.1.</strong> Campo</a></li><li class="chapter-item "><a href="reference/nested/functionals.html"><strong aria-hidden="true">8.3.2.</strong> Funcionales</a></li><li class="chapter-item "><a href="reference/nested/mesh.html"><strong aria-hidden="true">8.3.3.</strong> Malla</a></li><li class="chapter-item "><a href="reference/nested/selection.html"><strong aria-hidden="true">8.3.4.</strong> Selección</a></li></ol></li><li class="chapter-item "><a href="reference/io.html"><strong aria-hidden="true">8.4.</strong> E/S</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/nested/file.html"><strong aria-hidden="true">8.4.1.</strong> Archivo</a></li><li class="chapter-item "><a href="reference/nested/json.html"><strong aria-hidden="true">8.4.2.</strong> JSON</a></li></ol></li><li class="chapter-item "><a href="reference/modules.html"><strong aria-hidden="true">8.5.</strong> Módulos</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/nested/color.html"><strong aria-hidden="true">8.5.1.</strong> Color</a></li><li class="chapter-item "><a href="reference/nested/constants.html"><strong aria-hidden="true">8.5.2.</strong> Constantes</a></li><li class="chapter-item "><a href="reference/nested/delaunay.html"><strong aria-hidden="true">8.5.3.</strong> Delaunay</a></li><li class="chapter-item "><a href="reference/nested/graphics.html"><strong aria-hidden="true">8.5.4.</strong> Gráficos</a></li><li class="chapter-item "><a href="reference/nested/implicitmesh.html"><strong aria-hidden="true">8.5.5.</strong> Implicitmesh</a></li><li class="chapter-item "><a href="reference/nested/kdtree.html"><strong aria-hidden="true">8.5.6.</strong> KDTree</a></li><li class="chapter-item "><a href="reference/nested/meshgen.html"><strong aria-hidden="true">8.5.7.</strong> MeshGen</a></li><li class="chapter-item "><a href="reference/nested/meshslice.html"><strong aria-hidden="true">8.5.8.</strong> Meshslice</a></li><li class="chapter-item "><a href="reference/nested/meshtools.html"><strong aria-hidden="true">8.5.9.</strong> Meshtools</a></li><li class="chapter-item "><a href="reference/nested/optimize.html"><strong aria-hidden="true">8.5.10.</strong> Optimizar</a></li><li class="chapter-item "><a href="reference/nested/plot.html"><strong aria-hidden="true">8.5.11.</strong> Plot</a></li><li class="chapter-item "><a href="reference/nested/povray.html"><strong aria-hidden="true">8.5.12.</strong> POVRay</a></li><li class="chapter-item "><a href="reference/nested/vtk.html"><strong aria-hidden="true">8.5.13.</strong> VTK</a></li><li class="spacer"></li></ol></li></ol></li><li class="chapter-item "><a href="mdbook_notes.html">Acerca de esta versión en línea</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Morpho Manual</h1>

                    <div class="right-buttons">
                        <button id="language-toggle" class="icon-button" type="button"
                                title="Change language" aria-label="Change language"
                                aria-haspopup="true" aria-expanded="false"
                                aria-controls="language-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="language-list" class="theme-popup" aria-label="Languages" role="menu">
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="en">English</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="es">Spanish (Español)</a>
                          </button></li>
                        </ul>
                        <script>
                          let langToggle = document.getElementById("language-toggle");
                          let langList = document.getElementById("language-list");
                          langToggle.addEventListener("click", (event) => {
                              langList.style.display = langList.style.display == "block" ? "none" : "block";
                          });
                          let selectedLang = document.getElementById("es");
                          selectedLang.parentNode.classList.add("theme-selected");

                          // The path to the root, taking the current
                          // language into account.
                          let full_path_to_root = "../";
                          // The page path (mdbook only gives us
                          // access to the path to the Markdown file).
                          let path = "print.md".replace(/\.md$/, ".html");
                          for (let lang of langList.querySelectorAll("a")) {
                              if (lang.id == "en") {
                                  lang.href = `${full_path_to_root}${path}`;
                              } else {
                                  lang.href = `${full_path_to_root}${lang.id}/${path}`;
                              }
                          }
                        </script>
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/joshichaitanya3/morpho-manual" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><img src="Figures/morphologosmall.png" alt="image" /></p>
<h2 id="versión-060"><a class="header" href="#versión-060">Versión 0.6.0</a></h2>
<p><em>In nova fert animus mutatas dicere formas</em></p>
<p><em>corpora; di, coeptis (nam vos mutastis et illas)</em></p>
<p><em>adspirate meis primaque ab origine mundi</em></p>
<p><em>ad mea perpetuum deducite tempora carmen!</em></p>
<p>--- Ovid, <em>Metamorphoses</em></p>
<h2 id="acknowledgements" class="unnumbered"><a class="header" href="#acknowledgements">Agradecimientos</a></h2>
<p>El arquitecto principal de <em>morpho</em>, T J Atherton, desea agradecer a las muchas personas que han utilizado varias versiones del programa o han contribuido al proyecto:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Andrew DeBenedictis</td><td>Danny Goldstein</td></tr>
<tr><td>Ian Cazador</td><td>Chaitanya Joshi</td></tr>
<tr><td>Cole Wennerholm</td><td>Eoghan Downey</td></tr>
<tr><td>Allison Culbert</td><td>Abigail Wilson</td></tr>
<tr><td>Zhaoyu Xie</td><td>Matthew Peterson</td></tr>
<tr><td>Chris Burke</td><td>Badel Mbanga</td></tr>
<tr><td>Anca Andrei</td><td>Mateo Giso</td></tr>
<tr><td>Sam Hocking</td><td>Emmett Hamilton</td></tr>
<tr><td>Hudson Ramírez</td><td>Paco Navarro</td></tr>
<tr><td>Emmanuel Flores</td><td></td></tr>
</tbody></table>
</div>
<p><em>Este material se basa en el trabajo apoyado por la Fundación Nacional de Ciencias bajo las subvenciones DMR-1654283 y OAC-2003820.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="descripción-general"><a class="header" href="#descripción-general">Descripción general</a></h1>
<p><em>Morpho</em> tiene como objetivo resolver la siguiente clase de problemas. Considere un funcional, $$F=\int_{C}f(q,\nabla q,\nabla^{2}q,...) d^{n}x+\int_{\partial C}g(q,\nabla q,\nabla^{2}q,...) d^{n-1}x,$$ donde \(q\) representa un conjunto de campos definidos en una variedad \(C\), la cual podría incluir escalares, vectores, tensores u otras cantidades y sus derivadas \(\nabla^{n}q\). El funcional incluye términos en el interior y en la frontera \(\partial C\) y también puede incluir propiedades geométricas de la variedad, como curvaturas locales. Este funcional debe minimizarse a partir de una valor inicial propuesto \( \{ C_{0},q_{0} \}\) con respecto a los campos \(q\) y la forma de la variedad \(C\). Se pueden imponer restricciones globales y locales tanto en \(C\) como en \(q\).</p>
<p><em>Morpho</em> es un entorno orientado a objetos: todos los componentes del problema, incluyendo el dominio computacional, los campos, los funcionales, etc., se representan como objetos que interactúan entre sí. Gran parte del esfuerzo en la escritura de un programa en <em>morpho</em> implica la creación y manipulación de estos objetos. El entorno es flexible, modular y los usuarios pueden crear fácilmente nuevos tipos de objetos o cambiar por completo el funcionamiento de <em>morpho</em>.</p>
<p>Este manual tiene como objetivo ayudar a los usuarios a aprender a usar <em>morpho</em>. Proporciona instrucciones de instalación en <a href="installing_morpho.html">Capítulo 2</a>, información sobre cómo ejecutar el programa en <a href="using_morpho.html">Capítulo 3</a>. En el <a href="tutorial.html">Capítulo 4</a> se proporciona un tutorial detallado que muestra cómo configurar y resolver un problema de ejemplo. <a href="working_with_meshes.html">Capítulo 5</a> proporciona información sobre cómo trabajar con mallas y <a href="visualization.html">Capítulo 6</a> describe cómo visualizar los resultados de su cálculo con <em>morpho</em>. Los ejemplos proporcionados con morpho se describen en el <a href="examples.html">Capítulo 7</a>. Los capítulos restantes, que comprenden la segunda parte del manual, proporcionan una guía de referencia para todas las áreas de la funcionalidad de <em>morpho</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="instalación-de-morpho"><a class="header" href="#instalación-de-morpho">Instalación de <em>Morpho</em></a></h1>
<p><em>Morpho</em> está alojado en un repositorio de github disponible públicamente <a href="https://github.com/Morpho-lang/morpho">https://github.com/Morpho-lang/morpho</a>. <em>Morpho</em> también requiere dos programas subsidiarios, una aplicación de terminal alojada en <a href="https://github.com/Morpho-lang/morpho-cli">https://github.com/Morpho-lang/morpho-cli</a> y una aplicación de visualización <a href="https://github.com/Morpho-lang/morpho-morphoview">https://github.com/Morpho-lang/morpho-morphoview</a>. <em>Morpho</em> es extensible, y los paquetes que proporcionan funcionalidad adicional se alojan en repositorios de git.</p>
<p>Para esta versión, <em>morpho</em> se puede instalar en todas las plataformas compatibles utilizando el administrador de paquetes homebrew. Alternativamente, el programa se puede instalar desde la fuente como se describe a continuación. Estamos trabajando continuamente para mejorar la instalación de <em>morpho</em> y esperamos proporcionar mecanismos adicionales para la instalación en las próximas versiones.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="instalación-via-homebrew"><a class="header" href="#instalación-via-homebrew">Instalación via homebrew</a></h2>
<p>La forma más sencilla de instalar <em>morpho</em> es a través del <a href="https://brew.sh">administrador de paquetes homebrew</a>. Para ello:</p>
<ol>
<li>
<p>Si aún no está instalado, instale homebrew en su máquina como se describe en el <a href="https://brew.sh">sitio web de homebrew</a>.</p>
</li>
<li>
<p>Abra un terminal y escriba:</p>
<pre><code>brew update
brew tap morpho-lang/morpho
brew install morpho
</code></pre>
</li>
</ol>
<p>Si necesita desinstalar morpho, simplemente abra una terminal y escriba <code>brew uninstall morpho</code>. Es muy importante desinstalar el homebrew morpho de esta manera <em>antes</em> de intentar instalarlo desde la fuente como se muestra a continuación.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="instalación-desde-el-código-fuente"><a class="header" href="#instalación-desde-el-código-fuente">Instalación desde el código fuente</a></h2>
<p>La segunda forma de instalar morpho es compilando el código fuente directamente. Morpho ahora aprovecha el sistema de compilación <a href="https://cmake.org">CMake</a>, que permite compilaciones independientes de la plataforma.</p>
<h4 id="manera-en-la-que-la-instalación-de-código-fuente-morpho-pone-las-cosas"><a class="header" href="#manera-en-la-que-la-instalación-de-código-fuente-morpho-pone-las-cosas">Manera en la que la instalación de código fuente <em>morpho</em> pone las cosas</a></h4>
<p>Una instalación <em>morpho</em> incluye archivos de ayuda, módulos y otros recursos. De forma predeterminada, se instalan en la estructura de archivos <strong>/usr/local/</strong> de la siguiente manera:</p>
<p><strong>/usr/local/bin</strong> : Aquí se colocan los ejecutables morpho y morphoview.</p>
<p><strong>/usr/local/share/morpho</strong> : Aquí se almacenan los archivos y módulos de ayuda.</p>
<p><strong>/usr/local/include/morpho</strong> : Archivos de cabecera de Morpho para construir extensiones.</p>
<p><strong>/usr/local/lib/morpho</strong> : Extensiones de Morpho.</p>
<h3 id="recopilación-de-dependencias"><a class="header" href="#recopilación-de-dependencias">Recopilación de dependencias</a></h3>
<p><em>Morpho</em> requiere algunas bibliotecas para proporcionar cierta funcionalidad:</p>
<p><strong>blas/lapack</strong> : se utilizan para cálculos demandantes de álgebra lineal.</p>
<p><strong>suitesparse</strong> : se utiliza para álgebra lineal dispersa.</p>
<blockquote>
<p>Consulte <a href="https://people.engr.tamu.edu/davis/suitesparse.html">https://people.engr.tamu.edu/davis/suitesparse.html</a> y publicaciones para obtener más detalles</p>
</blockquote>
<p><strong>povray</strong> : es un trazador de rayos que se utiliza para gráficos con calidad de publicación (solo requerido por el módulo 'Povray').</p>
<p>La aplicación de terminal utiliza</p>
<p><strong>libgrapheme</strong> <em>o</em>,</p>
<p><strong>libunistring</strong>: para soporte de grafemas Unicode.</p>
<p><em>Morphoview</em> requiere adicionalmente</p>
<p><strong>glfw</strong> : para proporcionar la funcionalidad de la interfaz gráfica de usuario.</p>
<p><strong>freetype</strong> : Proporciona visualización de texto.</p>
<p>Cada una de estas dependencias se puede instalar utilizando cualquier administrador de paquetes adecuado.</p>
<ul>
<li>
<p>Homebrew (preferido en macOS):</p>
<pre><code>brew update
brew install glfw suite-sparse freetype povray libgrapheme
</code></pre>
</li>
<li>
<p>Apt (preferido en Ubuntu):</p>
<pre><code>sudo apt update
sudo apt upgrade
sudo apt install build-essential
sudo apt install libglfw3-dev libsuitesparse-dev liblapacke-dev povray libfreetype6-dev libunistring-dev
</code></pre>
</li>
</ul>
<h4 id="compilar-la-biblioteca-compartida-morpho"><a class="header" href="#compilar-la-biblioteca-compartida-morpho">Compilar la biblioteca compartida morpho</a></h4>
<p>La pieza central de <em>morpho</em> es una biblioteca compartida, que luego puede ser utilizada por múltiples aplicaciones. Para construirla,</p>
<ol>
<li>
<p>Obtenga el código fuente clonando el repositorio público de github:</p>
<pre><code>git clone https://github.com/Morpho-lang/morpho.git
</code></pre>
</li>
<li>
<p>Navegue a la carpeta 'morpho' y construya la biblioteca:</p>
<pre><code>cd morpho
mkdir build
cd build
cmake -DCMAKE_BUILD_TYPE=Release ..
sudo make install
</code></pre>
</li>
<li>
<p>Vuelva a salir de la carpeta morpho:</p>
<pre><code>cd ../../
</code></pre>
</li>
</ol>
<h4 id="compilar-la-aplicación-de-terminal-morpho"><a class="header" href="#compilar-la-aplicación-de-terminal-morpho">Compilar la aplicación de terminal morpho</a></h4>
<p>La aplicación de terminal proporciona una interfaz interactiva para <em>morpho</em> y también puede ejecutar archivos morpho.</p>
<ol>
<li>
<p>Obtenga el código fuente clonando el repositorio público de github:</p>
<pre><code>git clone https://github.com/Morpho-lang/morpho-cli.git
</code></pre>
</li>
<li>
<p>Vaya a la carpeta 'morpho-cli' y construya la biblioteca:</p>
<pre><code>cd morpho-cli
mkdir build
cd build
cmake -DCMAKE_BUILD_TYPE=Release ..
sudo make install
</code></pre>
</li>
<li>
<p>Comprueba que funciona escribiendo:</p>
<pre><code>morpho6
</code></pre>
</li>
<li>
<p>Suponiendo que la aplicación de terminal morpho se inicia correctamente, escriba <code>quit</code> para volver al shell y luego</p>
<pre><code>cd ../../
</code></pre>
<p>para volver a salir de la carpeta morpho-cli.</p>
</li>
</ol>
<h4 id="compilar-la-aplicación-de-visor-morphoview"><a class="header" href="#compilar-la-aplicación-de-visor-morphoview">Compilar la aplicación de visor morphoview</a></h4>
<p><em>Morphoview</em> es una sencilla aplicación de visualización para visualizar los resultados de <em>morpho</em>.</p>
<ol>
<li>
<p>Obtenga el código fuente clonando el repositorio público de github:</p>
<pre><code>git clone https://github.com/Morpho-lang/morpho-morphoview.git
</code></pre>
</li>
<li>
<p>Vaya a la carpeta 'morpho-cli' y construya la biblioteca:</p>
<pre><code>cd morpho-morphoview
mkdir build
cd build
cmake -DCMAKE_BUILD_TYPE=Release ..
sudo make install
</code></pre>
</li>
<li>
<p>Comprueba que funciona escribiendo:</p>
<pre><code>morphoview
</code></pre>
<p>que simplemente debería ejecutarse y salir normalmente. A continuación, puede escribir</p>
<pre><code>cd ../../
</code></pre>
<p>para volver a salir de la carpeta morpho-morphoview.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="windows-a-través-del-subsistema-de-windows-para-linux-wsl"><a class="header" href="#windows-a-través-del-subsistema-de-windows-para-linux-wsl">Windows a través del subsistema de Windows para Linux (WSL)</a></h2>
<p>La compatibilidad con Windows se proporciona a través del Subsistema de Windows para Linux (WSL), que es un entorno que permite a Windows ejecutar aplicaciones de Linux. Se recomienda encarecidamente usar WSL2, que es la versión más reciente y proporciona una mejor compatibilidad con las aplicaciones GUI; a continuación se proporcionan algunas instrucciones para WSL1.</p>
<ol>
<li>
<p>Comience instalando la <a href="https://ubuntu.com/desktop/wsl">Aplicación Ubuntu</a> desde la tienda de Microsoft. Siga todos los pasos de este enlace para asegurarse de que los gráficos funcionan.</p>
</li>
<li>
<p>Una vez que el terminal de Ubuntu esté funcionando en Windows, puede instalar <em>morpho</em> a través de homebrew o construyendo desde el código fuente.</p>
</li>
</ol>
<h4 id="gráficos-en-wsl1"><a class="header" href="#gráficos-en-wsl1">Gráficos en WSL1</a></h4>
<p>Si, en cambio, está trabajando en WSL1, debe seguir estas instrucciones para que se ejecuten los gráficos. A menos que se indique lo contrario, todos los comandos a continuación se ejecutan en la terminal de Ubuntu.</p>
<ol>
<li>
<p>Se debe instalar un administrador de ventanas para que WSL pueda crear ventanas. En Windows, instale <a href="https://sourceforge.net/projects/vcxsrv/">VcXsrv</a>. Aparece como XLaunch en el menú de inicio de Windows.</p>
</li>
<li>
<p>Ejecute Xlaunch. Entonces,</p>
<ol>
<li>
<p>elija <code>Múltiples ventanas</code>, establezca el número de pantalla en 0 y presione <code>Siguiente</code></p>
</li>
<li>
<p>elija <code>no iniciar ningún cliente</code> y presione <code>Siguiente</code></p>
</li>
<li>
<p><strong>Anule la selección</strong> de <code>opengl nativo</code> y pulse <code>Siguiente</code></p>
</li>
<li>
<p>Clic "Finalizar"</p>
</li>
</ol>
</li>
<li>
<p>En Ubuntu, descargue un paquete que contiene un conjunto completo de utilidades de escritorio que permite el uso de Windows.</p>
<pre><code>sudo apt install ubuntu-desktop mesa-utils
</code></pre>
<p>Dígale a ubuntu qué pantalla usar</p>
<pre><code>export DISPLAY=localhost:0
</code></pre>
<p>Para establecer la variable DISPLAY en el tipo de inicio de sesión</p>
<pre><code>echo export DISPLAY=localhost:0 &gt;&gt; ~/.bashrc 
</code></pre>
<p><em>[Tenga en cuenta que esto supone que está usando bash como su terminal; puede ajustar esta línea para otros terminales].</em></p>
</li>
<li>
<p>Pruebe que el sistema de ventanas funciona ejecutando</p>
<pre><code>glxgears
</code></pre>
<p>que debería abrir una ventana con algunos engranajes.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="actualización-de-morpho"><a class="header" href="#actualización-de-morpho">Actualización de <em>morpho</em></a></h2>
<p>A medida que se publiquen nuevas versiones de <em>morpho</em>, es probable que desee actualizar a la última versión. Desde la terminal:</p>
<ul>
<li>
<p>Si usaste homebrew para instalar morpho, simplemente escribe,</p>
<pre><code>brew upgrade morpho
</code></pre>
</li>
<li>
<p>Si usted instaló <em>morpho</em> manualmente, y todavía tienes la carpeta del repositorio git en tu computadora, navega hasta ella con <code>cd</code> y escribe,</p>
<pre><code>git pull
</code></pre>
<p>que descarga las actualizaciones. A continuación, puede seguir las instrucciones anteriores para volver a compilar <em>morpho.</em> No es necesario reinstalar las dependencias, pero tenga en cuenta que algunas nuevas versiones de <em>morpho</em> pueden requerir dependencias adicionales.</p>
</li>
<li>
<p>Si ya no tiene la carpeta original del repositorio git <em>morpho</em> desde la que instaló morpho, simplemente vuelva a ejecutar la instalación desde cero como se indicó anteriormente. No debería ser necesario volver a instalar las dependencias.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="desinstalación-de-morpho"><a class="header" href="#desinstalación-de-morpho">Desinstalación de <em>morpho</em></a></h2>
<p>Si desea desinstalar morpho, puede hacerlo simplemente desde la aplicación de terminal.</p>
<ul>
<li>
<p>Si usaste homebrew para instalar morpho, simplemente escribe</p>
<pre><code>brew uninstall morpho
</code></pre>
</li>
<li>
<p>Alternativamente, si compiló <em>morpho</em> desde el código fuente, puede eliminar todo con</p>
<pre><code>rm /usr/local/bin/morpho6
rm /usr/local/bin/morphoview
rm /usr/local/lib/libmorpho*
rm -r /usr/local/share/morpho
rm -r /usr/local/lib/morpho
</code></pre>
<p>Es posible que tengas que anteponerles el prefijo <code>sudo</code>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uso-de-morpho"><a class="header" href="#uso-de-morpho">Uso de <em>Morpho</em></a></h1>
<p><em>Morpho</em> es una aplicación de línea de comandos, como <code>python</code> o <code>lua</code>. Se puede utilizar para ejecutar scripts o programas, a los que generalmente se les da la extensión de archivo <em>.morpho</em>, o ejecutarse de forma interactiva respondiendo a los comandos del usuario.</p>
<h2 id="ejecución-de-un-programa"><a class="header" href="#ejecución-de-un-programa">Ejecución de un programa</a></h2>
<p>Para ejecutar un programa, simplemente ejecute morpho con el nombre del archivo,</p>
<pre><code>morpho6 script.morpho
</code></pre>
<p><em>Morpho</em> soporta una serie de banderas:</p>
<p><strong>-w</strong> : Ejecuta <em>morpho</em> con más de un hilo de trabajo, por ejemplo, <code>-w 4</code> ejecuta morpho con 4 hilos.</p>
<p><strong>-D</strong>: Muestra el desmontaje del programa sin ejecutarlo. <em>[Ver guía para desarrolladores]</em></p>
<p><strong>-d</strong> : Modo de depuración. Morpho se detendrá y entrará en el depurador cada vez que se encuentre una <code>@</code> en el código fuente. <em>[Ver guía para desarrolladores]</em></p>
<p><strong>-p</strong> : Perfila la ejecución del programa. Útil para identificar cuellos de botella en el rendimiento. <em>[Ver guía para desarrolladores]</em></p>
<h2 id="modo-interactivo"><a class="header" href="#modo-interactivo">Modo interactivo</a></h2>
<p>Para usar <em>morpho</em> de forma interactiva, simplemente cargue la aplicación <em>Terminal</em> (o equivalente en su sistema) y escriba</p>
<pre><code>morpho6
</code></pre>
<h4 id="interfaz-de-línea-de-comandos-para-morpho"><a class="header" href="#interfaz-de-línea-de-comandos-para-morpho">Interfaz de línea de comandos para Morpho</a></h4>
<p>![Interfaz de línea de comandos para Morpho] (./Figuras/commandline.jpg)</p>
<p>Como se muestra en la figura anterior, serás recibido con una breve bienvenida y un mensaje <code>&gt;</code> que te invitará a ingresar comandos <em>morpho</em>. Por ahora, pruebe un clásico:</p>
<pre><code class="language-javascript">print "Hola Mundo"
</code></pre>
<p>que mostrará 'Hola Mundo' como salida. Se proporciona más información sobre el lenguaje <em>morpho</em> en la sección de referencias, especialmente en el capítulo <a href="./reference/language.html">Lenguaje</a> si está familiarizado con lenguajes similares a C como C, C++, Java, Javascript, etc., las cosas deberían ser bastante familiares.</p>
<p>Para ayudar al usuario, el contenido del manual de referencia está disponible para el usuario en modo interactivo como ayuda en línea. Para obtener ayuda, simplemente escriba:</p>
<pre><code>help
</code></pre>
<p>o aún más brevemente,</p>
<pre><code>?
</code></pre>
<p>para ver la lista de temas principales. Para encontrar ayuda sobre un tema en particular, por ejemplo, ciclos <code>for</code>, simplemente escriba el nombre del tema después:</p>
<pre><code>? for
</code></pre>
<p>Una vez que hayas terminado de usar <em>morpho</em>, simplemente escriba</p>
<pre><code>quit
</code></pre>
<p>para salir del programa y volver al shell.</p>
<p>El entorno interactivo tiene algunas otras características útiles para ayudar al usuario:</p>
<ul>
<li>
<p><strong>Autocompletar.</strong> A medida que escribes, <em>morpho</em> te mostrará los comandos sugeridos que cree que estás intentando ingresar. Por ejemplo, si escribe <code>v</code>, la línea de comandos mostrará la palabra clave <code>var</code>. Para aceptar la sugerencia, presione la tecla de tabulación. Es posible que haya varias sugerencias disponibles; Utilice las teclas de flecha hacia arriba y hacia abajo para rotar a través de ellos.</p>
</li>
<li>
<p><strong>Historial de comandos.</strong> Utilice las teclas de flecha para recuperar los comandos introducidos anteriormente. A continuación, puede editarlos antes de ejecutarlos.</p>
</li>
<li>
<p><strong>Edición de líneas.</strong> Mientras escribes un comando, usa las flechas izquierda y derecha para mover el cursor; Puede insertar nuevos caracteres en el cursor simplemente escribiéndolos o eliminar caracteres con la tecla <code>delete</code>. Mantenga presionada la tecla <code>shift</code> mientras usa las teclas de flecha izquierda y derecha para seleccionar texto; luego puede usar 'Ctrl-C' para copiar y <code>Ctrl-V</code> para pegar. <code>Ctrl-A</code> se mueve al principio de la línea y <code>Ctrl-E</code> al final.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial"><a class="header" href="#tutorial">Tutorial</a></h1>
<p>Para ilustrar cómo usar <em>morpho</em>, resolveremos un problema que involucra cristales líquidos nemáticos (NLC), fluidos compuestos por moléculas largas y rígidas que poseen una orientación molecular promedio local descrita por un campo vectorial unitario \(\mathbf{n}\). Las gotas de NLC sumergidas en un fluido isótropo huésped como el agua se denominan tactoides, y, a diferencia de las gotas de, por ejemplo, aceite en el agua que forman esferas, los tactoides pueden adoptar formas alargadas.</p>
<p>La funcional a minimizar, esto es, la energía libre del sistema, es bastante compleja,</p>
<p>$$ \begin{equation} F= \underbrace{\frac{1}{2}\int_{C}K_{11}\left(\nabla\cdot\mathbf{n}\right)^{2}+K_{22}(\mathbf{n}\cdot\nabla\times\mathbf{n})^{2}+K_{33}\left|\mathbf{n}\times\nabla\times\mathbf{n}\right|^{2}dA}_\text{elasticidad de cristal líquido}\label{eq:free} \end{equation} $$</p>
<p>$$ \begin{equation*} \quad + \underbrace{ \sigma\int dl }_\text{t.s.} \end{equation*} $$</p>
<p>$$ \begin{equation*} \quad + \underbrace{\frac{W}{2}\int\left(\mathbf{n}\cdot\mathbf{t}\right)^{2}dl}_\text{anclaje} \end{equation*} $$</p>
<p>donde los tres términos incluyen <strong>elasticidad de cristal líquido</strong> que impulsa el alargamiento de la gota, <strong>tensión superficial</strong> <em>(s.t.)</em> que se opone al alargamiento del límite y un <strong>término de anclaje</strong> que impone una orientación preferida en el límite. Necesitamos una restricción local, \(\mathbf{n}\cdot\mathbf{n}=1\), y también impondrá una restricción en el volumen de la gota. Para simplificar, resolveremos este problema en 2D. El código completo de este ejemplo de tutorial se encuentra en la carpeta 'examples/tactoid' del repositorio.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="importación-de-módulos"><a class="header" href="#importación-de-módulos">Importación de módulos</a></h2>
<p><em>Morpho</em> es un sistema modular y, por lo tanto, normalmente comenzamos nuestro programa diciéndole a <em>morpho</em> los módulos que necesitamos para que estén disponibles. Para ello, utilizamos la palabra clave <code>import</code> seguida del nombre del módulo:</p>
<pre><code class="language-javascript">    import meshtools
    import optimize
    import plot
</code></pre>
<p>También podemos usar la palabra clave <code>import</code> para importar archivos de programa adicionales para ayudar a modularizar programas grandes. Estos son los módulos que usaremos para este ejemplo:</p>
<div class="table-wrapper"><table><thead><tr><th>Módulo</th><th>Finalidad</th></tr></thead><tbody>
<tr><td><code>meshtools</code></td><td>Código de utilidad para crear y refinar mallas</td></tr>
<tr><td><code>optimize</code></td><td>Realizar la optimización</td></tr>
<tr><td><code>plot</code></td><td>Visualiza los resultados</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="el-lenguaje-morpho"><a class="header" href="#el-lenguaje-morpho">El lenguaje Morpho</a></h1>
<figure id="fig:Postcard">
<div class="centering">
<embed src="../Figures/postcard.png" style="width:6in" />
</div>
<figcaption><span id="fig:Postcard"
label="fig:Postcard"></span>Postcard-sized summary of the
<em>morpho</em> language. </figcaption>
</figure>
<!-- 
<object data="../Figures/postcard.pdf" type="application/pdf" width="700px" height="700px">
    <embed src="../Figures/postcard.pdf">
        <p>This browser does not support PDFs. Please download the PDF to view it: <a href="http://yoursite.com/the.pdf">Download PDF</a>.</p>
    </embed>
</object> -->
<p>El lenguaje <em>morpho</em> es simple pero expresivo. Si estás familiarizado con los lenguajes tipo C (C, C++, Java, Javascript) te resultará muy natural. Una descripción mucho más detallada se proporciona en el Capítulo [Idioma](.. /reference/language.md), pero en la figura anterior se proporciona un breve resumen y proporcionamos una descripción general de las ideas clave para ayudarlo a seguir el tutorial:</p>
<ul>
<li>
<p><strong>Comentarios.</strong> Cualquier texto después de <code>//</code> o rodeado por <code>/``*</code> y <code>*``/</code> es un comentario y no es procesado por morpho:</p>
<pre><code>Este es un comentario
/* ¡Esto también! */
</code></pre>
</li>
<li>
<p><strong>Variables.</strong> Para crear una variable, utilice la palabra clave <code>var</code>; A continuación, puede asignar y utilizar la variable arbitrariamente:</p>
<pre><code>var a = 1
print a
</code></pre>
</li>
<li>
<p><strong>Funciones.</strong> Las funciones pueden tomar parámetros, y se les llama así:</p>
<pre><code>print sin(x)
</code></pre>
<p>y decláralos así:</p>
<pre><code>fn f(x,y) {
    return x^2+y^2
}
</code></pre>
<p>Algunas funciones toman argumentos opcionales, que se ven así:</p>
<pre><code>var a = foo(quiet=true)
</code></pre>
</li>
<li>
<p><strong>Objetos.</strong> <em>Morpho</em> está profundamente orientado a objetos. La mayoría de las cosas en morpho se representan como objetos, que proporcionan <em>métodos</em> que puedes usar para controlarlos. Los objetos están formados por <em>funciones constructoras</em> que comienzan con una letra mayúscula (y pueden tomar argumentos):</p>
<pre><code>var a = Object()
</code></pre>
<p>Las llamadas a métodos tienen el siguiente aspecto:</p>
<pre><code>a.foo()
</code></pre>
</li>
<li>
<p><strong>Colecciones.</strong> <em>Morpho</em> proporciona una serie de tipos de colecciones, todos los cuales son objetos, incluidas listas,</p>
<pre><code>var a = [1,2,3]
</code></pre>
<p>y Diccionarios:</p>
<pre><code>var b = { "Massachusetts": "Boston", "California": "Sacramento" }
</code></pre>
<p>y Rangos (a menudo utilizados en ciclos):</p>
<pre><code>var a = 0..10:2 # all even numbers 0-10 inclusive
</code></pre>
<p>Hay muchas otras, incluyendo Matrices, Matrices dispersas, etc.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="creación-de-la-malla-inicial"><a class="header" href="#creación-de-la-malla-inicial">Creación de la malla inicial</a></h2>
<figure id="fig:Mesh">
<div class="centering">
<p><img src="tutorial/../Figures/Tutorial/0ExampleMesh/meshgrade0.png" style="width:2in"
alt="image" /><img src="tutorial/../Figures/Tutorial/0ExampleMesh/meshgrade1.png"
style="width:2in" alt="image" /><img
src="../Figures/Tutorial/0ExampleMesh/meshgrade2.png" style="width:2in"
alt="image" /></p>
</div>
<figcaption><span id="fig:Mesh" label="fig:Mesh"></span>A <em>Mesh</em>
object contains different kinds of element. In this example, the mesh
contains points, lines and area elements referred to by their
<em>grade</em>.</figcaption>
</figure>
<p>Las mallas son regiones discretizadas del espacio. La región más simple que podemos imaginar es un <em>punto</em> o <em>vértice</em> descrito por un conjunto de coordenadas \((x_{1},x_{2},....,x_{D})\) donde el número de coordenadas \(D\) define la dimensionalidad del espacio en el que se dice que la variedad está <em>incrustada</em>. A partir de más de un punto, podemos empezar a construir regiones más complejas. En primer lugar, entre dos puntos podemos imaginar que fijamos una regla imaginaria y dibujamos una línea recta o <em>borde</em> entre ellos. Tres puntos definen un plano, y también un triángulo; Por lo tanto, podemos identificar el área bidimensional del plano delimitada por el triángulo como una <em>cara</em>, como en la cara de un poliedro. Usando cuatro puntos, podemos definir el volumen delimitado por un tetraedro. Cada uno de estos <strong>elementos</strong> tiene una dimensionalidad diferente llamada _grado_and una <code>Malla</code> completa puede contener elementos de muchos grados diferentes, como se muestra en la Fig. <a href="tutorial/creating_the_initial_mesh.html#fig:Malla">4.2</a>.</p>
<p><em>Morpho</em> proporciona varias formas de crear una malla. Se puede cargar una malla a partir de un archivo, construir una manualmente a partir de un conjunto de puntos, crear una a partir de un poliedro o a partir del conjunto de niveles (curvas de nivel) de una función.</p>
<p>Para este ejemplo, usaremos un archivo de malla predefinido <code>disk.mesh</code>. Para crear un objeto Mesh a partir de este archivo, llamamos a la función <em>Mesh</em> con el nombre del archivo:</p>
<pre><code class="language-javascript">var m = Mesh(“disk.mesh”)
</code></pre>
<p>Aquí, la palabra clave <strong>var</strong> le dice a morpho que cree una nueva variable <em>m</em>, que ahora se refiere al objeto <em>Mesh</em> recién creado.</p>
<figure id="fig:InitialMesh">
<div class="centering">
<img src="tutorial/../Figures/Tutorial/1Mesh/mesh.png" style="width:3.5in" />
</div>
<figcaption><span id="fig:InitialMesh"
label="fig:InitialMesh"></span>The initial mesh, loaded from
<code>disk.mesh</code>.</figcaption>
</figure>
<p>La malla inicial se muestra en la Fig. [4.3](#fig:Malla inicial); proporcionaremos el código para realizar la visualización en la sección <a href="tutorial/./visualizing_the_results.html">Visualización de los resultados</a>.</p>
<p>Si abres el archivo <code>disk.mesh</code>, que puedes encontrar en la misma carpeta que <code>tactoid.morpho</code>, verás que tiene un formato simple legible por humanos:</p>
<pre><code>vertices

1 -1. 0. 0 
2 -0.951057 -0.309017 0
...

edges
1 8 2 
2 2 4
...

faces
1 8 2 4 
2 8 4 6
...
</code></pre>
<p>El archivo se divide en secciones, cada una de las cuales describe elementos de un grado diferente. Cada línea comienza con un delimitador de sección como <em>vertices</em>, <em>edges</em> o <em>faces</em>, o con un id. Los vértices se definen entonces por un conjunto de coordenadas; Las aristas y las caras se definen proporcionando los respectivos identificadores de vértice.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="selecciones"><a class="header" href="#selecciones">Selecciones</a></h2>
<p>A veces, queremos referirnos a partes específicas de un objeto 'Mesh': elementos que coinciden con algún criterio, por ejemplo. Los objetos de 'selección' nos permiten hacer esto. Debido a que la selección del límite es una actividad muy común, la función constructora 'Selection' toma un argumento opcional para hacer esto:</p>
<pre><code>var bnd=Selection(m, boundary=true)
</code></pre>
<p>De forma predeterminada, solo los elementos de límite se incluyen en la <code>Selección</code>. Para una malla con un máximo de elementos de grado 2 (facets), los límites son elementos de grado 1 (líneas); Para una malla con elementos de grado 3 (volúmenes), los límites son elementos de grado 2 (facets). Muy a menudo también queremos los vértices en sí, por lo que podemos llamar a un método para lograrlo:</p>
<pre><code>bnd.addgrade(0)
</code></pre>
<p>Una vez que se ha creado una <code>Selección</code>, puede ser útil visualizarla para asegurarse de que se seleccionan los elementos correctos. Hablaremos más sobre la visualización en la sección <a href="tutorial/./visualizing_the_results.html">Visualización de resultados</a>, pero por ahora la línea</p>
<pre><code>Show(plotselection(m, bnd, grade=1))
</code></pre>
<p>muestra una visualización de la malla con los elementos de grado 1 seleccionados sombreados en rojo como se muestra en la Fig. <a href="tutorial/selections.html#fig:Boundary">4.4</a>.</p>
<p><img src="tutorial/../Figures/Tutorial/2Visualize/selection.png" alt="Selection" /> <em>Seleccionando la frontera del la malla</em></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="campos"><a class="header" href="#campos">Campos</a></h2>
<p>Habiendo creado nuestro dominio computacional inicial, ahora creamos un objeto <code>Field</code> (<code>Campo</code>) que representa el campo director \(\mathbf{n}\):</p>
<pre><code>var nn = Field(m, Matrix([1,0,0]))
</code></pre>
<p>Al igual que con el objeto <code>Mesh</code> anteriormente, declaramos una variable, <em>nn</em>, para hacer referencia al objeto <code>Field</code>. Tenemos que proporcionar dos argumentos a <code>Field</code>: el objeto <code>Mesh</code> en el que se define el <code>Field</code>, y algo para inicializarlo. Aquí, queremos que el director inicial tenga un valor espacialmente uniforme, por lo que podemos proporcionar a <code>Field</code> un objeto <code>Matrix</code> constante. De forma predeterminada, <em>morpho</em> almacena una copia de esta matriz en cada vértice de la malla; Sin embargo, los campos pueden almacenar información sobre elementos de cualquier grado (y almacenar más de una cantidad por grado e información sobre varios grados al mismo tiempo).</p>
<p>Es posible inicializar un <code>Field</code> con valores que varían espacialmente proporcionando una <em>función anónima</em> a <code>Field</code> como esta:</p>
<pre><code>var phi = Field(m, fn (x,y,z) x^2+y^2)
</code></pre>
<p>Aquí, <em>phi</em> es un campo escalar que toma el valor \(x^{2}+y^{2}\). La palabra clave <strong>fn</strong> se utiliza para definir funciones.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="definición-del-problema"><a class="header" href="#definición-del-problema">Definición del problema</a></h2>
<p>Pasamos ahora a plantear el problema. Cada término en el funcional energético <a href="tutorial/../tutorial.html#eq:free">(1)</a> está representado por un objeto <em>functional</em> correspondiente, que actúa sobre una <code>Mesh</code> (Malla) (y posiblemente un <code>Mesh</code> (Campo) para calcular una cantidad integral como una energía; Los objetos funcionales también son responsables de calcular gradientes de la energía con respecto a las posiciones de los vértices y los componentes de los campos.</p>
<p>Tomemos los términos de <a href="tutorial/../tutorial.html#eq:free">(1)</a> uno por uno: Para representar la elasticidad nemática creamos un objeto <code>Nematic</code> :</p>
<pre><code>var lf=Nematic(nn)
</code></pre>
<p>El término de tensión superficial implica la longitud del límite, por lo que necesitamos un o~bjeto <code>Length</code>:</p>
<pre><code>var lt=Length()
</code></pre>
<p>El término de anclaje no tiene un tipo de objeto integrado simple, pero podemos usar un objeto general LineIntegral` para lograr el resultado correcto.</p>
<pre><code>var la=LineIntegral(fn (x, n) n.inner(tangent())^2, nn)
</code></pre>
<p>Tenga en cuenta que tenemos que proporcionar una función la integrando y que será llamada por <code>LineIntegral</code> cuando evalúe la integral. Las funciones integrando se llaman primero con las coordenadas locales (como un objeto <code>Matrix</code> que representa un vector columna) y luego el valor interpolado local de cualquier número de <code>Campos</code>. También hacemos uso de la función especial <code>tangent()</code> que devuelve localmente una tangente local a la recta.</p>
<p>También tenemos que imponer limitaciones. Cualquier objeto <em>funcional</em> se puede usar igualmente bien como una energía o una restricción, y por lo tanto creamos un objeto <code>NormSq</code> (norm-squared) que se usará para implementar la restricción de vector unitario local en el campo director:</p>
<pre><code>var ln=NormSq(nn)
</code></pre>
<p>y un objeto <code>Area</code> para la restricción global. Esto es realmente una restricción que fija el volumen de fluido en la gota, pero como estamos en 2D, eso se convierte en una restricción en el área de la malla:</p>
<pre><code>var laa=Area()
</code></pre>
<p>Ahora tenemos una colección de objetos funcionales que podemos usar para definir el problema. Hasta ahora, no hemos especificado qué funcionales son energías y cuáles son restricciones; Tampoco hemos especificado sobre qué partes de la malla se evaluarán los funcionales. Toda esa información se recopila en un objeto <code>OptimizationProblem</code>, que ahora crearemos:</p>
<pre><code>// Configurar el problema de optimización
var W = 1
var sigma = 1

var problema = OptimizationProblem(m)
problema.addenergy(lf)
problem.addenergy(la, selection=bnd, prefactor=-W/2)
problem.addenergy(lt, selection=bnd, prefactor=sigma)
problem.addconstraint(laa)
problem.addlocalconstraint(ln, field=nn, target=1)
</code></pre>
<p>Tenga en cuenta que algunas de estas funciones solo actúan sobre una selección, como el límite, y por lo tanto usamos el parámetro opcional <code>selection</code> para especificarlo. También podemos especificar el prefactor del funcional.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="realizando-la-optimización"><a class="header" href="#realizando-la-optimización">Realizando la optimización</a></h2>
<p>Ahora estamos listos para realizar la optimización, para lo cual necesitamos un objeto <code>Optimizer</code>. Estos vienen en dos sabores: un <code>ShapeOptimizer</code> y un <code>FieldOptimizer</code> que actúan respectivamente sobre la forma y un campo. Los creamos con el problema y la cantidad sobre la que se supone que deben actuar:</p>
<pre><code class="language-javascript">// Crear optimizadores de formas y campos
var sopt = ShapeOptimizer(problem, m)
var fopt = FieldOptimizer(problem, nn)
</code></pre>
<p>Una vez creados estos, podemos realizar la optimización llamando al método <code>linesearch</code> con un número específico de iteraciones para cada uno:</p>
<pre><code class="language-javascript">// Bucle de optimización
for (i in 1..100) {  
    fopt.linesearch(20)
    sopt.linesearch(20)
}
</code></pre>
<p>Cada iteración de <code>linesearch</code> hace evolucionar el campo (o forma) hacia abajo en el gradiente del funcional de destino, sujeto a restricciones, y encuentra un tamaño de paso óptimo para reducir el valor del funcional. Aquí, alternamos entre optimizar el campo y optimizar la forma, realizando veinte iteraciones de cada uno, y en general hacemos esto cien veces. Estos números han sido elegidos de forma bastante arbitraria, y si nos fijamos en el resultado nos daremos cuenta de que <em>morpho</em> no siempre ejecuta veinte iteraciones de cada uno. Más bien, en cada iteración comprueba si el cambio en la energía satisface, $$|E|&lt;\epsilon,$$ o, $$\left|\frac{\Delta E}{E}\right|&lt;\epsilon$$ donde el valor de \(\epsilon\), la tolerancia de convergencia se puede cambiar estableciendo la propiedad <code>etol</code> del objeto Optimizer:</p>
<pre><code class="language-javascript">sopt.etol = 1e-7 // el valor predeterminado es 1E-8
</code></pre>
<p>Algunas otras propiedades de un <code>Optimizador</code> que pueden ser útiles para que el usuario las ajuste son las siguientes:</p>
<div class="table-wrapper"><table><thead><tr><th>Propiedad</th><th>Valor predeterminado</th><th>Finalidad</th></tr></thead><tbody>
<tr><td><code>etol</code></td><td>\(1\times10^{-8}\)</td><td>Tolerancia en la energía (error relativo)</td></tr>
<tr><td><code>ctol</code></td><td>\(1\times10^{-10}\)</td><td>Tolerancia a restricciones (qué tan bien se satisfacen las restricciones)</td></tr>
<tr><td><code>stepsize</code></td><td><code>0.1</code></td><td>Tamaño de paso para <code>relax</code> (cambiado por búsqueda de líneas)</td></tr>
<tr><td><code>steplimit</code></td><td><code>0.5</code></td><td>El tamaño de paso más grande que puede tomar una <code>linesearch</code></td></tr>
<tr><td><code>maxconstraintsteps</code></td><td>`20</td><td>Número de pasos que el optimizador puede realizar para garantizar que se satisfagan las restricciones</td></tr>
<tr><td><code>quiet</code></td><td><code>false</code></td><td>Si se imprime la salida a medida que se produce la optimización</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h2 id="sec:Visualizing-results"><a class="header" href="#sec:Visualizing-results">Visualización de resultados</a></h2>
<p><em>Morpho</em> proporciona un sistema de gráficos altamente flexible, con una aplicación de visualización externa <em>morphoview</em>, para permitir visualizaciones enriquecidas de los resultados. Las visualizaciones suelen implicar uno o más objetos <code>Gráphics</code>, que actúan como contenedor para que se muestren los elementos gráficos. Se pueden agregar varios <em>graphics primitives</em>, como esferas, cilindros, flechas, tubos, etc. a un objeto <code>Gráphics</code> para hacer un dibujo.</p>
<p>Ahora estamos listos para visualizar los resultados de la optimización. Primero, dibujaremos la malla. Debido a que estamos interesados en ver la estructura de la malla, dibujaremos los bordes (es decir, los elementos de grado 1). La función para hacer esto se proporciona como parte del módulo <code>plot</code> que importamos en la sección <a href="tutorial/./importing_modules.html">Importación de módulos</a>:</p>
<pre><code class="language-javascript">var g=plotmesh(m, grade=1)
</code></pre>
<p>A continuación, crearemos un objeto <code>Graphics</code> separado que contenga al director. Dado que el director \(\mathbf{n}\) es un campo vectorial unitario, y el signo no es significativo (la energía elástica nemática es en realidad invariante bajo \(\mathbf{n}\to-\mathbf{n}\)), una forma apropiada de mostrar un solo director es como un cilindro orientado a lo largo de \(\mathbf{n}\). Por lo tanto, crearemos una función auxiliar que cree un objeto 'Graphics' y dibuje un cilindro de este tipo en cada punto de malla:</p>
<pre><code class="language-javascript">// Función para visualizar un campo de director
// m - la malla 
// nn - el Campo del director a visualizar
// dl - Escalar el director 
fn visualize(m, nn, dl) { 
    var v = m.vertexmatrix()
    var nv = m.count() // Número de vértices
    var g = Graphics() // Creación de un objeto gráfico
    for (i in 0...nv) {
    var x = v.column(i) // Obtener el i-ésimo vértice
    // Dibuja un cilindro alineado con nn en este vértice
    g.display(Cylinder(x-nn[i]*dl, x+nn[i]*dl, aspectratio=0.3))
    }
    return g
}
</code></pre>
<p>Una vez que hemos definido esta función, podemos usarla:</p>
<pre><code class="language-javascript">var gnn=visualize(m, nn, 0.2)
</code></pre>
<p>Las variables \(g\) y \(gnn\) ahora se refieren a dos objetos Graphics separados. Podemos combinarlos usando el operador \(+\) y mostrarlos así:</p>
<pre><code class="language-javascript">var gdisp = g+gnn
Show(gdisp)
</code></pre>
<figure id="fig:FinalResult">
<div class="centering">
<img src="tutorial/../Figures/Tutorial/2Visualize/out.png" style="width:3.5in" />
</div>
<figcaption><span id="fig:FinalResult"
label="fig:FinalResult"></span>Optimized mesh and director
field.</figcaption>
</figure>
<p>La visualización resultante se muestra en la Fig. <a href="tutorial/visualizing_the_results.html#fig:FinalResult">4.5</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="refinamiento"><a class="header" href="#refinamiento">Refinamiento</a></h1>
<p>Ahora hemos resuelto nuestro primer problema de optimización de formas, y el script completo del problema se proporciona en la carpeta <code>examples/tutorial</code> dentro del repositorio de git como <code>tutorial.morpho</code>. El resultado que hemos obtenido en la Fig. <a href="tutorial/refinement.html#fig:FinalResult">4.5</a> es, sin embargo, una solución muy gruesa y de baja resolución que comprende solo un número relativamente pequeño de elementos. Para obtener una solución mejorada, necesitamos <em>refinar</em> nuestra malla. Debido a que la modificación de la malla también requiere que actualicemos otras estructuras de datos como campos y selecciones, se utiliza un objeto especial <code>MeshRefiner</code> para realizar el refinamiento.</p>
<p>Para llevar a cabo el refinamiento:</p>
<ol>
<li>
<p>Cree un objeto <code>MeshRefiner</code>, proporcionándole una lista de todos los objetos <code>Mesh</code>, <code>Field</code> y <code>Selection</code> (es decir, la malla y los objetos que dependen directamente de él) que deben actualizarse:</p>
<pre><code class="language-javascript">var mr = MeshRefiner([m, nn, bnd]); // Configurar el refinador
</code></pre>
</li>
<li>
<p>Llame al método 'refine' en el objeto <code>MeshRefiner</code> para realizar realmente el refinamiento. Este método devuelve un objeto <code>Dictionary</code> que asigna los objetos antiguos a los potencialmente recién creados.</p>
<pre><code class="language-javascript">var refmap = mr.refine(); // Realizar el refinamiento
</code></pre>
</li>
<li>
<p>Dígale a cualquier otro objeto que haga referencia a la malla, campos o selecciones que actualice sus referencias usando <code>refmap</code>. Por ejemplo, los objetos <code>OptimizationProblem</code> y <code>Optimizer</code> normalmente se actualizan en este paso.</p>
<pre><code class="language-javascript">for (el in [problem, sopt, fopt]) el.update(refmap); // Actualizar el problema
</code></pre>
</li>
<li>
<p>Actualizar nuestras propias referencias</p>
<pre><code class="language-javascript">m = refmap[m];
nn = refmap[nn];
bnd = refmap[bnd]; // Actualizar variables
</code></pre>
</li>
</ol>
<figure id="fig:Refinement">
<p><img src="tutorial/../Figures/Tutorial/3Refine/out1.png" style="width:2in"
alt="image" /><img src="tutorial/../Figures/Tutorial/3Refine/out2.png" style="width:2in"
alt="image" /><img src="tutorial/../Figures/Tutorial/3Refine/out3.png" style="width:2in"
alt="image" /></p>
<figcaption><span id="fig:Refinement"
label="fig:Refinement"></span>Optimized mesh and director field at three
successive levels of refinement.</figcaption>
</figure>
<p>Insertamos este código después de nuestra sección de optimización, lo que hace que <em>morpho</em> se optimice y refine sucesivamente.</p>
<blockquote>
<p>El código completo, incluido el refinamiento, se encuentra en la carpeta <code>examples/tutorial</code> dentro del repositorio git como <code>tutorial2.morpho</code></p>
</blockquote>
<p>Las formas optimizadas resultantes se muestran en la Fig. <a href="tutorial/refinement.html#fig:Refinamiento">4.6</a>.</p>
<pre><code>// Bucle de optimización
var refmax = 3
for (refiter in 1..refmax) {
  print "===Nivel de refinamiento ${refiter}==="
  for (i en 1..100) {
    fopt.linesearch(20)
    sopt.linesearch(20)
  }

if (refiter==refmax) rompe

Refinamiento
  var mr=MeshRefiner([m, nn, bnd]) // Configurar el refinador
  var refmap=mr.refine() // Realizar el refinamiento
  for (el in [problem, sopt, fopt]) el.update(refmap) // Actualiza el problema
  m=refmap[m]; nn=refmap[nn]; bnd=refmap[bnd] // Actualizar variables
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="siguientes-pasos"><a class="header" href="#siguientes-pasos">Siguientes pasos</a></h2>
<p>Una vez completado este tutorial, es posible que desee explorar el efecto de cambiar algunos de los parámetros del archivo. ¿Qué pasa si cambias <code>sigma</code> y W, los coeficientes delante de los términos de la energía? ¿Qué pasa si das un número diferente de pasos? ¿O cambiar las propiedades de los optimizadores como <code>stepsize</code> y <code>steplimit</code>?</p>
<p>Deberías mirar otros archivos de ejemplo proporcionados en la carpeta <code>examples</code> del repositorio de git. El resto del manual comprende capítulos que exploran ciertos conceptos de <em>morpho</em> con más detalle, seguidos de un manual de referencia detallado para la funcionalidad de <em>morpho</em> y una descripción completa del lenguaje de scripting.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chap:Working-with-Meshes"><a class="header" href="#chap:Working-with-Meshes">Trabajando con mallas</a></h1>
<p>Este capítulo explica varias formas en que el usuario puede crear y manipular objetos Mesh en <em>morpho</em>. La forma más sencilla de crear una malla para un dominio deseado es utilizar el módulo <code>meshgen</code>, que proporciona una interfaz conveniente y de muy alto nivel. El módulo <code>meshtools</code> proporciona operaciones de creación de mallas de bajo nivel y una serie de rutinas útiles para manipular mallas. El módulo <code>implicitmesh</code> produce superficies a partir de funciones implícitas. Por último, puede utilizar un programa externo para crear una malla que exporte los datos en formato vtk utilizando el módulo <code>vtk</code>.</p>
<p>La creación de mallas sigue dos patrones. Algunos métodos utilizan un patrón <strong>constructor</strong> en el que se llama a una sola función que crea la malla, p. ej.</p>
<pre><code class="language-javascript">var mesh = LineMesh(fn (t) [t,0], -1..1:0.1)
</code></pre>
<p>Otros enfoques siguen un patrón <strong>builder</strong>, en el que primero se crea un objeto auxiliar especial,</p>
<pre><code class="language-javascript">var mb = MeshBuilder()
</code></pre>
<p>y manipularlo, por ejemplo, añadiendo elementos u opciones de configuración. A continuación, se crea la malla llamando al método de compilación:</p>
<pre><code class="language-javascript">var mesh = mb.build() 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="sec:Meshgen"><a class="header" href="#sec:Meshgen">El módulo meshgen</a></h2>
<p>El módulo <code>meshgen</code> produce convenientemente mallas de alta calidad para muchos tipos de dominio. Sigue el patrón del generador con un objeto auxiliar MeshGen que realiza la construcción. Para usar <code>meshgen</code>, el usuario debe proporcionar una función escalar que sea positiva en todos los lugares en los que desea que se malla.</p>
<blockquote>
<p><strong>Nota</strong> Un ejemplo se conoce en la literatura como una function_ de distancia _con signo, que es la distancia euclidiana de un punto dado \(x\) al límite de un conjunto \(\Omega\) con el signo positivo si \(x\) está en el interior de \(\Omega\). MeshGen no requiere funciones de distancia con signo, pero acepta cualquier función continua y razonablemente suave.</p>
</blockquote>
<p>Por ejemplo, el interior del disco unitario en dos dimensiones, se describe mediante la función $$f(x,y)=1-(x^{2}+y^{2}).$$ Para crear la malla correspondiente, primero debemos especificar una función <em>morpho</em> adecuada que describa el dominio. Esta función será llamada repetidamente por MeshGen, que le pasará un vector de posición <code>x</code>. Por lo tanto, se debe acceder a los componentes \((x,y)\) desde el argumento <code>x</code> indexando:</p>
<pre><code class="language-javascript">fn disk(x) {
    return 1-(x[0]^2+x[1]^2)
}
</code></pre>
<p>Ahora que se especifica la función, podemos crear un objeto MeshGen:</p>
<pre><code class="language-javascript">var mg = MeshGen(disk, [-1..1:0.2, -1..1:0.2])
</code></pre>
<p>El segundo parámetro es una lista de rangos que proporcionan límites generales en el dominio que se va a mallar. Aquí usaremos \(x,y\in[-1,1]\). Al establecer el tamaño del paso, el usuario puede proporcionar a MeshGen una sugerencia general de la resolución.</p>
<p>Por último, creamos el Mesh llamando al método build:</p>
<pre><code class="language-javascript">var m = mg.build();
</code></pre>
<p>La malla resultante se muestra en la Fig. <a href="working_with_meshes/meshgen_module.html#fig:MeshGen-disk">5.1</a>, panel izquierdo. Se puede generar una malla de mayor resolución cambiando los objetos Range pasados a MeshGen:</p>
<pre><code>var mg = MeshGen(disk, [-1..1:0.1, -1..1:0.1])
</code></pre>
<p>Esto genera una malla de resolución mucho mayor, con aproximadamente cuatro veces el número de vértices como se muestra en la Fig. <a href="working_with_meshes/meshgen_module.html#fig:MeshGen-disk">5.1</a>, panel derecho.</p>
<figure id="fig:MeshGen-disk">
<p><img src="working_with_meshes/../Figures/MeshChapter/MeshGen/disk.png" style="width:3in"
alt="image" /><img src="working_with_meshes/../Figures/MeshChapter/MeshGen/finedisk.png"
style="width:3in" alt="image" /></p>
<figcaption><span id="fig:MeshGen-disk"
label="fig:MeshGen-disk"></span>Two disks created with different
resolutions with MeshGen.</figcaption>
</figure>
<p>MeshGen también puede mallar dominios más complicados. Para facilitar esto, proporciona una clase Domain que acepta una función escalar en su constructor. Por ejemplo, este código crea una elipse como se muestra en la Fig. <a href="working_with_meshes/meshgen_module.html#fig:MeshGen-2">5.2</a>, panel izquierdo:</p>
<pre><code>var e0 = Domain(fn (x) -((x[0]/2)^2+x[1]^2-1))
var mg = MeshGen(e0, [-2..2:0.2, -1..1:0.2])
var m = mg.build()
</code></pre>
<p>La ventaja de esto es que los objetos de dominio se pueden combinar utilizando los métodos de operación de conjunto <code>union</code>, <code>intersección</code> y <code>diferencia</code>. Para ilustrar las posibilidades con esto, usamos un constructor especial para crear tres dominios correspondientes a discos,</p>
<pre><code>var a = CircularDomain(Matrix([-0.5,0]), 1)
var b = CircularDomain(Matrix([0.5,0]), 1)
var c = CircularDomain(Matrix([0,0]), 0.3)
</code></pre>
<p>luego combínalos,</p>
<pre><code>var dom = a.union(b).difference(c)
</code></pre>
<p>y la malla el dominio resultante,</p>
<pre><code>var mg = MeshGen(dom, [-2..2:0.1, -1..1:0.1], quiet=false)
var m = mg.build()
</code></pre>
<p>con el resultado que se muestra en la Fig. <a href="working_with_meshes/meshgen_module.html#fig:MeshGen-2">5.2</a>, panel derecho.</p>
<figure id="fig:MeshGen-2">
<p><img src="working_with_meshes/../Figures/MeshChapter/MeshGen/ellipse.png" style="width:3in"
alt="image" /><img
src="../Figures/MeshChapter/MeshGen/overlappingdisks.png" style="width:3in"
alt="image" /></p>
<figcaption><span id="fig:MeshGen-2" label="fig:MeshGen-2"></span>More
complex domains can be created with MeshGen by combining
domains.</figcaption>
</figure>
<p>Las mallas tridimensionales se crean de manera muy similar. Aquí creamos una malla esférica, que se muestra en la Fig. <a href="working_with_meshes/meshgen_module.html#fig:MeshGen-3">5.3</a></p>
<pre><code>var dh = 0.2
var dom = Domain(fn (x) -(x[0]^2+x[1]^2+x[2]^2-1))
var mg = MeshGen(dom, [-1..1:dh, -1..1:dh, -1..1:dh])
var m = mg.build()
</code></pre>
<figure id="fig:MeshGen-3">
<div class="centering">
<img src="working_with_meshes/../Figures/MeshChapter/MeshSlicer/mesh.png" style="width:3.5in" />
</div>
<figcaption><span id="fig:MeshGen-3"
label="fig:MeshGen-3"></span>Spherical mesh created with
MeshGen</figcaption>
</figure>
<div style="break-before: page; page-break-before: always;"></div><h2 id="el-módulo-meshtools"><a class="header" href="#el-módulo-meshtools">El módulo meshtools</a></h2>
<p>Meshtools proporciona muchas funciones útiles para trabajar con mallas, incluidos constructores para crear ciertos tipos de mallas y también clases para refinar, desengrasar y fusionar mallas.</p>
<h4 id="linemesh"><a class="header" href="#linemesh">LineMesh</a></h4>
<p>La función <code>LineMesh</code> es una forma conveniente de crear una malla a partir de una función paramétrica de un parámetro. Debe especificar la función que se va a utilizar y un rango de puntos que se va a generar. A continuación, <code>LineMesh</code> evalúa cada punto del rango y los une con un elemento de línea.</p>
<p>Esto es útil para generar mallas como una línea recta simple (Fig. <a href="working_with_meshes/meshtools_module.html#fig:LineMesh">5.4</a>, panel izquierdo):</p>
<pre><code>var m = LineMesh(fn (t) [t,0], -1..1:0.1)
</code></pre>
<p>También puede solicitar que los extremos de la malla se unan para formar un bucle especificando <code>closed</code>. Este código genera un círculo (Fig. [5.4](#fig: LineMesh), panel central):</p>
<pre><code>var m = LineMesh(fn (t) [cos(t),sin(t)], -Pi...Pi:2*Pi/10, closed=true)
</code></pre>
<p>Puede aumentar la resolución del círculo cambiando el tamaño del paso en el Rango, por ejemplo a <code>2``*``Pi/20</code> para duplicar el número de puntos. Tenga en cuenta el uso del operador exclusivo Range aquí, <code>…</code>, en lugar de <code>..</code> para evitar la duplicación del punto en (1,0).</p>
<p>La malla de salida puede ser de cualquier dimensión, como esta hélice en 3D (Fig. <a href="working_with_meshes/meshtools_module.html#fig:LineMesh">5.4</a>, panel derecho). Tenga en cuenta que aquí usamos una función regular en lugar de una función anónima:</p>
<pre><code>fn helix(t) { 
  return [cos(2*Pi*t),t/2,sin(2*Pi*t)] 
}
var m = LineMesh(helix, -2..2:1/20)
</code></pre>
<figure id="fig:LineMesh">
<p><img src="working_with_meshes/../Figures/MeshChapter/LineMesh/line.png" style="width:2in"
alt="image" /><img src="working_with_meshes/../Figures/MeshChapter/LineMesh/circle.png"
style="width:2in" alt="image" /><img
src="../Figures/MeshChapter/LineMesh/helix.png" style="width:2in"
alt="image" /></p>
<figcaption><span id="fig:LineMesh" label="fig:LineMesh"></span>Using
LineMesh to create meshes from parametric functions: A straight line, a
circle and a helix.</figcaption>
</figure>
<h4 id="areamesh"><a class="header" href="#areamesh">AreaMesh</a></h4>
<p><code>AreaMesh</code> es similar a la función <code>LineMesh</code> que crea una malla a partir de una función paramétrica, que ahora toma dos parámetros. Para crear un cuadrado,</p>
<pre><code>var m = AreaMesh(fn (u,v) [u,v,0], -1..1:0.2, -1..1:0.2)
</code></pre>
<p>donde observe que se requiere un rango separado para \(u\) y \(v\). De forma predeterminada, la salida de AreaMesh solo contiene elementos de grado 0 y grado 2, es decir, vértices y facetas, como se puede ver en la Fig. <a href="working_with_meshes/meshtools_module.html#fig:%C3%81reaMesh-1">5.5</a> (izquierda). Para agregar elementos de grado 1 si es necesario, llame al método <code>addgrade</code> en la malla:</p>
<pre><code>m.addgrade(1)
</code></pre>
<p>Esto da el resultado que se muestra en la Fig. <a href="working_with_meshes/meshtools_module.html#fig:%C3%81reaMesh-1">5.5</a> (derecha).</p>
<figure id="fig:AreaMesh-1">
<p><img src="working_with_meshes/../Figures/MeshChapter/AreaMesh/square.png" style="width:3in"
alt="image" /><img src="working_with_meshes/../Figures/MeshChapter/AreaMesh/square2.png"
style="width:3in" alt="image" /></p>
<figcaption><span id="fig:AreaMesh-1"
label="fig:AreaMesh-1"></span>Using AreaMesh to create a flat square
mesh. Left: By default, only grade 0 and 2 elements are generated.
Right: The grade 1 elements can be added in with
<code>addgrade</code>.</figcaption>
</figure>
<p>Al igual que con LineMesh, las mallas se pueden cerrar en una o ambas direcciones, lo que permite la creación de un cilindro,</p>
<pre><code>m = AreaMesh(fn (u, v) [v, cos(u), sin(u)], 
               -Pi...Pi:Pi/16,
               -2..2:0.1, closed=[true, false])
</code></pre>
<p>y un toroide,</p>
<pre><code>var c=1, a=0.5 m = AreaMesh(fn (u, v) [(c + a*cos(v))*cos(u), 
                                       (c + a*cos(v))*sin(u),  
                                        a*sin(v)],
                            0...2*Pi:Pi/16,
                            0...2*Pi:Pi/8, closed=true)
</code></pre>
<p>Los resultados de estos se muestran en la Fig. <a href="working_with_meshes/meshtools_module.html#fig:%C3%81reaMesh-2">5.6</a>. Tenga en cuenta que las mallas generadas por más módulos que incorporan algún grado de control de calidad, por ejemplo, <code>implicitmesh</code> o <code>meshgen</code>, son generalmente mejores y deben usarse con preferencia a las creadas por AreaMesh.</p>
<figure id="fig:AreaMesh-2">
<p><img src="working_with_meshes/../Figures/MeshChapter/AreaMesh/tube.png" style="width:3in"
alt="image" /><img src="working_with_meshes/../Figures/MeshChapter/AreaMesh/torus.png"
style="width:3in" alt="image" /></p>
<figcaption><span id="fig:AreaMesh-2" label="fig:AreaMesh-2"></span>A
cylinder and torus created with AreaMesh.</figcaption>
</figure>
<h4 id="polyhedronmesh"><a class="header" href="#polyhedronmesh">PolyhedronMesh</a></h4>
<figure id="fig:PolyhedronMesh">
<p><img src="working_with_meshes/../Figures/MeshChapter/PolyhedronMesh/cubevertices.png"
style="width:2in" alt="image" /><img
src="../Figures/MeshChapter/PolyhedronMesh/cubeface.png" style="width:2in"
alt="image" /><img src="working_with_meshes/../Figures/MeshChapter/PolyhedronMesh/cube.png"
style="width:2in" alt="image" /></p>
<figcaption><span id="fig:PolyhedronMesh"
label="fig:PolyhedronMesh"></span>Creating a cube with PolyhedronMesh.
(Left) First the vertices are specified. (Center) Faces are specified as
an ordered sequence of points. (Right) PolyhedronMesh adds additional
vertices to create</figcaption>
</figure>
<p>PolyhedronMesh ayuda a crear mallas correspondientes a poliedros. Para hacer un cubo, por ejemplo, especificamos los ocho vértices (ver Fig. <a href="working_with_meshes/meshtools_module.html#fig:PolyhedronMesh">5.7</a>, izquierda),</p>
<pre><code>var vertices = [[-0.5, -0.5, -0.5],
                [ 0.5, -0.5, -0.5],
                [-0.5,  0.5, -0.5],
                [ 0.5,  0.5, -0.5], 
                [-0.5, -0.5,  0.5],
                [ 0.5, -0.5,  0.5],
                [-0.5,  0.5,  0.5],
                [ 0.5,  0.5,  0.5]]
</code></pre>
<p>y las seis caras,</p>
<pre><code>var faces = [ [0,1,3,2], [4,5,7,6],
              [0,1,5,4], [3,2,6,7],
              [0,2,6,4], [1,3,7,5] ]
</code></pre>
<p>Tenga en cuenta que los identificadores de vértices deben proporcionarse <em>en orden</em> de dar la vuelta a cada cara (ver Fig. <a href="working_with_meshes/meshtools_module.html#fig:PolyhedronMesh">5.7</a>, centro). Una vez especificadas las caras, podemos crear la malla,</p>
<pre><code>var m = PolyhedronMesh(vertices, faces)
m.addgrade(1)
</code></pre>
<p>Tenga en cuenta que PolyhedronMesh crea automáticamente vértices adicionales y genera triángulos para completar la malla (ver Fig. <a href="working_with_meshes/meshtools_module.html#fig:PolyhedronMesh">5.7</a>, derecha). A continuación, añadimos elementos de línea (grado 1), ya que no son creados automáticamente por PolyhedronMesh.</p>
<h4 id="delaunaymesh"><a class="header" href="#delaunaymesh">DelaunayMesh</a></h4>
<figure id="fig:DelaunayMesh">
<p><img src="working_with_meshes/../Figures/MeshChapter/DelaunayMesh/points.png"
style="width:3in" alt="image" /><img
src="../Figures/MeshChapter/DelaunayMesh/mesh.png" style="width:3in"
alt="image" /></p>
<figcaption><span id="fig:DelaunayMesh"
label="fig:DelaunayMesh"></span>Delaunay triangulation of (left) a
random oint cloud gives (right) a tetrahedralization.</figcaption>
</figure>
<p>La función constructora DelaunayMesh realiza una "triangulación" delaunay de un conjunto de puntos. Por ejemplo, la creación de una nube aleatoria de puntos (Fig. <a href="working_with_meshes/meshtools_module.html#fig:DelaunayMesh">5.8</a>, panel izquierdo):</p>
<pre><code>var pts = []
for (i in 0...100) pts.append(Matrix([2*random()-1, 2*random()-1, 2*random()-1])) 
</code></pre>
<p>entonces podemos llamar a DelaunayMesh para construir una tetraedralización. DelaunayMesh solo genera elementos de la más alta calidad (en 2D, elementos de área, en elementos de volumen 3D), por lo que si se necesitan bordes, estos se pueden agregar con 'addgrade'.</p>
<pre><code>var m=DelaunayMesh(pts)
m.addgrade(1)
</code></pre>
<p>La tetraedralización resultante se muestra en la Fig. <a href="working_with_meshes/meshtools_module.html#fig:DelaunayMesh">5.8</a>, panel derecho.</p>
<h4 id="subsec:ChangeMeshDimension"><a class="header" href="#subsec:ChangeMeshDimension">ChangeMeshDimension</a></h4>
<p>De vez en cuando, uno desea tomar una malla incrustada en un espacio, digamos dos dimensiones, e incrustarla en un espacio de diferente dimensionalidad. Por ejemplo, es posible que desee utilizar una malla 2D generada con MeshGen en el espacio 3D. La función <code>ChangeMeshDimension</code> proporciona una forma cómoda de hacerlo:</p>
<pre><code>var new = ChangeMeshDimension(mesh, dim)
</code></pre>
<p>donde <code>dim</code> es la dimensión de destino de la nueva malla.</p>
<h4 id="meshbuilder"><a class="header" href="#meshbuilder">MeshBuilder</a></h4>
<p>La clase MeshBuilder facilita la construcción manual de un objeto Mesh. Está destinado principalmente a ser utilizado por otros algoritmos de construcción de mallas, pero ocasionalmente es útil. Para empezar, cree un objeto MeshBuilder:</p>
<pre><code>var mb = MeshBuilder()
</code></pre>
<p>A continuación, puede agregar vértices y otros elementos uno por uno llamando a los métodos adecuados. Construyamos un tetraedro añadiendo primero los vértices:</p>
<pre><code>mb.addvertex([0, 0, 0.612372])
mb.addvertex([-0.288675, -0.5, -0.204124])
mb.addvertex([-0.288675, 0.5, -0.204124])
mb.addvertex([0.57735, 0, -0.204124])
</code></pre>
<p>A continuación, tenemos que añadir aristas que conecten estos vértices, y también caras. Podríamos hacer esto uno por uno, dando una lista de identificadores de vértices para cada elemento a su vez,</p>
<pre><code>mb.addedge([0,1])
mb.addedge([0,2]) 
// ... etc. 
</code></pre>
<p>pero hay una forma más inteligente para este caso. Observe que los identificadores de vértices correspondientes a las aristas del tetraedro corresponden a los conjuntos de tamaño 2 generados a partir de la lista <code>[``0,1,2,3``]</code> como se puede ver ejecutando este código:</p>
<pre><code>var vids = [0,1,2,3]
for (s in vids.sets(2)) print s 
</code></pre>
<p>Por lo tanto, podemos generar las aristas automáticamente,</p>
<pre><code>var vids = [0,1,2,3]
for (s in vids.sets(2)) mb.addedge(s)
</code></pre>
<p>y las caras también, que son los conjuntos de tamaño 3,</p>
<pre><code>for (s in vids.sets(3)) mb.addface(s)
</code></pre>
<p>Podemos terminar añadiendo un único elemento de grado 3 correspondiente al volumen:</p>
<pre><code>mb.addvolume(vids)
</code></pre>
<p>Una vez que se hayan agregado todos estos, llame al método <code>build</code> para crear un objeto Mesh:</p>
<pre><code>var m = mb.build()
</code></pre>
<p>y la malla resultante se muestra en la Fig. <a href="working_with_meshes/meshtools_module.html#fig:MeshBuilder">5.9</a>.</p>
<figure id="fig:MeshBuilder">
<div class="centering">
<img src="working_with_meshes/../Figures/MeshChapter/MeshBuilder/tetrahedron.png" style="width:3.5in" />
</div>
<figcaption><span id="fig:MeshBuilder"
label="fig:MeshBuilder"></span>Tetrahedron created with
MeshBuilder.</figcaption>
</figure><div style="break-before: page; page-break-before: always;"></div><h2 id="el-módulo-vtk"><a class="header" href="#el-módulo-vtk">El módulo vtk</a></h2>
<p>El módulo vtk proporciona facilidades de importación y exportación para el popular formato de archivo VTK, que es utilizado por muchos otros programas como <code>paraview</code>. A diferencia de los archivos morpho <em>.mesh</em>, los archivos VTK pueden incluir datos de malla y de campo. Para cargar una malla desde un archivo VTK, use un objeto VTKImporter:</p>
<pre><code>Import vtk 
var mv = VTKImporter("archivo.vtk")
var m = mv.mesh()
</code></pre>
<p>Los campos se pueden cargar de manera similar. Cada campo del archivo VTK tiene un identificador, que se pasa al método <code>field</code> como una cadena.</p>
<pre><code>var f = mv.field("F")
var g = mv.field("G")
</code></pre>
<p>La exportación requiere una clase VTKExporter,</p>
<pre><code>import meshtools 
import vtk 
var m1 = LineMesh(fn (t) [t,0,0], -1..1:2)
var g1 = Field(m1, fn(x,y,z) Matrix([x,2*x,3*x]))

var vtkE = VTKExporter(g1, fieldname=“g”)
vtkE.export(“data.vtk”)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="uniendo-mallas"><a class="header" href="#uniendo-mallas">Uniendo mallas</a></h2>
<p>Una estrategia potencial para crear mallas para dominios complicados es comenzar creando varias mallas más simples y luego fusionarlas en una malla más grande. La clase MeshMerge en el paquete <code>meshtools</code> nos permite hacer esto. Para usarlo, creamos un objeto MeshMerge con una lista de mallas que deseamos fusionar</p>
<pre><code>var mrg = MeshMerge([m1, m2, m3, ... ])
</code></pre>
<p>y, a continuación, llame al método merge para realizar la combinación y devolver la malla resultante:</p>
<pre><code>var newmesh = mrg.merge()
</code></pre>
<p>Como ejemplo de esto, construiremos una malla que podría ser una suposición inicial para una membrana sostenida entre dos límites fijos cuadrados. Para ello, crearemos un octante y luego lo reflejaremos a lo largo de diferentes ejes. La unidad básica está construida con PolyhedronMesh, como se muestra en la Fig. <a href="working_with_meshes/merging_meshes.html#fig:MeshMerge">5.11</a>:</p>
<pre><code>var a = 0.5 // Vertical separation
var r = 0.5 // Size of hole
var L = 1  // Size of box 

// One octant of the mesh 
var vertices = [ [r,0,a], [L,0,a], [L,r,a], [L,L,a],
                 [r,L,a], [0,L,a], [0,r,a], [r,r,a],
                 [r,0,0], [r,r,0], [0,r,0] ]
var faces = [ [0,1,2,7], [2,3,4,7], [7,4,5,6], [0,8,9,7], [6,7,9,10] ]

var m1 = PolyhedronMesh(vertices, faces)
m1.addgrade(1)
</code></pre>
<p>Ahora necesitamos crear código que refleje una malla sobre uno o más ejes. Hay más de una forma de hacerlo, pero aquí crearemos una clase MeshReflector que siga el patrón del constructor:</p>
<pre><code>class MeshReflector {
  init(mesh) {
    self.mesh = mesh
    self.dim = mesh.vertexmatrix().dimensions()[0] // Get Mesh dimension
  }

  // Construct a matrix that reflects about one or more axes    
  _reflectionmatrix(axis) { 
    var rmat = Matrix(self.dim,self.dim)
    for (i in 0...self.dim) rmat[i,i]=1
    if (isint(axis)) rmat[axis,axis]*=-1
    else if (isobject(axis)) for (i in axis) rmat[i,i]*=-1
    return rmat
  }

  reflect(axis) { // Reflect the mesh about the given axis or axes
    var rmat = self._reflectionmatrix(axis)
    // Clone and transform the mesh
    var m = self.mesh.clone()
    for (vid in 0…m.count()) {
      m.setvertexposition(vid, rmat * m.vertexposition(vid))
    }
    return m
  }
} 
</code></pre>
<p>Una vez definida esta clase, creamos un MeshReflector y lo usamos para construir siete copias reflejadas:</p>
<pre><code>var mr = MeshReflector(m1)

// Merge reflected meshed together
var merge = MeshMerge([ m1,
                        mr.reflect(0),
                        mr.reflect(1),
                        mr.reflect(2),
                        mr.reflect([0,1]),
                        mr.reflect([1,2]),
                        mr.reflect([2,0]),
                        mr.reflect([0,1,2])
                      ])
var m = merge.merge()
</code></pre>
<p>La malla resultante se muestra en la Fig. <a href="working_with_meshes/merging_meshes.html#fig:MeshMerge">5.11</a>, panel derecho. Tenga en cuenta que MeshMerge elimina automáticamente los elementos duplicados a medida que se realiza la combinación, de modo que</p>
<pre><code>print m1.count(1)
</code></pre>
<p>informa que había 35 elementos de línea en la malla original, mientras que</p>
<pre><code>print m.count(1)
</code></pre>
<p>produce \(256=8\times(35-6/2)\) elementos de línea, porque hay 6 aristas compartidas para cada copia.</p>
<figure id="fig:MeshMerge">
<p><img src="working_with_meshes/../Figures/MeshChapter/MeshMerge/unit.png" style="width:3in"
alt="image" /><img src="working_with_meshes/../Figures/MeshChapter/MeshMerge/final.png"
style="width:3in" alt="image" /></p>
<figcaption><span id="fig:MeshMerge" label="fig:MeshMerge"></span>By
reflecting a small mesh segment (left) about various axes, we can
assemble a larger mesh (right).</figcaption>
</figure>
<div style="break-before: page; page-break-before: always;"></div><h2 id="seleccionando-mallas"><a class="header" href="#seleccionando-mallas">Seleccionando mallas</a></h2>
<p>El módulo <code>meshslice</code> está diseñado para ayudar a visualizar un "corte" a través de la malla y los campos asociados, lo que a menudo es útil cuando se trabaja con mallas tridimensionales o superiores. Para ilustrar su uso, reutilizaremos la malla esférica creada con MeshGen en la <a href="working_with_meshes/meshgen_module.html">Meshgen Section</a> anterior (ver Fig. <a href="working_with_meshes/meshgen_module.html#fig:MeshGen-3">5.3</a>). Asegúrese de que la malla tenga elementos de grado 2 presentes con <code>addgrade</code> si es necesario. También crearemos un campo escalar simple:</p>
<pre><code>var u = Field(m, fn (x,y,z) x*y)
</code></pre>
<p>Para tomar un slice, primero crea un objeto MeshSlicer con la malla que queremos cortar:</p>
<pre><code>var ms=MeshSlicer(m)
</code></pre>
<p>A continuación, llame al método <code>slice</code>, que requiere que especifiquemos un plano de corte. Los planos se definen mediante un punto \((x,y,z)\) y un vector normal \((n_{x},n_{y},n_{z})\), que se pasan como argumentos:</p>
<pre><code>var slc=ms.slice([0,0,0],[0,0,1]) // position, normal
</code></pre>
<p>Después de tomar un slice, también podemos cortar cualquier número de objetos Field:</p>
<pre><code>var uslc=ms.slicefield(u)
</code></pre>
<p>Un solo MeshSlicer puede tomar cualquier número de sectores de la misma malla; <code>slicefield</code> siempre utiliza el segmento más reciente tomado. Los resultados del ejemplo se muestran en la Fig. <a href="working_with_meshes/slicing_meshes.html#fig:MeshSlicer">5.12</a>. Como se puede ver, los resultados de cortar una malla suelen producir mallas que son irregulares, con triángulos estrechos y elementos de tamaño desigual. Por lo tanto, estas mallas están pensadas principalmente para fines de visualización en lugar de su uso en cálculos.</p>
<figure id="fig:MeshSlicer">
<p><img src="working_with_meshes/../Figures/MeshChapter/MeshSlicer/slicemesh.png"
style="width:3in" alt="image" /><img
src="../Figures/MeshChapter/MeshSlicer/field.png" style="width:3in"
alt="image" /></p>
<figcaption><span id="fig:MeshSlicer"
label="fig:MeshSlicer"></span>Sliced plane of the spherical Mesh shown
in Fig. <a href="working_with_meshes/slicing_meshes.html#fig:MeshGen-3" data-reference-type="ref"
data-reference="fig:MeshGen-3">5.3</a>, together with a sliced scalar
field plotted with plotfield.</figcaption>
</figure>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chap:Visualization"><a class="header" href="#chap:Visualization">Visualización</a></h1>
<p>En este capítulo se describen las formas de utilizar <em>morpho</em> para visualizar la salida. Las funciones fáciles de usar para visualizar objetos geométricos se encuentran en el módulo <code>plot</code>, mientras que puede dibujar objetos arbitrarios usando el módulo <code>gráficos</code>. La calidad de la publicación se puede generar cómodamente utilizando el módulo <code>povray</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="el-módulo-de-visualización"><a class="header" href="#el-módulo-de-visualización">El módulo de visualización</a></h2>
<figure id="fig:PlotMesh">
<div class="centering">
<p><span class="sans-serif">A</span><img
src="../Figures/VisChapter/plotmesh/square.png" style="width:2in"
alt="image" /><span class="sans-serif">B</span><img
src="../Figures/VisChapter/plotmesh/square2.png" style="width:2in"
alt="image" /><span class="sans-serif">C</span><img
src="../Figures/VisChapter/plotmesh/square3.png" style="width:2in"
alt="image" /></p>
</div>
<figcaption><strong><span id="fig:PlotMesh"
label="fig:PlotMesh"></span>Using plotmesh.</strong> <strong>A</strong>
By default, the highest grade element is displayed. <strong>B</strong>
Other grades, here points and edges, can be shown by setting the
<code>grade</code> option. <strong>C</strong> The color of the mesh can
be chosen with the color option.</figcaption>
</figure>
<p>El módulo <code>plot</code> ofrece una forma conveniente de visualizar mallas, campos y selecciones. Para ilustrar su uso, crearemos una malla simple,</p>
<pre><code>import meshtools
var m = AreaMesh(fn (u,v) [u, v, 0], -1..1:0.2, -1..1:0.2)
m.addgrade(1)
</code></pre>
<p>y un campo escalar asociado,</p>
<pre><code>var f = Field(m, fn (x,y) x*y)
</code></pre>
<h4 id="meshes-mallas"><a class="header" href="#meshes-mallas">Meshes (Mallas)</a></h4>
<p>Para visualizar la malla, use la función <code>plotmesh</code></p>
<pre><code>var g = plotmesh(m)
</code></pre>
<p>que genera un objeto Graphics, que describiremos con más detalle en la <a href="visualization/graphics_module.html">Sección de gráficos</a> a continuación. De forma predeterminada, <code>plotmesh</code> muestra solo el elemento de grado más alto presente aquí grado 2 o facetas como se muestra en la <a href="visualization/plot_module.html#fig:PlotMesh">6.1</a>A. Para mostrar otras calificaciones, use la opción <code>grade</code>:</p>
<pre><code>var g = plotmesh(m, grade=[0,1])
</code></pre>
<p>que muestra puntos y aristas como se muestra en la Fig. [6.1] (#fig:PlotMesh)B.</p>
<p>Puede controlar el color de la malla con la opción <code>color</code> como se muestra en la Fig. [6.1] (#fig:TramaMesh) C:</p>
<pre><code>var g = plotmesh(m, grade=0, color=Red)
</code></pre>
<p>Para mostrar elementos seleccionados particulares de una malla, puede usar el argumento opcional <code>selection</code> y proporcionar un objeto Selection.</p>
<pre><code>var sel = Selection(m, fn (x,y,z) x^2+y^2&lt;1)
sel.addgrade(2)
var g = plotmesh(m, grade=[0,2], selection=sel)
</code></pre>
<h4 id="etiquetas-de-malla"><a class="header" href="#etiquetas-de-malla">Etiquetas de malla</a></h4>
<figure id="fig:PlotMeshLabels">
<div class="centering">
<p><span class="sans-serif">A</span><img
src="../Figures/VisChapter/plotmeshlabels/meshlabels.png" style="width:2in"
alt="image" /><span class="sans-serif">B</span><img
src="../Figures/VisChapter/plotmeshlabels/meshlabels2.png"
style="width:2in" alt="image" /></p>
</div>
<figcaption><strong><span id="fig:PlotMeshLabels"
label="fig:PlotMeshLabels"></span>Using plotmeshlabels to display
element ids.</strong> <strong>A</strong> Element ids for vertices.
<strong>B</strong> Element ids for the grade 1 elements.</figcaption>
</figure>
<p>A veces es útil poder identificar el identificador de un elemento determinado en una malla, especialmente con fines de depuración. La función <code>plotmeshlabels</code> está diseñada para facilitar esto, como se muestra en la Fig. <a href="visualization/plot_module.html#fig:PlotMeshLabels">6.2</a>. Puede seleccionar el grado para el que desea dibujar los identificadores y especificar su color, tamaño y dirección de dibujo. También es posible dar un desplazamiento, que puede ser una lista, una matriz o incluso una función, que ajuste la ubicación de las etiquetas en relación con el centro del elemento. Aquí los desplazamos un poco más arriba y a la derecha:</p>
<pre><code>var glabel = plotmeshlabels(m, grade=0, color=Black, offset=[0.025,0.025,0])
</code></pre>
<p>La función <code>plotmeshlabels</code> solo dibuja etiquetas, no la malla en sí, por lo que normalmente la combinamos con <code>plotmesh</code> y mostramos ambas:</p>
<pre><code>var gmesh = plotmesh(m, grade=[0,1])
var g = gmesh+glabel
</code></pre>
<p>Para mostrar los identificadores de los elementos de grado 1, por ejemplo, podríamos usar:</p>
<pre><code>var glabel = plotmeshlabels(m, grade=1, color=Red, offset=[-0.05,-0.05,-0.03])
</code></pre>
<h4 id="selecciones-1"><a class="header" href="#selecciones-1">Selecciones</a></h4>
<figure id="fig:PlotSelection">
<div class="centering">
<p><span class="sans-serif">A</span><img
src="../Figures/VisChapter/plotselection/selection.png" style="width:2in"
alt="image" /><span class="sans-serif">B</span><img
src="../Figures/VisChapter/plotselection/selectionbnd.png"
style="width:2in" alt="image" /></p>
</div>
<figcaption><strong><span id="fig:PlotSelection"
label="fig:PlotSelection"></span>Using plotselection.</strong>
<strong>A</strong> Selected elements. <strong>B</strong> Selected
boundary.</figcaption>
</figure>
<p>Al configurar un problema en <em>morpho</em>, es muy común usar objetos de selección para aplicar funcionales a partes limitadas de una malla. Es esencial comprobar que las selecciones son correctas, y la 'selección de parcelas' proporciona una manera fácil de hacerlo. Para ilustrar esto, seleccionemos los elementos de la parte inferior derecha de la malla,</p>
<pre><code>var s = Selection(m, fn (x,y,z) x&lt;=0 &amp;&amp; y&lt;=0)
s.addgrade(1)
</code></pre>
<p>y visualice la selección como se muestra en la Fig. <a href="visualization/plot_module.html#fig:PlotSelection">6.3</a> Un:</p>
<pre><code>var g = plotselection(m, s, grade=[0,1])
</code></pre>
<p>Del mismo modo, podemos seleccionar la frontera,</p>
<pre><code>var bnd = Selection(m, boundary=true)
</code></pre>
<p>y visualice la selección como se muestra en la <a href="visualization/plot_module.html#fig:PlotSelection">6.3</a>B:</p>
<pre><code>var gbnd = plotselection(m, bnd, grade=[0,1])
</code></pre>
<h4 id="campos-1"><a class="header" href="#campos-1">Campos</a></h4>
<p>Otro uso importante del módulo <code>plot</code> es visualizar objetos escalares de campo. Para ilustrar esto, crearemos un AreaMesh que tenga más puntos,</p>
<pre><code>var m = AreaMesh(fn (u,v) [u, v, 0], -1..1:0.1, -1..1:0.1)
</code></pre>
<p>y un objeto Field correspondiente:</p>
<pre><code>var f = Field(m, fn (x,y,z) sin(Pi*x)*sin(Pi*y))
</code></pre>
<blockquote>
<p>En realidad, es el tercer modo propio de energía más baja de un tambor cuadrado, o equivalentemente el estado \((1,1)\) de un pozo cuadrado infinito 2D en mecánica cuántica.</p>
</blockquote>
<p>De forma predeterminada, <code>plotfield</code> dibuja los puntos en los que se define el campo y los colorea por el valor como se muestra en la Fig. <a href="visualization/plot_module.html#fig:PlotField">6.4</a>A:</p>
<pre><code>var g = plotfield(f)
</code></pre>
<p>Alternativamente, <code>plotfield</code> puede dibujar elementos de orden superior e interpolar el color si selecciona la opción de estilo apropiadamente como se muestra en la Fig. <a href="visualization/plot_module.html#fig:PlotField">6.4</a>B:</p>
<pre><code>var g = plotfield(f, style=“interpolate”)
</code></pre>
<p>Para facilitar la interpretación de estos gráficos, es habitual mostrar un objeto ScaleBar junto al gráfico. Estos tienen bastantes opciones, incluida la posición y el tamaño, así como el número de ticks y el diseño del texto.</p>
<pre><code>var sb = ScaleBar(posn=[1.2,0,0], length=1, textcolor=Black)
</code></pre>
<p>La barra de escala es el argumento opcional de <code>plotfield</code>. Aquí, también usamos un objeto de mapa de colores diferente:</p>
<pre><code>var g = plotfield(f, style=“interpolate”, scalebar=sb, colormap=PlasmaMap())
</code></pre>
<p>El módulo <code>color</code> proporciona una serie de mapas de colores que puede probar: ViridisMap se usa de forma predeterminada, pero también se recomiendan PlasmaMap, MagmaMap e InfernoMap y han sido especialmente formulados para ser accesibles a usuarios con percepción limitada del color.</p>
<blockquote>
<p>Las versiones <em>morpho</em> son adaptaciones de <em>Simon Garnier, Noam Ross, Robert Rudis, Antônio P. Camargo, Marco Sciaini, and Cédric Scherer (2021). viridis(Lite) - Colorblind-Friendly Color Maps for R. viridis package version 0.6.2.</em></p>
</blockquote>
<p>GrayMap y HueMap también están disponibles.</p>
<figure id="fig:PlotField">
<div class="centering">
<p><span class="sans-serif">A</span><img
src="../Figures/VisChapter/plotfield/fieldpts.png" style="width:2in"
alt="image" /><span class="sans-serif">B</span><img
src="../Figures/VisChapter/plotfield/interpolate.png" style="width:2in"
alt="image" /><span class="sans-serif">C</span><img
src="../Figures/VisChapter/plotfield/scalebar.png" style="width:2in"
alt="image" /></p>
</div>
<figcaption><strong><span id="fig:PlotField"
label="fig:PlotField"></span>Visualizing Fields with plotfield.</strong>
<strong>A</strong> By default, the field is displayed by coloring the
respective points. <strong>B</strong> Interpolated view.
<strong>C</strong> The same field with a scalebar added and a different
choice of colormap (here PlasmaMap) used.</figcaption>
</figure>
<div style="break-before: page; page-break-before: always;"></div><h2 id="sec:The-graphics-module"><a class="header" href="#sec:The-graphics-module">El módulo de gráficos</a></h2>
<p>El soporte para gráficos de bajo nivel es proporcionado por el módulo <code>graphics</code>, que puede usar para crear visualizaciones personalizadas y generar otros tipos de salida gráfica. Estos se pueden combinar fácilmente con la salida del módulo <code>plot</code>, que utiliza 'gráficos' internamente.</p>
<p>Comenzamos creando un objeto Graphics, que representa una <em>escena</em> o una colección de cosas que se mostrarán.</p>
<pre><code>var g = Graphics()
</code></pre>
<p>Una vez creado el objeto Graphics, podemos añadir <em>display elements</em>, objetos que especifican lo que se va a dibujar, a la escena a su vez.</p>
<blockquote>
<p>A veces se denominan gráficos ’primitivos’.</p>
</blockquote>
<p>El módulo de gráficos admite los siguientes tipos de elementos:</p>
<ul>
<li>
<p><strong>Cilindro</strong> especificado por dos puntos en cada extremo del cilindro sobre su eje. También puede especificar la relación de aspecto, es decir, la relación entre el radio del cilindro y su longitud, y el número de puntos a dibujar.</p>
<pre><code>Cylinder([-1/2,-1/2,-1/2], [1/2,1/2,1/2], aspectratio=0.2, n=10)
</code></pre>
</li>
<li>
<p><strong>Arrow</strong> especificada de la misma manera que un Cilindro, p.ej.</p>
<pre><code>Arrow([-1/2,-1/2,-1/2], [1/2,1/2,1/2], aspectratio=0.2, n=10)
</code></pre>
</li>
<li>
<p><strong>Sphere</strong> especificada por el centro y el radio, p. ej.</p>
<pre><code>Sphere([0,0,0], 0.8)
</code></pre>
</li>
<li>
<p><strong>Text</strong> especificado por el texto que se va a mostrar y la ubicación en la que se va a mostrar. Se pueden proporcionar muchas opciones, incluida la dirección de dibujo y la dirección vertical, el tamaño en puntos (1 unidad gráfica = 72 puntos) y la fuente.</p>
<pre><code>Text(“Hello World!”, [-0.75,0,0], size=24, color=Black)
</code></pre>
</li>
<li>
<p><strong>Tube</strong> especificado por una secuencia de puntos y un radio. También puede especificar si el tubo está cerrado o no.</p>
<pre><code>var pts = []
for (phi in -Pi..Pi:Pi/32) {
    pts.append([0.5*(1+0.3*sin(4*phi))*cos(phi), 0.5*(1+0.3*sin(4*phi))*sin(phi), 0])
}
g.display(Tube(pts, 0.05, color=Blue, closed=true))
</code></pre>
</li>
<li>
<p><strong>TriangleComplex</strong> describe una colección de triángulos, que se pueden usar para mostrar poliedros y otros objetos complejos. Estos elementos son de bajo nivel, y hay más información disponible en la sección de referencia.</p>
</li>
</ul>
<p>La mayoría de estos elementos aceptan ciertos argumentos opcionales:</p>
<ul>
<li>
<p><strong>color</strong> para especificar el color.</p>
</li>
<li>
<p><strong>transmit</strong> especifica la transparencia del elemento, que por defecto es 0.</p>
</li>
<li>
<p><strong>Filter</strong> Forma alternativa de especificar la transparencia para su uso con el módulo Povray.</p>
</li>
</ul>
<p>Una vez que se han creado los elementos apropiados, podemos mostrar el objeto Graphics con <code>morphoview</code> usando Show.</p>
<pre><code>Show(g)
</code></pre>
<figure id="fig:GraphicsElements">
<div class="centering">
<p><span class="sans-serif">A</span><img
src="../Figures/VisChapter/primitives/cylinder.png" style="width:2in"
alt="image" /><span class="sans-serif">B</span><img
src="../Figures/VisChapter/primitives/arrow.png" style="width:2in"
alt="image" /><span class="sans-serif">C</span><img
src="../Figures/VisChapter/primitives/sphere.png" style="width:2in"
alt="image" /></p>
</div>
<div class="centering">
<p><span class="sans-serif">D</span><img
src="../Figures/VisChapter/primitives/text.png" style="width:2in"
alt="image" /><span class="sans-serif">E</span><img
src="../Figures/VisChapter/primitives/tube.png" style="width:2in"
alt="image" /><span class="sans-serif">F</span><img
src="../Figures/VisChapter/primitives/trianglecomplex.png"
style="width:2in" alt="image" /></p>
</div>
<figcaption><strong><span id="fig:GraphicsElements"
label="fig:GraphicsElements"></span>Graphics elements.</strong>
<strong>A</strong> Cylinder <strong>B</strong> Arrow <strong>C</strong>
Sphere <strong>D</strong> Text <strong>E</strong> Tube and
<strong>F</strong> TriangleComplex.</figcaption>
</figure>
<h4 id="example-visualizing-an-electric-field" class="unnumbered"><a class="header" href="#example-visualizing-an-electric-field">Ejemplo: Visualización de un campo eléctrico</a></h4>
<figure id="fig:ElectricField">
<div class="centering">
<img src="visualization/../Figures/VisChapter/electricexample/electric.png"
style="width:5in" />
</div>
<figcaption><strong><span id="fig:ElectricField"
label="fig:ElectricField"></span>Electric field due to a
dipole.</strong> Custom visualization created using the graphics
module.</figcaption>
</figure>
<p>Como ilustración de lo que es posible usando directamente el módulo <code>graphics</code>, crearemos una visualización del campo eléctrico debido a dos cargas puntuales Fig. <a href="visualization/graphics_module.html#fig:ElectricField">6.6</a>. Comience estableciendo algunas constantes y creando el objeto Graphics:</p>
<pre><code>var L = 2 // Size of domain to draw
var R = 1 // Separation of the charges
var dx = 0.125 // Spacing of points to draw
var eps = 1e-10 // Check for zero separation

var g = Graphics()
</code></pre>
<p>Ahora definiremos las cargas creando dos objetos List: uno contiene la fuerza de cada carga y el segundo almacena sus posiciones:</p>
<pre><code>// Electric field due to a system of point charges
var qq = [1,-1]
var xq = [ Matrix([-R/2, 0, 0]), Matrix([R/2, 0, 0])]
</code></pre>
<p>También definiremos una distancia de corte alrededor de cada carga por debajo de la cual no dibujaremos el campo eléctrico (¡recuerde que crece \(\to\infty\) a medida que nos acercamos!):</p>
<pre><code>var cutoff = 0.2
</code></pre>
<p>A continuación, necesitamos una función que calcule el campo eléctrico en un punto arbitrario. Hacemos esto sumando los campos eléctricos debidos a cada carga usando la ley de Coulomb:</p>
<pre><code>fn efield(x) {
   var e = 0
   for (q, k in qq) {
    var r=x-xq[k]
    if (r.norm()&lt;cutoff) return nil
    e+=q*r/(r.norm()^3) // = 1/r^2 * \hat{r}
  }
  return e
 }
</code></pre>
<p>Para dibujar el campo eléctrico, creamos una cuadrícula rectangular de puntos, calculamos el campo eléctrico en cada punto y dibujamos una flecha a lo largo de la orientación.</p>
<pre><code>var lambda = dx/10
for (x in -L..L:dx) for (y in -L..L:dx) {
  var x0 = Matrix([x,y,0])
  var E = efield(x0)
  if (isnil(E)) continue
  if (E.norm()&gt;eps) g.display(Arrow(x0-lambda*E,x0+lambda*E))
}
</code></pre>
<p>Ahora dibujamos las cargas, coloreándolas por su signo:</p>
<pre><code>for (q,k in qq) {
  var col = Red
  if (q&lt;0) col = Blue
  g.display(Sphere(xq[k],dx/4,color=col))
}
</code></pre>
<p>Por último, mostramos la escena:</p>
<pre><code>Show(g)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="el-módulo-povray"><a class="header" href="#el-módulo-povray">El módulo povray</a></h2>
<p>Todas las figuras de este manual han sido exportadas directamente desde los programas <em>morpho</em> que las crearon utilizando la persistencia del trazador de rayos de visión o <code>povray</code>. Un trazador de rayos es un programa que toma una descripción de la escena y renderiza una salida gráfica trazando la trayectoria de los rayos de luz individuales. Debido a que el modelo de propagación de la luz y la formación de imágenes está motivado físicamente, el resultado es de muy alta calidad. Por el contrario, <code>morphoview</code> y la mayoría de los programas gráficos utilizan técnicas de renderizado aproximado simplificadas que permiten la salida interactiva en tiempo real. En el momento de escribir este artículo, el trazado de rayos está ganando popularidad como técnica, y algunas tarjetas gráficas de alto rendimiento ahora tienen capacidad de trazado de rayos en tiempo real. <code>Povray</code> es un programa muy bien establecido que está ampliamente disponible y es multiplataforma.</p>
<p>Para usar el módulo <code>povray</code>, debe crear un objeto POVRaytracer e inicializarlo con el objeto graphics</p>
<pre><code>import povray

var pov = POVRaytracer(g)
</code></pre>
<p>Puede elegir las características de los gráficos estableciendo las propiedades de este objeto, por ejemplo:</p>
<pre><code>pov.viewpoint = Matrix([5,5,6]) // Sets where the camera is located
pov.viewangle = 18 // Controls the angular size of the view
pov.background = White // Sets the background for rendering
pov.light=[Matrix([10,10,10]), Matrix([0,0,10]), Matrix([-10,-10,10])] // Places light point sources at several positions
</code></pre>
<p>Debido a que la lista de propiedades puede resultar bastante engorrosa, es posible especificarlas a través de un objeto Camera independiente e inicializar el trazador de rayos para usar la Camera:</p>
<pre><code>var pov = POVRaytracer(g, camera=cam)
</code></pre>
<p>Consulte la sección Referencia para obtener más detalles.</p>
<p>Para producir resultados, llame al método render para crear un archivo .pov y ejecute povray:</p>
<pre><code>pov.render(“graphic.pov”)
</code></pre>
<p>De forma predeterminada, se abre el archivo .png resultante. Puede detener esto llamando a render con <code>display</code> establecido en <code>false</code>:</p>
<pre><code>pov.render(“graphic.pov”, display=false)
</code></pre>
<p>Si simplemente desea crear un archivo .pov sin ejecutar povray, use el método write:</p>
<pre><code>pov.write(“graphic.pov”)
</code></pre>
<figure id="fig:Transparency">
<div class="centering">
<img src="visualization/../Figures/VisChapter/povray/transparency.png"
style="width:4in" />
</div>
<figcaption><strong><span id="fig:Transparency"
label="fig:Transparency"></span>Randomly generated spheres</strong>
rendered with random transparency.</figcaption>
</figure>
<p>Una de las principales ventajas del trazado de rayos es el soporte natural para los efectos de transparencia. Aquí generamos 50 esferas de colocación, tamaño y transparencia aleatorias configurando la opción <code>transmitir</code>. La salida renderizada se muestra en la Fig. <a href="visualization/povray_module.html#fig:Transparency">6.7</a>.</p>
<pre><code>fn randompt(R) {
    return R*Matrix([random()-1/2, random()-1/2, random()-1/2])
}

for (i in 1..50) {
    g.display(Sphere(randompt(1.5), random()/5, transmit=random()))
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chap:Examples"><a class="header" href="#chap:Examples">Ejemplos</a></h1>
<p>En este capítulo se analizan los programas de ejemplo proporcionados para ilustrar varias características de <em>morpho</em>. Estos se pueden encontrar en la carpeta <code>examples</code> del repositorio git de morpho y se enumeran aquí en orden alfabético. Algunos se relacionan estrechamente con el material presentado en otros capítulos para los que se proporcionan referencias cruzadas.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="catenoide"><a class="header" href="#catenoide">Catenoide</a></h2>
<figure id="fig:Catenoid">
<div class="centering">
<p><img src="examples/../Figures/ExamplesChapter/catenoid/catenoid-before.png"
style="width:3in" alt="image" /><img
src="../Figures/ExamplesChapter/catenoid/catenoid-after.png"
style="width:3in" alt="image" /></p>
</div>
<figcaption><strong><span id="fig:Catenoid"
label="fig:Catenoid"></span>Catenoid.</strong> (left) initial mesh
before optimization and (right) after optimization. Only grade 1
elements are shown. Boundary elements are displayed in red.</figcaption>
</figure>
<p>Una película de jabón sostenida entre dos anillos circulares concéntricos paralelos adopta la forma de una superficie mínima llamada <em>catenoid.</em> Este es un problema de optimización relativamente simple y, por lo tanto, es un buen ejemplo para que los principiantes <em>morpho</em>.</p>
<p>La malla inicial se crea usando AreaMesh en el módulo <code>meshtools</code>:</p>
<pre><code>var r = 1.0 // radius
var ratio = 0.4 // Separation to diameter ratio
var L = 2*r*ratio // Separation

// Generate a tube / cylindrical mesh
var mesh = AreaMesh(fn (u, v) [r*cos(u), v, r*sin(u)],
                    -Pi…Pi:Pi/10,
                    -L/2..L/2:L/5,
                    closed=[true,false] )
mesh.addgrade(1)
</code></pre>
<p>El límite de la malla debe fijarse en su lugar. Podemos hacer esto creando una selección y visualizándola como se muestra en la Fig. <a href="examples/catenoid.html#fig:Catenoid">7.1</a>, panel izquierdo:</p>
<pre><code>// Select the boundary
var bnd = Selection(mesh, boundary=true)
var g = plotselection(mesh, bnd, grade=1) 
</code></pre>
<p>El problema de optimización simplemente requiere que especifiquemos el área como la cantidad a minimizar:</p>
<pre><code> // Define the optimizataion problem
var problem = OptimizationProblem(mesh) 
// Add the area energy using the built-in Area functional
var area = Area()
problem.addenergy(area) 
</code></pre>
<p>A continuación, creamos un ShapeOptimizer para realizar la optimización,</p>
<pre><code>var opt = ShapeOptimizer(problem, mesh) 
</code></pre>
<p>arreglar los elementos de frontera usando el objeto de selección que creamos,</p>
<pre><code>opt.fix(bnd)
</code></pre>
<p>y realizar la optimización. El gradiente conjugado funciona bien para este problema y converge en unas pocas iteraciones. La forma final optimizada se muestra en la Fig. <a href="examples/catenoid.html#fig:Catenoid">7.1</a>, panel derecho.</p>
<pre><code>opt.conjugategradient(1000)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="colestérico"><a class="header" href="#colestérico">Colestérico</a></h2>
<p>Un cristal líquido colestérico, en contraste con un cristal líquido nemático como se consideró en el tutorial del Capítulo X, favorece un estado retorcido. La energía elástica del cristal líquido se modifica para incluir un vector de onda quiral preferido \(q_{0}\), $$ \begin{equation} F=\frac{1}{2}\int_{C}K_{11}\left(\nabla\cdot\mathbf{n}\right)^{2}+K_{22}(\mathbf{n}\cdot\nabla\times\mathbf{n}-q_{0})^{2}+K_{33}\left|\mathbf{n}\times\nabla\times\mathbf{n}\right|^{2}dA.\label{eq:CholestericFreeEnergy} \end{equation} $$ El ejemplo colestérico minimiza la ecuación anterior en un dominio cuadrado \((x, y)\in[-L,L]\), con \(L=1/2\), junto con una energía de anclaje, $$W\int(\mathbf{n}\cdot\mathbf{\hat{y}})^{2}dl,$$ impuesta en los límites superior e inferior para promover una alineación <em>planar degenerada</em>, es decir, \(\mathbf{n}\) prefiere situarse en cualquier dirección en el plano \(x-z\). La estructura optimizada con \(q_{0}=\pi/2\) se muestra en la Fig. (<a href="examples/cholesteric.html#fig:Colest%C3%A9rico">7.2</a>).</p>
<figure id="fig:Cholesteric">
<div class="centering">
<img src="examples/../Figures/ExamplesChapter/cholesteric/cholesteric.png"
style="width:3in" />
</div>
<figcaption><span id="fig:Cholesteric"
label="fig:Cholesteric"></span><strong>Cholesteric liquid crystal on a
square domain.</strong></figcaption>
</figure>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cubo"><a class="header" href="#cubo">Cubo</a></h2>
<figure id="fig:Cube">
<div class="centering">
<p><img src="examples/../Figures/ExamplesChapter/cube/cube-init.png"
style="width:3in" alt="image" /><img
src="../Figures/ExamplesChapter/cube/cube.png" style="width:3in"
alt="image" /></p>
</div>
<figcaption><strong><span id="fig:Cube" label="fig:Cube"></span>Minimal
surface at constant enclosed volume.</strong> (left) Initial cube
(right) Final optimized structure after 4 levels of
refinement.</figcaption>
</figure>
<p>En este ejemplo se encuentra una superficie mínima con un volumen cerrado fijo, es decir, una esfera. Es muy similar a un ejemplo similar de <em>Surface Evolver</em> y, por lo tanto, puede ayudar a aquellos familiarizados con ese programa a aprender a usar <em>morpho</em>. A partir de un cubo inicial, que se muestra en la Fig. (<a href="examples/cube.html#fig:Cube">7.3</a>), y creado de la siguiente manera:</p>
<pre><code> // Create an initial cube
var m = PolyhedronMesh([ [-0.5, -0.5, -0.5],
                         [ 0.5, -0.5, -0.5],
                         [-0.5,  0.5, -0.5],
                         [ 0.5,  0.5, -0.5],
                         [-0.5, -0.5,  0.5],
                         [ 0.5, -0.5,  0.5],
                         [-0.5,  0.5,  0.5],
                         [ 0.5,  0.5,  0.5]],
                       [ [0,1,3,2], [4,5,7,6],
                         [0,1,5,4], [3,2,6,7],
                         [0,2,6,4], [1,3,7,5] ])
</code></pre>
<p>El problema y el optimizador están configurados:</p>
<pre><code>var problem = OptimizationProblem(m)
var la = Area()
problem.addenergy(la)

var lv = VolumeEnclosed()
problem.addconstraint(lv)

var opt = ShapeOptimizer(problem, m)
</code></pre>
<p>La malla se optimiza, luego se refina y luego se vuelve a optimizar:</p>
<pre><code>var Nlevels = 4 // Levels of refinement
var Nsteps = 1000 // Maximum number of steps per refinement level

for (i in 1..Nlevels) {
  opt.conjugategradient(Nsteps)
  if (i==Nlevels) break
  // Refine
  var mr=MeshRefiner([m])
  var refmap = mr.refine()
  for (el in [problem, opt]) el.update(refmap)
  m = refmap[m]
}
</code></pre>
<p>Y finalmente se compara el área resultante con el área real de una esfera al mismo volumen:</p>
<pre><code>var V0=lv.total(m)
var Af=la.total(m)
var R=(V0/(4/3*Pi))^(1/3)
var area = 4*Pi*R^2
print “Final area: ${Af} True area: ${area} diff: ${abs(Af-area)}”
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="delaunay"><a class="header" href="#delaunay">Delaunay</a></h2>
<figure id="fig:Delaunay">
<div class="centering">
<p><img src="examples/../Figures/ExamplesChapter/delaunay/delaunay-2d.png"
style="width:3in" alt="image" /><img
src="../Figures/ExamplesChapter/delaunay/delaunay-3d.png" style="width:3in"
alt="image" /></p>
</div>
<figcaption><strong><span id="fig:Delaunay"
label="fig:Delaunay"></span>Delaunay triangulation.</strong> (left)
Triangulation of random 2D point cloud (right) Tetrahedralization of
random 3D point cloud.</figcaption>
</figure>
<p>En este ejemplo se muestra el uso del módulo <code>delaunay</code> para crear una triangulación de Delaunay a partir de una nube de puntos. La triangulación generada se comprueba explícitamente para la propiedad de que ningún otro punto que no sean los vértices se encuentra dentro de la circunesfera de cada triángulo.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="dla"><a class="header" href="#dla">DLA</a></h2>
<figure id="fig:DLA">
<div class="centering">
<img src="examples/../Figures/ExamplesChapter/dla/dla.png" style="width:6in" />
</div>
<figcaption><span id="fig:DLA" label="fig:DLA"></span><strong>Aggregate
produced by diffusion limited aggregation.</strong></figcaption>
</figure>
<p>La agregación limitada por difusión es un proceso que describe la formación de agregados de partículas pegajosas. Una partícula inicial de radio \(r\) se coloca en \( x_0=(0,0,0) \). Las partículas subsiguientes se agregan una por una a partir de los puntos aleatorios iniciales \(\mathbf{x}_{i}^{0}=R\mathbf{\xi}/|\mathbf{\xi}|\) donde \(\xi\) es un punto aleatorio normalmente distribuido en cada eje; La construcción \(\mathbf{\xi}/|\mathbf{\xi}|\) genera un punto aleatorio en la esfera unitaria. En <em>morpho</em>, esto se ve así</p>
<pre><code>fn randompt() {
  var x = Matrix([randomnormal(), randomnormal(), randomnormal()])
  return R*x/x.norm() 
}
</code></pre>
<p>La partícula móvil se mueve difusivamente, de acuerdo con</p>
<p>$$ x_i^{n+1}=x_i^{n}+\delta\xi$$</p>
<p>donde \(\delta\) es un número pequeño. A medida que la partícula se mueve, comprobamos si ha colisionado con alguna otra partícula, $$\left|x_{i}-x_{j}\right|&lt;2r,\forall i\neq j,\label{eq:collisioncheck}$$ o si se ha salido de los límites, $$\left|x_{i}\right|&gt;2R.$$ Si una partícula ha colisionado con otra partícula, queda fija en su lugar y se une al agregado. A medida que se agregan partículas, el agregado desarrolla una morfología fractalina característica, como se muestra en la Fig. <a href="examples/dla.html#fig:DLA">7.5</a>. El cuerpo del programa es un bucle doble:</p>
<pre><code>for (n in 1..Np) { // Add particles one-by-one  
  var x = randompt()
  while (true) {
    // Move current particle
    x+=Matrix([delta*randomnormal(), delta*randomnormal(), delta*randomnormal()])

    // Check for collisions
    /* … */

    // Catch if it wandered out of the boundary
    if (x.norm()&gt;2*R) x = randompt() 
  }
}
</code></pre>
<p>Para realizar la comprobación de colisiones, el ejemplo utiliza una estructura de datos llamada árbol \(k\)-dimensional, que se proporciona en el módulo 'kdtree'. Un árbol \(k\)-dimensional proporciona una búsqueda de vecino más cercano con \(O(\log N)\) complejidad en lugar de \(O(N)\) complejidad como se requeriría buscando todos los puntos directamente. El código de comprobación de colisión tiene el siguiente aspecto:</p>
<pre><code>if ((tree.nearest(x).location-x).norm()&lt;2*r) {
  tree.insert(x)
  pts.append(x)
  if (x.norm()&gt;R/2) R = 2*x.norm()
  break // Move to next particle
}
</code></pre>
<p>Observe que expandimos gradualmente \(R\) a medida que crece el agregado. Idealmente, cada punto debería comenzar muy lejos, realmente en el infinito, pero esto sería muy costoso en términos del número de pasos de difusión. Un valor de \(R\) el doble de la mayor extensión del agregado es un buen compromiso entre la velocidad y una aproximación razonable de la agregación limitada por difusión.</p>
<p>En este ejemplo también se muestra cómo crear una visualización personalizada sencilla directamente mediante el módulo <code>graphics</code>. Las partículas se dibujan como esferas y se muestran con el siguiente código. En la Fig. <a href="examples/dla.html#fig:DLA">7.5</a>.</p>
<pre><code>var col = Gray(0.5)
var g = Graphics()
g.background = White
for (x in pts) g.display(Sphere(x, r, color=col))
Show(g)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="electrostática"><a class="header" href="#electrostática">Electrostática</a></h2>
<p>Este ejemplo muestra cómo resolver un problema electrostático simple con refinamiento adaptativo y proporciona un ejemplo útil de cómo convertir un problema que normalmente se considera como la resolución de un PDE como un problema de optimización.</p>
<p>Supongamos que queremos resolver la ecuación de Laplace,</p>
<p>$$\nabla^{2}\phi=0$$</p>
<p>en un dominio cuadrado \(C\) definido por \(-L/2\leq x\leq L/2\) y \(-L/2\leq y\leq L/2\). Una formulación equivalente adecuada para <em>morpho</em> es minimizar,</p>
<p>$$ \begin{equation} \int_{C}\left|\nabla\phi\right|^{2}dA \label{eq:el1} \end{equation} $$</p>
<p>con respecto a \(\phi\).</p>
<p>Podemos demostrar que los dos son equivalentes aplicando el cálculo de variaciones a la \eqref{eq:el1},</p>
<p>$$ \delta\int*{C}\left|\nabla\phi\right|^{2}dA =\int*{C}\delta\left|\nabla\phi\right|^{2}dA $$ $$ =\int_{C}\frac{\partial}{\partial\nabla\phi}\left|\nabla\phi\right|^{2}\cdot\delta\nabla\phi dA,$$</p>
<p>e integrando por partes,</p>
<p>$$ \begin{align} \int_{C}\frac{\partial}{\partial\nabla\phi}\left|\nabla\phi\right|^{2}\cdot\delta\nabla\phi dA &amp; =\int_{\partial C}\nabla\phi\cdot\hat{\mathbf{s}}\delta\phi dl-\int_{C}\nabla\cdot\frac{\partial}{\partial\nabla\phi}\left|\nabla\phi\right|^{2}\delta\phi dA\nonumber \\ &amp; =\int_{\partial C}\nabla\phi\cdot\hat{\mathbf{s}}\delta\phi dl-\int_{C}\nabla^{2}\phi\delta\phi dA,\label{eq:bulkvariations} \end{align} $$</p>
<blockquote>
<p><strong>Nota</strong> Si no estás familiarizado con el cálculo de variaciones, siéntete libre de omitir los párrafos que se refieren a "variaciones". El cálculo de variaciones generaliza el cálculo de la diferenciación con respecto a las variables a la diferenciación con respecto a las funciones.</p>
</blockquote>
<p>donde \(\hat{\mathbf{s}}\) es la normal externa. Por lo tanto, permitiendo variaciones arbitrarias \(\delta\phi\), para que el integrando masivo desaparezca, la ecuación de Laplace \(\nabla^{2}\phi=0\) debe ser satisfecha. De manera similar, al requerir que el integrando de frontera desaparezca, se obtiene la condición de contorno "natural" \(\nabla\phi\cdot\hat{\mathbf{s}}=0\), conocida como la condición de contorno de Neumann. En ausencia de energías límite, la resolución de \(\nabla^{2}\phi=0\) en \(C\) sujeta a \(\nabla\phi\cdot\hat{\mathbf{s}}=0\) en \(\partial C\) produce la familia de soluciones constantes uniformes \(\phi=\text{const}.\)</p>
<p>Para imponer datos de límites, complementaremos \eqref{eq:el1} con la funcionalidad adicional,</p>
<p>$$ \begin{equation} \lambda\int_{\partial C}\left[\phi-\phi_{0}(\mathbf{x})\right]^{2}dl\label{eq:anchoring} \end{equation} $$</p>
<p>donde la función \(\phi_{0}\) representa algún potencial límite impuesto. Tomando variaciones de este funcional,</p>
<p>$$ \begin{align} \delta\lambda\int_{\partial C}\left[\phi-\phi_{0}(\mathbf{x})\right]^{2}dl &amp; =\lambda\int_{\partial C}\frac{\partial}{\partial\phi}\left[\phi-\phi_{0}(\mathbf{x})\right]^{2}\delta\phi dl\nonumber \\ &amp; =\lambda\int_{\partial C}2\left[\phi-\phi_{0}(\mathbf{x})\right]\delta\phi dl\label{eq:boundary} \end{align} $$</p>
<p>Recopilando los términos de frontera de \eqref{eq:bulkvariations} y \eqref{eq:boundary}, obtenemos la condición de frontera equivalente en \(\phi\), $$\nabla\phi\cdot\hat{\mathbf{s}}+2\lambda(\phi-\phi_{0})=0,$$ que se conoce como condición de límite de Robin. Como \(\lambda\to\infty\), \(\phi\to\phi_0\) en el límite, recuperando un límite fijo o condición de Dirichlet, mientras que como \(\lambda\to0\), recuperamos las condiciones de Neumann discutidas anteriormente.</p>
<p>En el ejemplo, estableceremos \(\phi_0=0\) en el límite izquierdo e inferior y \(\phi_0=1\) en el límite derecho y superior, y usaremos \(\lambda=100\).</p>
<p>El código ilustra algunos trucos de <em>morpho</em>. En primer lugar, se utiliza el siguiente código para seleccionar los lados izquierdo/inferior y superior/derecho de la malla:</p>
<pre><code>var bnd = Selection(mesh, boundary=true)
var bnd1 = Selection(mesh, fn (x,y,z) abs(x+L/2)&lt;0.01 || abs(y+L/2)&lt;0.01)
var bnd2 = Selection(mesh, fn (x,y,z) abs(x-L/2)&lt;0.01 || abs(y-L/2)&lt;0.01)
for (b in [bnd1, bnd2]) b.addgrade(1)
bnd1=bnd.intersection(bnd1)
bnd2=bnd.intersection(bnd2)
</code></pre>
<p>Lo que sucede aquí es que seleccionamos todo el límite en la primera línea y luego seleccionamos los vértices relevantes en las dos líneas siguientes. A continuación, los bordes se añaden a la selección con <code>addgrade</code>, pero esto también selecciona algunos bordes interiores. Para asegurarnos de que solo tenemos bordes de límite en nuestras selecciones, encontramos la intersección de <code>bnd1</code> y <code>bnd</code>, y de manera similar para <code>bnd2</code>.</p>
<p>La configuración del problema implica sumar la energía electrostática Eq.\eqref{eq:el1} usando <code>GradSq</code> y los términos de frontera Eq.\eqref{eq:anchoring} como 'LineIntegral's.</p>
<pre><code>var problem = OptimizationProblem(mesh)
var le = GradSq(phi)
problem.addenergy(le)
var v1 = 0, v2 = 1
var lt1 = LineIntegral(fn (x, v) (v-v1)^2, phi)
problem.addenergy(lt1, selection=bnd1, prefactor=100)
var lt2 = LineIntegral(fn (x, v) (v-v2)^2, phi)
problem.addenergy(lt2, selection=bnd2, prefactor=100)
</code></pre>
<p>La optimización se realiza con un <code>FieldOptimizer</code>:</p>
<pre><code>var opt = FieldOptimizer(problem, phi)
opt.conjugategradient(100)
</code></pre>
<p>El problema, tal como se plantea, requiere que \(\phi\) cambie muy bruscamente en las córneas superior izquierda e inferior derecha a medida que los cambios potenciales impuestos, pero lejos de estos \(\phi\) cambia mucho más lentamente. Por lo tanto, nos gustaría realizar un <em>refinamiento adaptativo</em>, refinando la malla solo en lugares donde \(\phi\) está cambiando rápidamente y usando elementos gruesos en otros lugares.</p>
<p>Para identificar los elementos que se van a refinar, calculamos la energía electrostática en cada elemento, usaremos esto como una medida heurística de la rapidez con la que \(\phi\) está cambiando y encontraremos la energía media por elemento. A continuación, creamos una selección y seleccionamos manualmente los elementos que tienen una energía electrostática superior a \(1,5\times\) la media.</p>
<pre><code>// Select elements that have an above average contribution to the energy
var en = le.integrand(phi) // energy in each element
var mean = en.sum()/en.count() // mean energy per element
var srefine = Selection(mesh)
for (id in 0…en.count()) if (en[0,id]&gt;1.5*mean) srefine[2,id]=true
// identify large contributions
</code></pre>
<p>A continuación, el refinamiento se realiza con un objeto MeshRefiner del módulo <code>meshtools</code>, que creamos con una lista tanto de la malla para refinar <em>y</em> todas las cantidades que hacen referencia a la malla:</p>
<pre><code>var ref = MeshRefiner([mesh, phi, bnd, bnd1, bnd2])
</code></pre>
<p>El refinamiento se realiza utilizando la selección <code>srefine</code> que se acaba de crear</p>
<pre><code>var refmap = ref.refine(selection=srefine)
</code></pre>
<p>que devuelve un diccionario que asigna las cantidades antiguas a las nuevas refinadas. Usamos este diccionario para actualizar OptimizationProblem y FieldOptimizer,</p>
<pre><code>for (el in [problem, opt]) el.update(refmap)
</code></pre>
<p>y finalmente actualizar nuestras variables</p>
<pre><code>mesh = refmap[mesh]
phi = refmap[phi]
bnd = refmap[bnd]
bnd1 = refmap[bnd1]
bnd2 = refmap[bnd2]
</code></pre>
<p>Por último, equiangulamos la malla para ayudar a evitar elementos estrechos,</p>
<pre><code>equiangulate(mesh)
</code></pre>
<p>Una vez que se completa el refinamiento, se puede producir una mayor optimización en la malla recién refinada</p>
<pre><code>opt.conjugategradient(1000)
</code></pre>
<p>El proceso de refinamiento y optimización que acabamos de describir tiene lugar en un bucle. La malla resultante después de 10 iteraciones se muestra en la Fig. <a href="examples/electrostatics.html#fig:Electrostatics">7.6</a>, junto con la solución \(\phi\). El código se ejecuta en unos pocos segundos, lo que proporciona una aceleración considerable en comparación con la optimización en una cuadrícula fina para obtener una precisión comparable.</p>
<figure id="fig:Electrostatics">
<div class="centering">
<p><img
src="../Figures/ExamplesChapter/electrostatics/electrostatics-mesh.png"
style="width:3in" alt="image" /><img
src="../Figures/ExamplesChapter/electrostatics/electrostatics-result.png"
style="width:3in" alt="image" /></p>
</div>
<figcaption><span id="fig:Electrostatics"
label="fig:Electrostatics"></span><strong>Electrostatics problem on a
square domain</strong> (left) mesh after 10 iterations of adaptive
refinement and optimization and (right) the resulting solution. Grade 1
elements are shown to emphasize the mesh structure.</figcaption>
</figure>
<div style="break-before: page; page-break-before: always;"></div><h2 id="implicitmesh"><a class="header" href="#implicitmesh">Implicitmesh</a></h2>
<p>Estos ejemplos ilustran cómo utilizar el módulo <code>implicitmesh</code> para generar superficies descritas como el conjunto cero de una función escalar. Los ejemplos de <code>sphere.morpho</code> y <code>torus.morpho</code> se describen con más detalle en el Capítulo X, Sección Y. El <code>threesurface.morpho</code> restante crea una triangulación de una superficie con tres controladores, $$r_{z}^{4}z^{2}-\left(1-\left(\frac{x}{r_{x}}\right)^{2}-\left(\frac{y}{r_{y}}\right)^{2}\right)\left((x-x_{1})^{2}+y^{2}-r_{1}^{2}\right)\left((x+x_{1})^{2}+y^{2}-r_{1}^{2}\right)\left(x^{2}+y^{2}-r_{1}^{2}\right)=0,$$ donde \(r_{x}\), \(r_{y}\), \(r_{z}\), \(r_{1}\) y \(x_{1}\) son parámetros. La superficie resultante se muestra en la Fig. <a href="examples/implicitmesh.html#fig:Threesurface">7.7</a>.</p>
<figure id="fig:Threesurface">
<div class="centering">
<img src="examples/../Figures/ExamplesChapter/implicitmesh/threesurface.png"
style="width:4in" />
</div>
<figcaption><span id="fig:Threesurface"
label="fig:Threesurface"></span><strong>Surface with three
handles</strong> generated with the <code>implicitmesh</code>
module.</figcaption>
</figure>
<div style="break-before: page; page-break-before: always;"></div><h2 id="meshgen"><a class="header" href="#meshgen">Meshgen</a></h2>
<p>Los ejemplos de esta carpeta ilustran varias técnicas para crear mallas con el módulo <code>meshgen</code>. En la Fig. <a href="examples/meshgen.html#fig:Meshgen-2D">7.8</a>; los de 3D se muestran en la Fig. <a href="examples/meshgen.html#fig:Meshgen-3D">7.9</a>. Véase también la <a href="examples/../working_with_meshes/meshgen_module.html">Sección Meshgen</a> del <a href="examples/../working_with_meshes.html">Capítulo Trabajar con Mallas</a> para una discusión adicional del módulo <code>meshgen</code>.</p>
<figure id="fig:Meshgen-2D">
<div class="centering">
<p><span class="sans-serif">A<img
src="../Figures/ExamplesChapter/meshgen/disk.png" style="width:3in"
alt="image" />B<img src="examples/../Figures/ExamplesChapter/meshgen/ellipse.png"
style="width:3in" alt="image" /></span></p>
</div>
<div class="centering">
<p><span class="sans-serif">C<img
src="../Figures/ExamplesChapter/meshgen/halfdisk.png" style="width:3in"
alt="image" />D<img
src="../Figures/ExamplesChapter/meshgen/overlappingdisks.png"
style="width:3in" alt="image" /></span></p>
</div>
<div class="centering">
<p><span class="sans-serif">E<img
src="../Figures/ExamplesChapter/meshgen/superellipse.png" style="width:3in"
alt="image" />F<img src="examples/../Figures/ExamplesChapter/meshgen/weighted.png"
style="width:3in" alt="image" /></span></p>
</div>
<figcaption><span id="fig:Meshgen-2D"
label="fig:Meshgen-2D"></span><strong>2D meshes created with
the</strong> <strong><code>meshgen</code></strong>
<strong>module.</strong> <strong>A</strong> <code>disk.morpho</code>,
<strong>B</strong> <code>ellipse.morpho</code>, <strong>C</strong>
<code>halfdisk.morpho</code>, <strong>D</strong>
<code>overlappingdisks.morpho</code>, <strong>E</strong>
<code>superellipse.morpho</code>, <strong>F</strong>
<code>weighted.morpho</code></figcaption>
</figure>
<figure id="fig:Meshgen-3D">
<div class="centering">
<p><span class="sans-serif">A<img
src="../Figures/ExamplesChapter/meshgen/sphere.png" style="width:3in"
alt="image" />B<img
src="../Figures/ExamplesChapter/meshgen/ellipsoidsection.png"
style="width:3in" alt="image" /></span></p>
</div>
<div class="centering">
<p><span class="sans-serif">C<img
src="../Figures/ExamplesChapter/meshgen/superellipsoid.png"
style="width:3in" alt="image" /></span></p>
</div>
<figcaption><span id="fig:Meshgen-3D"
label="fig:Meshgen-3D"></span><strong>3D meshes created with
the</strong> <strong><code>meshgen</code></strong>
<strong>module.</strong> <strong>A</strong> <code>sphere.morpho</code>,
<strong>B</strong><code> ellipsoidsection.morpho</code>,
<strong>C</strong> <code>superellipsoid.morpho.</code></figcaption>
</figure>
<div style="break-before: page; page-break-before: always;"></div><h2 id="meshslice"><a class="header" href="#meshslice">Meshslice</a></h2>
<figure id="fig:Meshslice">
<div class="centering">
<img src="examples/../Figures/ExamplesChapter/meshslice/meshslice2.png"
style="width:4in" />
</div>
<figcaption><strong><span id="fig:Meshslice"
label="fig:Meshslice"></span>Mesh sliced along three planes</strong>
showing a scalar field interpolated onto each slice.</figcaption>
</figure>
<p>En este ejemplo se muestra cómo utilizar el módulo <code>meshslice</code> para crear un sector a través de una malla con fines de visualización. El programa utiliza una malla esférica,</p>
<pre><code>var m = Mesh(“sphere.mesh”)
m.addgrade(1)
m.addgrade(2)
</code></pre>
<p>y crea un par de campos de ejemplo, un escalar,</p>
<pre><code>var phi = Field(m, fn (x,y,z) x+y+z)
</code></pre>
<p>y un vector,</p>
<pre><code>var nn = Field(m, fn (x,y,z) Matrix([x,y,z])/sqrt(x^2+y^2+z^2))
</code></pre>
<p>Se crea un MeshSlicer para realizar el corte,</p>
<pre><code>var slice = MeshSlicer(m)
var slc = slice.slice([0,0,0], [1,0,0])
</code></pre>
<p>y luego también se crean campos interpolados a lo largo de esta rebanada,</p>
<pre><code>var sphi = slice.slicefield(phi)
var snn = slice.slicefield(nn)
</code></pre>
<p>Los elementos de grado 1 (bordes) de la malla original, junto con el campo phi interpolado en tres cortes diferentes, se muestran en la Fig. <a href="examples/meshslice.html#fig:Meshslice">7.10</a>. El programa de ejemplo ilustra algunas otras posibilidades diferentes.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="plot"><a class="header" href="#plot">Plot</a></h2>
<p>Este ejemplo ilustra el dibujo de mallas, el trazado de campos, etc. Véase el <a href="examples/../visualization.html">Capítulo de visualización</a> para obtener más detalles.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="povray"><a class="header" href="#povray">Povray</a></h2>
<p>Los ejemplos de esta carpeta ilustran el uso del módulo <code>povray</code> utilizado para producir representaciones de calidad de publicación desde dentro de los programas <em>morpho</em>. Todas las figuras de este libro se generaron utilizando este módulo.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="qtensor"><a class="header" href="#qtensor">Qtensor</a></h2>
<figure id="fig:Qtensor">
<div class="centering">
<img src="examples/../Figures/ExamplesChapter/qtensor/Qtensor_K_0.01.png"
style="width:4in" />
</div>
<figcaption><strong><span id="fig:Qtensor"
label="fig:Qtensor"></span></strong>Equilibrium configuration of nematic
LC in a disk described by the Q tensor formulation. The scalar order
parameter is shown as a density field; the local orientation extracted
from <span class="math inline">\(Q\)</span> is displayed as
cylinders.</figcaption>
</figure>
<p>Este ejemplo demuestra el uso de la formulación alternativa del tensor Q de la teoría nemática del cristal líquido. Presentamos brevemente la teoría necesaria en dos subsecciones a continuación, luego describimos la implementación en <em>morpho</em>.</p>
<h4 id="el-tensor-q"><a class="header" href="#el-tensor-q">El tensor Q</a></h4>
<p>En 2D, para un nemático uniaxial, podemos definir un tensor Q: $$Q_{ij}=S(n_{i}n_{j}-1/2\delta_{ij})$$ Aquí, el \(-1/2\delta_{ij}\) se agrega por conveniencia, para hacer que la matriz no tenga traza: $$\text{Tr}(\mathbf{Q})=Q_{ii}=S(n_{i}n_{i}-1/2\delta_{ii})=S(1-1/2(2))=0$$ Ahora, el tensor Q también es simétrico por definición:  $$Q_{ij}=Q_{ji}$$ Debido a estas dos razones, podemos escribir el tensor Q como una función solo de \(Q_{xx}\) y \(Q_{xy}\):</p>
<p>$$ \mathbf{Q}= \begin{bmatrix} Q_{xx} &amp; Q_{xy} \\ Q_{xy} &amp; -Q_{xx} \end{bmatrix}. $$</p>
<h4 id="energía-elástica-y-anclaje"><a class="header" href="#energía-elástica-y-anclaje">Energía elástica y anclaje</a></h4>
<p>La energía libre de equilibrio de Landau-de Gennes para un cristal líquido nemático se puede escribir en términos del tensor Q:</p>
<p>$$ F_{LDG}= \int_{\Omega}d^{2}{\bf x}\ \left(\frac{a_{2}}{2}\text{Tr}(\mathbf{Q}^{2})+\frac{a_{4}}{4}(\text{Tr}\mathbf{Q}^{2})^{2}+\frac{K}{2}(\nabla\mathbf{Q})^{2}\right) $$ $$ +\oint_{\partial\Omega}d{\bf x}\frac{1}{2}E_{A}\text{Tr}[(\mathbf{Q}-\mathbf{W})^{2}] $$</p>
<p>donde \(a_{2}=(\rho-1)\) y \(a_{4}=(\rho+1)/\rho^{2}\) establecen la transición isotrópica a nemática siendo \(\rho\) la densidad no dimensional. El sistema está en el estado isótropo para \(\rho&lt;1\) y en la fase nemática cuando \(\rho&gt;1\). En la fase nemática, \(\ell_{n}=\sqrt{K/a_{2}}\) establece la longitud de la coherencia nemática. Ahora,</p>
<p>$$\mathbf{Q}^{2}=\begin{bmatrix}Q_{xx} &amp; Q_{xy} \\ Q_{xy} &amp; -Q_{xx} \end{bmatrix}\begin{bmatrix}Q_{xx} &amp; Q_{xy} \\ Q_{xy} &amp; -Q_{xx} \end{bmatrix}=(Q_{xx}^{2}+Q_{xy}^{2})\begin{bmatrix}1 &amp; 0 \\\  0 &amp; 1 \end{bmatrix}$$ Por lo tanto, $$\text{Tr}(\mathbf{Q}^{2})=2(Q_{xx}^{2}+Q_{xy}^{2})$$ De manera similar, $$(\nabla\mathbf{Q})^{2}=\partial_{i}Q_{kj}\partial_{i}Q_{kj}=2{(\partial_{x}Q_{xx})^{2}+(\partial_{x} Q_{xy})^{2}+(\partial_{y}Q_{xx})^{2}+(\partial_{y}Q_{xy})^{2}}$$ Ahora, el segundo término es una integral de límite, siendo \(E_{A}\) la fuerza de anclaje. \(\mathbf{W}\) es el tensor correspondiente a la condición de contorno. Por ejemplo, para el anclaje paralelo, $$W_{ij}=(t_{i}t_{j}-1/2\delta_{ij})$$ donde \(t_{i}\) es un componente del vector tangente en el límite. \(\mathbf{W}\) es también un tensor simétrico sin trazas con dos componentes independientes \(W_{xx}\) y \(W_{xy}\). El término límite se convierte en: $$\text{Tr}[(\mathbf{Q}-\mathbf{W})^{2}]=2{Q_{xx}^{2}+Q_{xy}^{2}-2(Q_{xx}W_{xx}+Q_{xy}W_{xy})+W_{xx}^{2}+W_{xy}^{2}}$$</p>
<h4 id="problema-de-optimización"><a class="header" href="#problema-de-optimización">Problema de optimización</a></h4>
<p>Podemos formular todas las expresiones anteriores en términos de cantidades vectoriales: $$\vec{q}\equiv \{ Q_{xx},Q_{xy} \} $$ $$\vec{w}\equiv \{w_{xx},w_{xy} \}$$ Así, $$\text{Tr}(\mathbf{Q}^{2})=2||\vec{q}||^{2}$$</p>
<p>$$(\nabla\mathbf{Q})^{2}=2||\nabla\vec{q}||^{2}$$</p>
<p>$$\text{Tr}[(\mathbf{Q}-\mathbf{W})^{2}]=2||\vec{q}-\vec{w}||^{2}$$ Con estos, queremos minimizar la integral de área de $$F=\int_{\Omega}d^{2}{\bf x}\ \left(a_{2}||\vec{q}||^{2}+a_{4}||\vec{q}||^{4}+K||\nabla\vec{q}||^{2}\right)$$ junto con la energía integral de línea $$\oint_{\partial\Omega}d{\bf x}\ E_{A}||\vec{q}-\vec{w}||^{2}$$</p>
<h4 id="implementación"><a class="header" href="#implementación">Implementación</a></h4>
<p>Esta energía libre se establece fácilmente en <em>morpho</em>. Para este ejemplo, consideramos una geometría de disco 2D con radio unitario. Usamos \(\rho=1.3\), de modo que estamos en lo profundo del régimen nemático. Corregimos \(E_{\text{A}}=3\), que establece un fuerte anclaje en el límite. Con este fuerte anclaje tangencial, obtenemos una carga topológica de \(+1\) en el límite, y esto actúa como una restricción. Cuando la longitud de la coherencia nemática es comparable al diámetro del disco (\(\ell_{n}\sim R\)), la carga \(+1\) penetra en todo el disco, mientras que si (\(\ell_{n}\ll R\)), entonces una formación con 2 \(+1/2\) defectos es más estable. Para probar esto, usamos dos valores diferentes de \(K\):, 0.01 y 1.0.</p>
<p>Primero definimos todos nuestros parámetros e importamos \(\texttt{disk.mesh}\) desde el ejemplo del tactoide:</p>
<pre><code>var rho = 1.3 // Deep in the nematic phase
var EA = 3 // Anchoring strength
var K = 0.01 // Bending modulus

var a2 = (1-rho)
var a4 = (1+rho)/rho^2

var m = Mesh(“disk.mesh”)
var m = refinemesh(m) // Refining for a better result
var bnd = Selection(m, boundary=true)
bnd.addgrade(0) // add point elements
</code></pre>
<p>Definimos el tensor Q en su forma vectorial como se discutió anteriormente, inicializándolo en pequeños valores aleatorios:</p>
<pre><code>var q_tensor = Field(m, fn(x,y,z)
Matrix([0.01*random(1), 0.01*random(1)]))
</code></pre>
<p>Nótese que esto, incidentalmente, hace que el director sea paralelo a una línea de 45 grados. Ahora definimos la energía a granel, la energía de anclaje y la energía libre de distorsión de la siguiente manera:</p>
<pre><code>// Define bulk free energy
fn landau(x, q) {
  var qt = q.norm()
  var qt2=qt*qt
  return a2*qt2 + a4*qt2*qt2
}
// Define anchoring energy at the boundary
fn anchoring(x, q) {
  var t = tangent()
  var wxx = t[0]*t[0]-0.5
  var wxy = t[0]*t[1]
  return (q[0]-wxx)^2+(q[1]-wxy)^2
}

var bulk = AreaIntegral(landau, q_tensor)
var anchor = LineIntegral(anchoring, q_tensor)
var elastic = GradSq(q_tensor)
</code></pre>
<p>Equipados con las energías, definimos el <code>Problema de Optimización</code>:</p>
<pre><code>var problem = OptimizationProblem(m)
problem.addenergy(bulk)
problem.addenergy(elastic, prefactor = K)
problem.addenergy(anchor, selection=bnd, prefactor=EA)
</code></pre>
<p>Para minimizar la energía con respecto al campo, definimos el <code>FieldOptimizer</code> y realizamos una <code>búsqueda de líneas</code>:</p>
<pre><code>var opt = FieldOptimizer(problem, q_tensor)
opt.linesearch(500)
</code></pre>
<h4 id="visualización"><a class="header" href="#visualización">Visualización</a></h4>
<p>Para visualizar la configuración final, usamos el mismo fragmento de código que usamos para el ejemplo del tactoide, y definimos algunas funciones auxiliares adicionales para extraer el director y el orden del tensor Q:</p>
<pre><code>fn qtodirector(q) {
  var S = 2*q.norm()
  var Q = q/S
  var nx = sqrt(Q[0]+0.5)
  var ny = abs(Q[1]/nx)
  nx*=sign(Q[1])
  return Matrix([nx,ny,0])
}

fn qtoorder(q) {
  var S = 2*q.norm()
  return S
}
</code></pre>
<p>Los usamos para crear campos a partir de <code>q_tensor</code>.</p>
<pre><code>// Convert the q-tensor to the director and order
var nn = Field(m, Matrix([1,0,0]))
for (i in 0…m.count()) nn[i]=qtodirector(q_tensor[i])
var S = Field(m, 0)
for (i in 0…m.count()) S[i]=qtoorder(q_tensor[i])
</code></pre>
<p>y mostrarlos, reutilizando la función <code>visualizar</code> del ejemplo del tutorial de Tactoid.</p>
<pre><code>var splot = plotfield(S, style=“interpolate”)
var gnn=visualize(m, nn, 0.05)
var gdisp = splot+gnn
Show(gdisp)
</code></pre>
<p>Esto crea hermosos gráficos del nemático, que se muestran en la Fig. <a href="examples/qtensor.html#fig:Qtensor">7.11</a>. Al igual que en el ejemplo del tactoide, también podemos hacer un refinamiento adaptativo de la malla basado en la densidad de energía elástica.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="thomson"><a class="header" href="#thomson">Thomson</a></h2>
<figure id="fig:Thomson">
<div class="centering">
<img src="examples/../Figures/ExamplesChapter/thomson/thomson.png"
style="width:4in" />
</div>
<figcaption><strong><span id="fig:Thomson"
label="fig:Thomson"></span>Solution of the Thomson problem</strong> for
<span class="math inline">\(N=100\)</span> charges.</figcaption>
</figure>
<p>Considere \(N\) cargas \(q\) con posiciones \(x_i\) que están confinadas a estar en la esfera unitaria de modo que \(\left| x_i\right|=1 \) que se repelen electrostáticamente y, por lo tanto, cuya configuración minimiza la energía,  $$\frac{k}{2}\sum_{i\neq j}\frac{q^{2}}{\left|x_{i}-x_{j}\right|}$$ El problema fue planteado por el físico J. J. Thomson en 1904, en el contexto de un modelo temprano para la estructura de un átomo.</p>
<p>Para configurar esto en <em>morpho</em>, comenzamos creando una malla a partir de una secuencia de puntos aleatorios usando un objeto MeshBuilder del módulo <code>meshtools</code>. Tenga en cuenta que esta es una malla bastante inusual; consiste en \(N\) puntos no conectados sin información de conectividad.</p>
<pre><code>var build = MeshBuilder()
for (i in 1..Np) {
  var x = Matrix([2*random()-1, 2*random()-1, 2*random()-1])
  x/=x.norm() // Project onto unit sphere
  build.addvertex(x)
}
var mesh = build.build()
</code></pre>
<p>A continuación, se especifica el problema de optimización. Usamos el funcional PairwisePotential del módulo <code>functionals</code> y suministramos el potencial de Coulomb \(1/r\), junto con su derivada \(-1/r^{2}\) como funciones anónimas:</p>
<pre><code>var problem = OptimizationProblem(mesh)
var lv = PairwisePotential(fn (r) 1/r, fn (r) -1/r^2)
problem.addenergy(lv)
</code></pre>
<p>La restricción de las partículas a una esfera se implementa como una restricción de conjunto de niveles: Usamos el funcional ScalarPotential como una restricción local para asegurarnos de que cada partícula se encuentra en el contorno cero de la función escalar \(x^{2}+y^{2}+z^{2}-1\), que define la esfera unitaria.</p>
<pre><code>var lsph = ScalarPotential(fn (x,y,z) x^2+y^2+z^2-1) problem.addlocalconstraint(lsph) 
</code></pre>
<p>A continuación, se realiza la optimización:</p>
<pre><code>var opt = ShapeOptimizer(problem, mesh)
opt.stepsize=0.01/sqrt(Np)
opt.relax(5)
opt.conjugategradient(1000)
</code></pre>
<p>Observe que estimamos el tamaño del paso inicial a partir del número de partículas. Dado que cada partícula adoptará una fracción \(1/N\) del área, el tamaño del paso es \(\propto1/\sqrt{N}\). En la práctica, encontramos que dar unos pocos pasos de descenso de gradiente con relajación ayuda a acondicionar el problema al separar cualquier partícula de la distribución inicialmente aleatoria que se colocó muy cerca una de la otra. Después de esto, <code>gradiente conjugado</code> funciona bien y, por lo general, converge en alrededor de \(100\) iteraciones.</p>
<p>Una última característica interesante de este ejemplo es el uso de una visualización personalizada. Dibujamos una esfera con un centro de masa en la ubicación de cada partícula:</p>
<pre><code>var g = Graphics()
for (i in 0...mesh.count()) {
  g.display(Sphere(mesh.vertexposition(i),1/sqrt(Np)))
} 
g.display(Sphere([0,0,0],1))
Show(g)
</code></pre>
<p>Una configuración típica resultante de esto se muestra en la Fig. <a href="examples/thomson.html#fig:Thomson">7.12</a>. Tenga en cuenta que hicimos que la esfera grande fuera transparente para renderizar con el módulo povray; esto se logró agregando el argumento opcional <code>transmit=0.3</code> a la llamada a <code>Sphere</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="envolver"><a class="header" href="#envolver">Envolver</a></h2>
<figure id="fig:Wrap">
<div class="centering">
<img src="examples/../Figures/ExamplesChapter/wrap/wrap.png" style="width:4in" />
</div>
<figcaption><strong><span id="fig:Wrap" label="fig:Wrap"></span>Minimal
surface constrained to lie outside two ellipsoidal one-sided level set
constraints.</strong></figcaption>
</figure>
<p>En el ejemplo de ajuste se encuentra una superficie mínima restringida para que se encuentre fuera de dos elipsoides. La solución, que se muestra en la Fig. <a href="examples/wrap.html#fig:Wrap">7.13</a> podría representar, por ejemplo, una posible configuración para un puente de fluido que conecte dos partículas elipsoidales.</p>
<p>La idea básica de este código es "envolver" los elipsoides, comenzando con una malla inicial es un cubo que los encierra por completo. Esto se crea con PolyhedronMesh desde el módulo <code>meshtools</code>:</p>
<pre><code>// Create a initial cube
var L = 2
var cube = [[-L, -L, -L], [-L, -L, L], [-L, L, -L],
            [-L, L, L], [L, -L, -L], [L, -L, L],
            [L, L, -L], [L, L, L]]

var faces = [[7, 3, 1, 5], [7, 5, 4, 6], [7, 6, 2, 3], [3, 2, 0, 1], [0, 2, 6,   4], [1, 0, 4, 5]]

var m=PolyhedronMesh(cube, faces)
m=refinemesh(m)
</code></pre>
<p>Las partículas se implementan como restricciones de conjunto de niveles. Se define una clase Ellipsoid conveniente para ayudar a crear las restricciones adecuadas,</p>
<pre><code>class Ellipsoid { // Construct with Ellipsoid(origin, principalradii)
  init(x, r) { 
    self.origin = x
    self.principalradii = r
  }
  // Returns a level set function for this Ellipsoid
  levelset() {
    fn phi (x,y,z) {
      var x0 = self.origin, rr = self.principalradii
      return ((x-x0[0])/rr[0])^2 + ((y-x0[1])/rr[1])^2 + ((z-x0[2])/rr[2])^2 - 1     
    }
    return phi
  }
  /* Analogous code for gradient() … */
}
</code></pre>
<p>El método <code>levelset</code> fabrica una función escalar que representa el elipsoide y es adecuada para su uso con el funcional ScalarPotential. Un segundo método, <code>gradient</code>, devuelve el gradiente de esa función.</p>
<p>A continuación, se crean los dos elipsoides de interés de la siguiente manera:</p>
<pre><code>var ell1 = Ellipsoid([0,1/2,0],[1/2,1/2,1])
var ell2 = Ellipsoid([0,-1/2,0],[1,1/2,1/2])
</code></pre>
<p>El problema de optimización se configura para incluir el área de superficie sujeta al cumplimiento de las restricciones establecidas por el nivel; Estos se anotan como unilaterales, es decir, satisfechos si la malla se encuentra en cualquier punto fuera de la región de restricción.</p>
<pre><code>// We want to minimize the area
var la = Area() // Subject to level set constraints
var ls1 = ScalarPotential( ell1.levelset(), ell1.gradient() )
var ls2 = ScalarPotential( ell2.levelset(), ell2.gradient() )
var leq = EquiElement()

var problem = OptimizationProblem(m)
problem.addenergy(la)
problem.addlocalconstraint(ls1, onesided=true)
problem.addlocalconstraint(ls2, onesided=true) 
```blem.addlocalconstraint(ls2, onesided=true) 
</code></pre>
<p>Para promover la calidad de la malla, se establece un segundo problema de regularización:</p>
<pre><code>var reg = OptimizationProblem(m)
reg.addenergy(leq)
reg.addlocalconstraint(ls1, onesided=true)
reg.addlocalconstraint(ls2, onesided=true)
</code></pre>
<p>La optimización y el refinamiento se realizan de forma iterativa:</p>
<pre><code>sopt.stepsize=0.025
sopt.steplimit=0.1
ropt.stepsize=0.01
ropt.steplimit=0.2
for (refine in 1..3) {
  for (i in 1..100) {
    sopt.relax(5)
    ropt.conjugategradient(1)
    equiangulate(m)
  }
  var mr=MeshRefiner([m])
  var refmap = mr.refine()
  for (el in [problem, reg, sopt, ropt]) el.update(refmap)
  m = refmap[m]
}
</code></pre>
<p>Tenga en cuenta que establecemos <code>stepsize</code> y <code>steplimit</code> en cada optimizador; Estos valores se encontraron por ensayo y error. La forma inicial es bastante extrema, por lo que usamos <code>relax</code> para el problema de optimización principal, que es muy robusto. Llamar "equiangulado" ayuda a mantener la calidad de la malla.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="referencias"><a class="header" href="#referencias">Referencias</a></h1>
<p>Este capítulo refleja la documentación de todo lo que se envía con la distribución principal de Morpho. La documentación está organizada en los siguientes apartados:</p>
<p>La sección <a href="reference/language.html">Idioma</a> proporciona una descripción detallada del lenguaje Morpho, incluyendo la sintaxis y la semántica del lenguaje.</p>
<p>La sección <a href="reference/data_types.html">Tipos de datos</a> describe los distintos tipos de datos como <code>Lista</code>, objetos <code>Matriz</code>, etc.</p>
<p>La sección <a href="reference/computational_geometry.html">Geometría Computacional</a> proporciona la documentación de mallas, selecciones, campos y funcionales.</p>
<p>La sección <a href="reference/io.html">I/O</a> proporciona la documentación para el objeto <code>File</code>.</p>
<p>La sección <a href="reference/modules.html">Módulos</a> proporciona la documentación de los distintos módulos estándar enviados con Morpho.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="idioma"><a class="header" href="#idioma">Idioma</a></h2>
<p>Esta sección proporciona una descripción detallada del lenguaje Morpho, incluyendo la sintaxis y la semántica del lenguaje.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sintaxis"><a class="header" href="#sintaxis">Sintaxis</a></h1>
<p>Morpho proporciona un lenguaje orientado a objetos flexible similar a otros lenguajes de la familia C (como C++, Java y Javascript) con una sintaxis simplificada.</p>
<p>Los programas de Morpho se almacenan como texto plano con la extensión de archivo .morpho. Un programa se puede ejecutar desde la línea de comandos escribiendo</p>
<pre><code class="language-javascript">morpho5 program.morpho
</code></pre>
<h2 id="comentarios"><a class="header" href="#comentarios">Comentarios</a></h2>
<p>Hay dos tipos de comentarios disponibles. El primer tipo se denomina "comentario de línea" por el cual el texto después de <code>//</code> en la misma línea es ignorado por el intérprete.</p>
<pre><code class="language-javascript">a.dosomething() // Un comentario
</code></pre>
<p>Se pueden crear comentarios de 'bloque' más largos colocando texto entre <code>/*</code> y <code>*/</code>. Se ignoran las nuevas líneas</p>
<pre><code class="language-javascript">/*Éste
   es
   Un comentario más largo */
</code></pre>
<p>A diferencia de C, estos comentarios se pueden anidar</p>
<pre><code class="language-javascript">/* Un comentario /*anidado */ */
</code></pre>
<p>permitiendo al programador comentar rápidamente una sección de código.</p>
<h2 id="símbolos"><a class="header" href="#símbolos">Símbolos</a></h2>
<p>Los símbolos se utilizan para referirse a entidades con nombre, incluidas variables, clases, funciones, etc. Los símbolos deben comenzar con una letra o guión bajo _ como primer carácter y pueden incluir letras o números como el resto. Los símbolos distinguen entre mayúsculas y minúsculas.</p>
<pre><code class="language-javascript">asymbol
_alsoasymbol
another_symbol
EvenThis123
YET_ANOTHER_SYMBOL
</code></pre>
<p>Por lo general, las clases reciben nombres con una letra mayúscula inicial. Los nombres de las variables suelen estar todos en minúsculas.</p>
<h2 id="saltos"><a class="header" href="#saltos">Saltos</a></h2>
<p>Estrictamente, morpho termina las declaraciones con punto y coma como C, pero en la práctica estos suelen ser opcionales y puede comenzar una nueva línea en su lugar. Por ejemplo, en lugar de</p>
<pre><code class="language-javascript">var a = 1; // El ; es opcional
</code></pre>
<p>simplemente puede usar</p>
<pre><code class="language-javascript">var a = 1
</code></pre>
<p>Si desea poner varias instrucciones en la misma línea, puede separarlas con punto y coma:</p>
<pre><code class="language-javascript">var a = 1; print a
</code></pre>
<p>Hay algunos casos extremos a tener en cuenta: El analizador de morpho funciona aceptando una nueva línea en cualquier lugar donde espere encontrar un punto y coma. Para dividir una instrucción en varias líneas, indique a morpho que planea continuar dejando la instrucción sin terminar. Por lo tanto, haga esto:</p>
<pre><code class="language-javascript">print a +
      1
</code></pre>
<p>en lugar de esto:</p>
<pre><code class="language-javascript">print a   // &lt; Morpho cree que esta es una declaración completa
      + 1 // &lt; y por lo tanto esta línea causará un error de sintaxis
</code></pre>
<h2 id="booleanos"><a class="header" href="#booleanos">Booleanos</a></h2>
<p>Las operaciones de comparación como <code>==</code>, <code>&lt;</code> y <code>&gt;=</code> devuelven <code>verdadero</code> o <code>falso</code> dependiendo del resultado de la comparación. Por ejemplo,</p>
<pre><code class="language-javascript">print 1==2
</code></pre>
<p>imprime <code>false</code>. Las constantes <code>true</code> o <code>false</code> se proporcionan para que las use en su propio código:</p>
<pre><code class="language-javascript">return true
</code></pre>
<h2 id="nil"><a class="header" href="#nil">Nil</a></h2>
<p>La palabra clave <code>nil</code> se utiliza para representar la ausencia de un objeto o valor.</p>
<p>Tenga en cuenta que en las instrucciones <code>if</code>, un valor de <code>nil</code> se trata como <code>false</code>.</p>
<pre><code class="language-javascript">if (nil) {
    // Nunca se ejecuta.
}
</code></pre>
<h2 id="bloques"><a class="header" href="#bloques">Bloques</a></h2>
<p>El código se divide en <em>bloques</em>, que están delimitados por llaves como esta:</p>
<pre><code class="language-javascript">{
  var a = "Hola"
  print a
}
</code></pre>
<p>Esta sintaxis se utiliza en declaraciones de funciones, bucles e instrucciones condicionales.</p>
<p>Cualquier variable declarada dentro de un bloque se convierte en <em>local</em> para ese bloque y no se puede ver fuera de él. Por ejemplo,</p>
<pre><code class="language-javascript">var a = "Foo"
{
  var a = "Bar"
  print a
}
print a
</code></pre>
<p>imprimiría "Bar" y luego "Foo"; Se dice que la versión de <code>a</code> dentro del bloque de código <em>sombra</em> de la versión externa.</p>
<h2 id="precedencia"><a class="header" href="#precedencia">Precedencia</a></h2>
<p>La precedencia se refiere al orden en el que morpho evalúa las operaciones. Por ejemplo,</p>
<pre><code class="language-javascript">print 1+2*3
</code></pre>
<p>imprime <code>7</code> porque <code>2*3</code> se evalúa antes de la suma; Se dice que el operador '*' tiene mayor prioridad que <code>+</code>.</p>
<p>Siempre puede modificar el orden de evaluación mediante paréntesis:</p>
<pre><code class="language-javascript">print (1+2)*3 // imprime 9
</code></pre>
<h2 id="imprimir"><a class="header" href="#imprimir">Imprimir</a></h2>
<p>La palabra <code>print</code> se utiliza para imprimir información en la consola. Puede ir seguido de cualquier valor, p. ej.</p>
<pre><code class="language-javascript">print 1
print true
print a
print "Hola"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="valores"><a class="header" href="#valores">Valores</a></h1>
<p>Los valores son la unidad básica de información en morpho: Todas las funciones en morpho aceptan valores como argumentos y devuelven valores.</p>
<h2 id="int"><a class="header" href="#int">Int</a></h2>
<p>Morpho proporciona números enteros, que funcionan como cabría esperar en otros idiomas, aunque rara vez es necesario preocuparse por la distinción entre números flotantes y enteros.</p>
<p>Convierta un número de coma flotante en un número entero:</p>
<pre><code class="language-javascript">print Int(1.3) // esperado: 1
</code></pre>
<p>Convierta una cuerda en un entero:</p>
<pre><code class="language-javascript">print Int("10")+1 // esperado: 11
</code></pre>
<h2 id="flotar"><a class="header" href="#flotar">Flotar</a></h2>
<p>Morpho proporciona números de coma flotante de doble precisión.</p>
<p>Convierta una cadena en un número de coma flotante:</p>
<pre><code class="language-javascript">print Float("1.2e2")+1 // esperado: 121
</code></pre>
<h2 id="ceil"><a class="header" href="#ceil">Ceil</a></h2>
<p>Devuelve el entero más pequeño mayor o igual que su argumento:</p>
<pre><code class="language-javascript">print ceil(1.3) // esperado: 2
</code></pre>
<h2 id="floor"><a class="header" href="#floor">Floor</a></h2>
<p>Devuelve el entero más grande menor o igual que su argumento:</p>
<pre><code class="language-javascript">print floor(1.3) // esperado: 1
</code></pre>
<h2 id="formato"><a class="header" href="#formato">Formato</a></h2>
<p>El método format convierte un número en un <code>String</code> utilizando un especificador de formato dado:</p>
<pre><code class="language-javascript">print (1/3).format("%4.2g") // Salidas: 0.33
</code></pre>
<p>El especificador debe comenzar con <code>%</code> y puede incluir:</p>
<ul>
<li>Un ancho mínimo, dado como un número entero.</li>
<li>Número de decimales que se mostrarán, con '.' delante.</li>
<li>Una opción de formato, ya sea 'f' o 'g' donde:</li>
</ul>
<pre><code class="language-javascript">- 'f' displays the number in decimal form, e.g. 0.01
- 'g' uses scientific notation, e.g. 1e-2
</code></pre>
<p>La sintaxis de la cadena de formato es similar a la utilizada en C y Python.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<p>Las variables se definen utilizando la palabra clave <code>var</code> seguida del nombre de la variable:</p>
<pre><code class="language-javascript">var a
</code></pre>
<p>Opcionalmente, se puede dar una tarea inicial:</p>
<pre><code class="language-javascript">var a = 1
</code></pre>
<p>Las variables definidas en un bloque de código solo son visibles dentro de ese bloque, por lo que</p>
<pre><code class="language-javascript">var greeting = "Hola"
{
    var greeting = “Adios”
    print greeting
}
print greeting
</code></pre>
<p>imprimirá</p>
<p><em>Adios</em> <em>Hola</em></p>
<p>Se pueden definir varias variables a la vez separándolas con comas</p>
<pre><code class="language-javascript">var a, b=2, c[2]=[1,2]
</code></pre>
<p>donde cada uno puede tener su propio inicializador (o no).</p>
<h2 id="indexación"><a class="header" href="#indexación">Indexación</a></h2>
<p>Morpho proporciona una serie de objetos de colección, como <code>List</code>, <code>Range</code>, <code>Array</code>, <code>Dictionary</code>, <code>Matrix</code> y <code>Sparse</code>, que pueden contener más de un valor. La notación de índice (a veces llamada notación de subíndice) se utiliza para acceder a los elementos de estos objetos.</p>
<p>Para recuperar un elemento de una colección, use los corchetes <code>[</code> y <code>]</code> de la siguiente manera:</p>
<pre><code class="language-javascript">var a = List("Manzana", "Bolsa", "Gato")
print a[0]
</code></pre>
<p>que imprime <em>Apple</em>. Tenga en cuenta que se accede al primer elemento con <code>0</code>, no con <code>1</code>.</p>
<p>Del mismo modo, para establecer una entrada en una colección, use:</p>
<pre><code class="language-javascript">a[0]="Víbora"
</code></pre>
<p>que reemplazaría el primer elemento de <code>a</code> por <code>’’Adder’’</code>.</p>
<p>Algunos objetos de colección necesitan más de un índice,</p>
<pre><code class="language-javascript">var a = Matrix([[1,0],[0,1]])
print a[0,0]
</code></pre>
<p>y otros como <code>Dictionary</code> utilizan índices no numéricos,</p>
<pre><code class="language-javascript">var b = Dictionary()
b["Massachusetts"]="Boston"
b["California"]="Sacramento"
</code></pre>
<p>como en este diccionario de capitales de estado.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flujo-de-control"><a class="header" href="#flujo-de-control">Flujo de control</a></h1>
<p>Las instrucciones de flujo de control se utilizan para determinar si se ejecuta un fragmento de código seleccionado y cuántas veces. Entre ellas se encuentran:</p>
<ul>
<li><code>if</code> - ejecuta selectivamente un fragmento de código si se cumple una condición.</li>
<li><code>else</code> - ejecuta un bloque de código diferente si se produce un error en la prueba de una instrucción 'if'.</li>
<li><code>for</code> - ejecuta repetidamente una sección de código con un contador</li>
<li><code>while</code> - ejecuta repetidamente una sección de código mientras se cumple una condición.</li>
</ul>
<h2 id="if"><a class="header" href="#if">If</a></h2>
<p><code>If</code> le permite ejecutar selectivamente una sección de código dependiendo de si se cumple una condición. La versión más simple se ve así:</p>
<pre><code class="language-javascript">if (x&lt;1) print x
</code></pre>
<p>donde el cuerpo del bucle, <code>print x</code>, solo se ejecuta si x es menor que 1. El cuerpo puede ser un bloque de código para dar cabida a secciones de código más largas:</p>
<pre><code class="language-javascript">if (x&lt;1) {
    ... // haz algo
}
</code></pre>
<p>Si quieres elegir entre dos alternativas, usa <code>else</code>:</p>
<pre><code class="language-javascript">if (a==b) {
    // haz algo
} else {
    Este código solo se ejecuta si la condición es falsa
}
</code></pre>
<p>Incluso puede encadenar varias pruebas de la siguiente manera:</p>
<pre><code class="language-javascript">if (a==b) {
    // opción 1
} else if (a==c) {
    // opción 2
} else {
    // algo más
}
</code></pre>
<h2 id="while"><a class="header" href="#while">While</a></h2>
<p>Los bucles while repiten una sección de código mientras una condición es verdadera. Por ejemplo,</p>
<pre><code class="language-javascript">var k=1
while (k &lt;= 4) { print k; k+=1 }
       ^cond   ^body
</code></pre>
<p>imprime los números del 1 al 4. El bucle tiene dos secciones: <code>cond</code> es la condición que se va a ejecutar y <code>body</code> es la sección de código que se va a repetir.</p>
<p>Los bucles simples como el ejemplo anterior, especialmente aquellos que implican contar una secuencia de números, se escriben más convenientemente usando un ciclo <code>for</code>,</p>
<pre><code class="language-javascript">for (k in 1..4) print k
</code></pre>
<p>Donde los ciclos <code>while</code> pueden ser muy útiles es cuando se cambia el estado de un objeto en el ciclo, p. ej.</p>
<pre><code class="language-javascript">var a = List(1,2,3,4)
while (a.count()&gt;0) print a.pop()
</code></pre>
<p>que imprime 4,3,2,1.</p>
<h2 id="do"><a class="header" href="#do">Do</a></h2>
<p>Un ciclo <code>do</code>…<code>while</code> repite el código mientras una condición es verdadera---similar a un bucle <code>while</code>—pero la prueba ocurre al final:</p>
<pre><code class="language-javascript">var k=1
do {
  print k;
  k+=1
} while (k&lt;5)
</code></pre>
<p>que imprime 1,2,3,4</p>
<p>Por lo tanto, este tipo de bucle ejecuta al menos una interacción</p>
<h2 id="for"><a class="header" href="#for">For</a></h2>
<p>Los ciclos For permiten ejecutar repetidamente una sección de código. Vienen en dos versiones: la versión más simple se ve así,</p>
<pre><code class="language-javascript">for (var i in 1..5) print i
</code></pre>
<p>que imprime los números del 1 al 5 a su vez. La variable <code>i</code> es la <em>loop variable</em>, que adquiere un valor diferente en cada iteración. <code>1..5</code> es un rango, que denota una secuencia de números. El <em>body</em> del bucle, <code>print i</code>, es el código que se ejecutará repetidamente.</p>
<p>Morpho insertará implícitamente una <code>var</code> antes de la variable de bucle si falta, por lo que esto también funciona:</p>
<pre><code class="language-javascript">for (i in 1..5) print i
</code></pre>
<p>Si desea que la variable de bucle cuente en incrementos distintos de 1, puede especificar un tamaño de paso en el rango:</p>
<pre><code class="language-javascript">for (i in 1..5:2) print i
               ^step
</code></pre>
<p>No es necesario que los rangos sean enteros:</p>
<pre><code class="language-javascript">for (i in 0.1..0.5:0.1) print i
</code></pre>
<p>También puede reemplazar el intervalo por otros tipos de objetos de colección para recorrer su contenido:</p>
<pre><code class="language-javascript">var a = Matrix([1,2,3,4])
for (x in a) print x
</code></pre>
<p>Morpho itera sobre el objeto de colección usando una <em>variable contador</em> entero que normalmente está oculto. Si desea conocer el valor actual del contador (por ejemplo, para obtener el índice de un elemento, así como su valor), puede utilizar lo siguiente:</p>
<pre><code class="language-javascript">var a = [1, 2, 3]
for (x, i in a) print "${i}: ${x}"
</code></pre>
<p>Morpho también proporciona una segunda forma de bucle <code>for</code> similar a la de C:</p>
<pre><code class="language-javascript">for (var i=0; i&lt;5; i+=1) { print i }
     ^start   ^test ^inc.  ^body
</code></pre>
<p>que se ejecuta de la siguiente manera: start: la variable <code>i</code> se declara y se establece inicialmente en cero. Prueba: Antes de cada iteración, se evalúa la prueba. Si la prueba es <code>false</code>, el bucle termina. body: se ejecuta el cuerpo del bucle. INC: la variable <code>i</code> se incrementa en 1.</p>
<p>Puedes incluir cualquier código que desees en cada una de las secciones.</p>
<h2 id="break"><a class="header" href="#break">Break</a></h2>
<p><code>Break</code> se usa dentro de los ciclos para terminarlos antes de tiempo. Por ejemplo</p>
<pre><code class="language-javascript">for (i in 1..5) {
    if (i&gt;3) break // --.
    print i        //   | (Una vez i&gt;3)
}                  //   |
...                // &lt;-'
</code></pre>
<p>solo imprimiría 1, 2 y 3. Una vez que la condición <code>i&gt;3</code> es verdadera, la instrucción <code>break</code> hace que la ejecución continúe después del cuerpo del bucle.</p>
<p>Tanto los bucles <code>for</code> como <code>while</code> admiten break.</p>
<h2 id="continue"><a class="header" href="#continue">Continue</a></h2>
<p><code>Continue</code> se usa dentro de bucles para omitir el resto de una iteración. Por ejemplo</p>
<pre><code class="language-javascript">for (i in 1..5) {     // &lt;-.
    print "Hola"          |
    if (i&gt;3) continue // --'
    print i
}                     
</code></pre>
<p>imprime "Hola" cinco veces, pero solo imprime 1, 2 y 3. Una vez que la condición <code>i&gt;3</code> es verdadera, la instrucción <code>continue</code> hace que la ejecución se transfiera al inicio del cuerpo del bucle.</p>
<p>Los ciclos <code>for</code> tradicionales también admiten <code>continue</code>:</p>
<pre><code class="language-javascript">                // incremento de v
for (var i=0; i&lt;5; i+=1) {
    if (i==2) continue
    print i
}
</code></pre>
<p>Dado que <code>continue</code> hace que el control se transfiera <em>to el incremento section</em> en este tipo de bucle, aquí el programa imprime 0..4 pero se omite el número 2.</p>
<p>El uso de bucles 'continue' con 'while' es posible, pero no se recomienda, ya que puede producir fácilmente un bucle infinito!</p>
<pre><code class="language-javascript">var i=0
while (i&lt;5) {
    if (i==2) continue
    print i
    i+=1
}
</code></pre>
<p>En este ejemplo, cuando la condición <code>i==2</code> es <code>true</code>, la ejecución salta al principio, pero <code>i</code> <em>no es</em> incrementada. El ciclo se atasca en la iteración <code>i==2</code>.</p>
<h2 id="try"><a class="header" href="#try">Try</a></h2>
<p>Una instrucción <code>try</code> y <code>catch</code> le permite controlar los errores. Por ejemplo</p>
<pre><code class="language-javascript">try {
  // haz algo
} catch {
  “Tag” : // controlar el error
}
</code></pre>
<p>Código dentro del bloque después de que se ejecute la palabra clave <code>try</code>. Si se genera un error, Morpho busca si la etiqueta asociada con el error coincide con alguna de las etiquetas en el bloque <code>catch</code>. Si es así, se ejecuta el código después de la etiqueta coincidente. Si no se produce ningún error, el bloque catch se omite por completo.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="funciones"><a class="header" href="#funciones">Funciones</a></h1>
<p>Una función en morpho se define con la palabra clave <code>fn</code>, seguida del nombre de la función, una lista de parámetros entre paréntesis y el cuerpo de la función entre llaves. En este ejemplo se calcula el cuadrado de un número:</p>
<pre><code class="language-javascript">fn sqr(x) {
  return x*x
}
</code></pre>
<p>Una vez que se ha definido una función, puede evaluarla como cualquier otra función morpho.</p>
<pre><code class="language-javascript">print sqr(2)
</code></pre>
<h2 id="variadic"><a class="header" href="#variadic">Variadic</a></h2>
<p>Además de los parámetros regulares, las funciones también se pueden definir con parámetros <em>variadic</em>:</p>
<pre><code class="language-javascript">fn func(x, ...v) {
    for (a in v) print a
}
</code></pre>
<p>A continuación, se puede llamar a esta función con 1 o más argumentos:</p>
<pre><code class="language-javascript">func(1)
func(1, 2)
func(1, 2, 3) // Todo válido 
</code></pre>
<p>El parámetro variádico <code>v</code> captura todos los argumentos adicionales proporcionados. Las funciones no se pueden definir con más de un parámetro variádico.</p>
<p>Puede mezclar parámetros regulares, variádicos y opcionales. Los parámetros variádicos van antes que los parámetros opcionales:</p>
<pre><code class="language-javascript">fn func(x, ...v, optional=true) {
    // 
}
</code></pre>
<h2 id="optional"><a class="header" href="#optional">Optional</a></h2>
<p>Las funciones también se pueden definir con parámetros <em>opcionales</em>:</p>
<pre><code class="language-javascript">fn func(a=1) {
    print a 
}
</code></pre>
<p>Cada parámetro opcional debe definirse con un valor predeterminado (aquí <code>1</code>). A continuación, se puede llamar a la función con o sin el parámetro opcional:</p>
<pre><code class="language-javascript">func()    // a == 1 debido al valor predeterminado
func(a=2) // a == 2 suministrado por el usuario
</code></pre>
<h2 id="return"><a class="header" href="#return">Return</a></h2>
<p>La palabra clave <code>return</code> se utiliza para salir de una función, pasando opcionalmente un valor dado de vuelta a la persona que llama. <code>return</code> se puede usar en cualquier lugar dentro de una función. El siguiente ejemplo calcula el <code>n</code> ésimo número de Fibonacci,</p>
<pre><code class="language-javascript">fn fib(n) {
  if (n&lt;2) return n
  return fib(n-1) + fib(n-2)
}
</code></pre>
<p>devolviendo antes de tiempo si <code>n&lt;2</code>, de lo contrario devolviendo el resultado llamándose a sí mismo de forma recursiva.</p>
<h1 id="closures"><a class="header" href="#closures">Closures</a></h1>
<p>Las funciones en morpho pueden formar <em>closures</em>, es decir, pueden encerrar información de su contexto local. En este ejemplo,</p>
<pre><code class="language-javascript">fn foo(a) {
    fn g() { return a } 
    return g
}
</code></pre>
<p>la función <code>foo</code> devuelve una función que captura el valor de <code>a</code>. Si ahora intentamos llamar a <code>foo</code> y luego llamamos a las funciones devueltas,</p>
<pre><code class="language-javascript">var p=foo(1), q=foo(2) 
print p() // espera: 1 
print q() // esperado: 2

</code></pre>
<p>podemos ver que <code>p</code> y <code>q</code> parecen contener diferentes copias de <code>g</code> que encapsulan el valor con el que se llamó a <code>foo</code>.</p>
<p>Morpho insinúa que una función devuelta es en realidad un cierre mostrándola con corchetes dobles:</p>
<pre><code class="language-javascript">print foo(1) // se espera: &lt;&lt;fn g&gt;&gt; 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clases"><a class="header" href="#clases">Clases</a></h1>
<p>Las clases se definen utilizando la palabra clave <code>class</code> seguida del nombre de la clase. La definición incluye métodos a los que responde la clase. El método especial <code>init</code> se llama cada vez que se crea un objeto.</p>
<pre><code class="language-javascript">class Cake {
    init(type) {
        self.type = type
    }
</code></pre>
<pre><code class="language-javascript">    eat() {
        print "Un delicioso "+self.type+“pastel"
    }
}
</code></pre>
<p>Los objetos se crean llamando a la clase como si fuera una función:</p>
<pre><code class="language-javascript">var c = Cake("zanahoria")
</code></pre>
<p>Tenga en cuenta que todos los objetos en Morpho heredan de una clase base <code>Object</code>, que proporciona un conjunto de métodos estándar.</p>
<p>Véase también <code>Objeto</code>.</p>
<h2 id="is"><a class="header" href="#is">Is</a></h2>
<p>La palabra clave <code>is</code> se utiliza para especificar la superclase de una clase:</p>
<pre><code class="language-javascript">class A is B {
</code></pre>
<pre><code class="language-javascript">}
</code></pre>
<p>Todos los métodos definidos por la superclase <code>B</code> se copian en la nueva clase <code>A</code>, <em>antes</em> de cualquier método especificado en la definición de clase. Por lo tanto, puede reemplazar métodos de la superclase simplemente definiendo un método con el mismo nombre.</p>
<h2 id="with"><a class="header" href="#with">With</a></h2>
<p>La palabra clave <code>with</code> se usa junto con 'is' para insertar métodos adicionales en una definición de clase <em>sin</em> convertirlos en la superclase. A menudo se denominan "mixins". Estos métodos se insertan después de los métodos de la superclase. Se pueden especificar varias clases después de <code>with</code>; se agregan en el orden especificado.</p>
<pre><code class="language-javascript">class A is B with C, D {
</code></pre>
<pre><code class="language-javascript">}
</code></pre>
<p>Aquí <code>B</code> es la superclase de <code>A</code>, pero los métodos definidos por <code>C</code> y <code>D</code> también están disponibles para <code>A</code>. Si <code>B</code>, <code>C</code> y <code>D</code> definen métodos con el mismo nombre, los de <code>C</code> tienen prioridad sobre cualquiera de <code>B</code> y los de <code>D</code> tienen prioridad sobre <code>B</code> y <code>C</code>.</p>
<h2 id="self"><a class="header" href="#self">Self</a></h2>
<p>La palabra clave <code>self</code> se utiliza para acceder a las propiedades y métodos de un objeto desde su definición.</p>
<pre><code class="language-javascript">class Vehicle {
  init (type) { self.type = type }
</code></pre>
<pre><code class="language-javascript">  drive () { print “Manejando mi ${self.type}.” }
}
</code></pre>
<h2 id="super"><a class="header" href="#super">Super</a></h2>
<p>La palabra clave <code>super</code> le permite acceder a los métodos proporcionados por la superclase de un objeto en lugar de la suya propia. Esto es particularmente útil cuando el programador quiere que una clase amplíe la funcionalidad de una clase principal, pero necesita asegurarse de que el comportamiento anterior aún se mantiene.</p>
<p>Por ejemplo, considere el siguiente par de clases:</p>
<pre><code class="language-javascript">class Lunch {
    init(type) { self.type=type }
}
</code></pre>
<pre><code class="language-javascript">class Soup is Lunch {
    init(type) {
        print "¡Deliciosa sopa!"
        super.init(type)
    }
}
</code></pre>
<p>La subclase Soup usa <code>super</code> para llamar al inicializador original.</p>
<h1 id="objects"><a class="header" href="#objects">Objects</a></h1>
<p>Los objetos en Morpho se crean llamando a una función constructora, que generalmente tiene el mismo nombre que la clase del objeto:</p>
<pre><code class="language-javascript">var a = Color(0.5,0.5,0.5) // 50% gris 
</code></pre>
<p>Puede almacenar información en un objeto asignando a sus propiedades:</p>
<pre><code class="language-javascript">a.prop = "Foo" 
</code></pre>
<p>y puedes leer de ellos de manera similar:</p>
<pre><code class="language-javascript">print a.prop
</code></pre>
<p>La <code>clase</code> de un objeto determina los métodos que se pueden usar en el objeto. Los llamas usando el archivo . operador:</p>
<pre><code class="language-javascript">print a.clone() 
</code></pre>
<p>Véase también <code>clase</code>.</p>
<h2 id="has"><a class="header" href="#has">Has</a></h2>
<p>El método <code>has</code> se utiliza para probar si un objeto tiene una propiedad particular:</p>
<pre><code class="language-javascript">print a.has(“foo”)
</code></pre>
<p>Si llamas a <code>has</code> sin parámetros,</p>
<pre><code class="language-javascript">print a.has()
</code></pre>
<p>devuelve una lista de todas las etiquetas de propiedad que tiene un objeto.</p>
<h2 id="respondsto"><a class="header" href="#respondsto">Respondsto</a></h2>
<p>El método <code>respondsto</code> se utiliza para probar si un objeto proporciona un método en particular:</p>
<pre><code class="language-javascript">print a.respondsto(“foo”)
</code></pre>
<p>Si llamas a <code>respondsto</code> sin parámetros,</p>
<pre><code class="language-javascript">print a.respondsto()
</code></pre>
<p>devuelve una lista de todos los métodos que un objeto tiene disponibles.</p>
<h2 id="invoke"><a class="header" href="#invoke">Invoke</a></h2>
<p>El método <code>invoke</code> se utiliza para invocar un método desde su etiqueta y una lista de parámetros:</p>
<pre><code class="language-javascript">print a.invoke(“has”, “foo”)
</code></pre>
<p>es equivalente a:</p>
<pre><code class="language-javascript">print a.has(“foo”)
</code></pre>
<h2 id="clss"><a class="header" href="#clss">Clss</a></h2>
<p>El método <code>clss</code> se utiliza para obtener la clase a la que pertenece un objeto.</p>
<pre><code class="language-javascript">print a.clss() 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="módulos"><a class="header" href="#módulos">Módulos</a></h1>
<p>Morpho es extensible y proporciona un sistema de módulos conveniente que funciona como bibliotecas estándar en otros lenguajes. Los módulos pueden definir variables, funciones y clases útiles, y pueden estar disponibles utilizando la palabra clave 'import'. Por ejemplo,</p>
<pre><code class="language-javascript">import color
</code></pre>
<p>carga el módulo <code>color</code> que proporciona funcionalidad relacionada con el color.</p>
<p>Puede crear sus propios módulos; Son solo archivos morpho normales que se almacenan en un lugar estándar. En plataformas UNIX, esto es <code>/usr/local/share/morpho/modules</code>.</p>
<h2 id="import"><a class="header" href="#import">Import</a></h2>
<p>Import proporciona acceso al sistema de módulos e incluye código de varios archivos de origen.</p>
<p>Para importar código de otro archivo, use import con el nombre de archivo:</p>
<pre><code class="language-javascript">import "archivo.morfo"
</code></pre>
<p>que incluye inmediatamente todo el contenido de <code>”file.morpho”</code>. Ahora se pueden usar todas las clases, funciones o variables definidas en ese archivo, lo que le permite dividir su programa en varios archivos fuente.</p>
<p>Morpho proporciona una serie de módulos incorporados, y puede escribir los suyos propios, que se pueden cargar de la siguiente manera:</p>
<pre><code class="language-javascript">import color
</code></pre>
<p>que importa el módulo <code>color</code>.</p>
<p>Puede importar símbolos de forma selectiva de un módulo utilizando la palabra clave <code>for</code>:</p>
<pre><code class="language-javascript">import color for HueMap, Red
</code></pre>
<p>que importa solo la clase <code>HueMap</code> y la variable <code>Red</code>.</p>
<p>También puede importar un módulo utilizando la palabra clave <code>as</code> para colocar los símbolos en un espacio de nombres especificado:</p>
<pre><code class="language-javascript">import color as col 
</code></pre>
<p>A continuación, puede usar símbolos específicos como este:</p>
<pre><code class="language-javascript">print col.Red 
</code></pre>
<p>(Consulte el tema de ayuda ‘namespaces’ para obtener más información.)</p>
<h2 id="namespaces"><a class="header" href="#namespaces">Namespaces</a></h2>
<p>Un namespace es una colección de símbolos que se importa desde un módulo.  Identifica un espacio de nombres utilizando la palabra clave 'as' al importar el módulo de la siguiente manera:</p>
<pre><code class="language-javascript">import color as col // ‘col’ es el namespace

</code></pre>
<p>Todo lo definido por el módulo con un símbolo único, incluidas las clases, las funciones y las variables globales, se puede identificar utilizando el namespace, p. ej.</p>
<pre><code class="language-javascript">print col.Red 
</code></pre>
<p>Dado que los símbolos solo se definen en el namespace en el que los importó, no puede hacer referencia a ellos directamente:</p>
<pre><code class="language-javascript">print Red 
</code></pre>
<p>Se recomienda el uso de namespaces, ya que ayuda a evitar conflictos entre módulos.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ayuda"><a class="header" href="#ayuda">Ayuda</a></h1>
<p>Morpho proporciona un sistema de ayuda en línea. Para obtener ayuda sobre un tema llamado <code>topicname</code>, escriba</p>
<pre><code class="language-javascript">help topicname
</code></pre>
<p>A continuación se proporciona una lista de temas disponibles e incluye palabras clave de idioma como <code>class</code>, <code>fn</code> y <code>for</code>, clases integradas como <code>Matrix</code> y <code>File</code> o información sobre funciones como <code>exp</code> y <code>random</code>.</p>
<p>Algunos temas tienen subtemas adicionales: para acceder a estos tipos</p>
<pre><code class="language-javascript">help topic subtopic
</code></pre>
<p>Por ejemplo, para obtener ayuda sobre un método para una clase determinada, puede escribir</p>
<pre><code class="language-javascript">help Classname.methodname
</code></pre>
<p>Tenga en cuenta que <code>help</code> ignora todos los signos de puntuación.</p>
<p>También puede usar <code>?</code> como sinónimo abreviado de <code>ayuda</code></p>
<pre><code class="language-javascript">? topic
</code></pre>
<p>Una característica útil es que, si se produce un error, simplemente escriba <code>ayuda</code> para obtener más información sobre el error.</p>
<h1 id="quit"><a class="header" href="#quit">Quit</a></h1>
<p>El comando CLI <code>quit</code> sale de la ejecución <code>morpho</code> en modo interactivo y vuelve al shell.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="errores"><a class="header" href="#errores">Errores</a></h1>
<p>Cuando se produce un error al ejecutar un programa morpho, se muestra un mensaje de error junto con una explicación de en qué parte del programa se produjo el error.</p>
<p>Puede crear sus propios errores personalizados utilizando la clase <code>Error</code>:</p>
<pre><code class="language-javascript">var myerr = Error(“Tag”, "Un mensaje")
</code></pre>
<p>Utilice el método <code>throw</code> para generar el error, interrumpiendo la ejecución a menos que se detecte el error:</p>
<pre><code class="language-javascript">myerr.throw() 
</code></pre>
<p>o</p>
<pre><code class="language-javascript">myerr.throw("Un mensaje personalizado") 
</code></pre>
<p>También puede utilizar el método de <code>advertencia</code> para alertar al usuario de un problema potencial que no necesita que se interrumpa el programa.</p>
<pre><code class="language-javascript">myerr.warning() 
</code></pre>
<h2 id="asignación"><a class="header" href="#asignación">Asignación</a></h2>
<p>Este error puede producirse al crear nuevos objetos o cambiar su tamaño. Por lo general, indica que la computadora está bajo presión de memoria.</p>
<h2 id="intrnl"><a class="header" href="#intrnl">Intrnl</a></h2>
<p>Este error indica un problema interno con morpho. Póngase en contacto con los desarrolladores para obtener asistencia.</p>
<h2 id="invldop"><a class="header" href="#invldop">InvldOp</a></h2>
<p>Este error se produce cuando a un operador como <code>+</code> o <code>-</code> se le asignan operandos que no entiende. Por ejemplo,</p>
<pre><code class="language-javascript">print "Hola" * "Adiós" // Causa 'InvldOp'
</code></pre>
<p>este error se debe a que el operador de multiplicación no sabe cómo multiplicar cadenas.</p>
<p>Si los operandos son objetos, esto significa que los objetos no proporcionan un método para la operación solicitada, por ejemplo, para</p>
<pre><code class="language-javascript">print object1 / object2
</code></pre>
<p><code>object1</code> necesitaría proporcionar un método <code>div()</code> que pueda manejar con éxito <code>object2</code>.</p>
<h2 id="cnctfld"><a class="header" href="#cnctfld">CnctFld</a></h2>
<p>Este error se produce cuando se produce un error en la concatenación de cadenas u otros objetos, normalmente debido a una memoria baja.</p>
<h2 id="uncallable"><a class="header" href="#uncallable">Uncallable</a></h2>
<p>Este error se produce cuando se intenta llamar a algo que no es un método o una función. Aquí, inicializamos una variable con una cadena y la llamamos:</p>
<pre><code class="language-javascript">var f = "No es una función"
f() // Causa ‘Uncallable’

</code></pre>
<h2 id="glblrtrn"><a class="header" href="#glblrtrn">GlblRtrn</a></h2>
<p>Este error se produce cuando morpho encuentra una palabra clave <code>return</code> fuera de una definición de función o método.</p>
<h2 id="instfail"><a class="header" href="#instfail">InstFail</a></h2>
<p>Este error se produce cuando morpho intenta crear un nuevo objeto, pero algo sale mal.</p>
<h2 id="notanobj"><a class="header" href="#notanobj">NotAnObj</a></h2>
<p>Este error se produce si intenta acceder a una propiedad de algo que no es un objeto:</p>
<pre><code class="language-javascript">var a = 1
a.size = 5
</code></pre>
<h2 id="objlcksprp"><a class="header" href="#objlcksprp">ObjLcksPrp</a></h2>
<p>Este error se produce si intenta acceder a una propiedad o método que no se ha definido para un objeto:</p>
<pre><code class="language-javascript">var a = Object()
print a.pifflepaffle
</code></pre>
<p>o</p>
<pre><code class="language-javascript">print a.foo()
</code></pre>
<h2 id="noinit"><a class="header" href="#noinit">NoInit</a></h2>
<p>Este error puede ocurrir si intentas crear un nuevo objeto a partir de una clase que no tiene un método <code>init</code>:</p>
<pre><code class="language-javascript">class Foo { }
var a = Foo(0.3)
</code></pre>
<p>Aquí, el argumento <code>Foo</code> provoca el error <code>NoInit</code> porque no hay ningún método <code>init</code> disponible para procesarlo.</p>
<h2 id="notaninst"><a class="header" href="#notaninst">NotAnInst</a></h2>
<p>Este error se produce si intenta invocar un método en algo que no es un objeto:</p>
<pre><code class="language-javascript">var a = 4
print a.foo()
</code></pre>
<h2 id="clsslcksmthd"><a class="header" href="#clsslcksmthd">ClssLcksMthd</a></h2>
<p>Este error se produce si intenta invocar un método en una clase que no existe:</p>
<pre><code class="language-javascript">class Foo { }
print Foo.foo()
</code></pre>
<h2 id="invldargs"><a class="header" href="#invldargs">InvldArgs</a></h2>
<p>Este error se produce si se llama a una función con un número incorrecto de argumentos:</p>
<pre><code class="language-javascript">fn f(x) { return x }
f(1,2)
</code></pre>
<h2 id="notindxbl"><a class="header" href="#notindxbl">NotIndxbl</a></h2>
<p>Este error se produce si intenta indexar algo que no es una colección:</p>
<pre><code class="language-javascript">var a = 0.3
print a[1]
</code></pre>
<h2 id="indxbnds"><a class="header" href="#indxbnds">IndxBnds</a></h2>
<p>Este error puede producirse al seleccionar una entrada de un objeto de colección (como una lista) si el índice proporcionado es mayor que el número de entradas:</p>
<pre><code class="language-javascript">var a = [1,2,3]
print a[10]
</code></pre>
<h2 id="nonnmindx"><a class="header" href="#nonnmindx">NonNmIndx</a></h2>
<p>Este error se produce si intenta indexar una matriz con un índice no numérico:</p>
<pre><code class="language-javascript">var a[2,2]
print a[“foo”,"bar"]
</code></pre>
<h2 id="arraydim"><a class="header" href="#arraydim">ArrayDim</a></h2>
<p>[tagarraydim]: # arraydim</p>
<p>Este error se produce si intenta indexar una matriz con un número incorrecto de índices:</p>
<pre><code class="language-javascript">var a[2,2]
print a[1]
</code></pre>
<h2 id="dbgquit"><a class="header" href="#dbgquit">DbgQuit</a></h2>
<p>Esta notificación se genera después de seleccionar <code>Quit</code> en el depurador. La ejecución del programa se detiene y el control vuelve al usuario.</p>
<h2 id="symblundf"><a class="header" href="#symblundf">SymblUndf</a></h2>
<p>Este error se produce si hace referencia a algo que no se ha declarado previamente, por ejemplo, al intentar usar una variable de llamada a una función que no existe. Es posible que el símbolo esté mal escrito o que las mayúsculas no coincidan con la definición (los símbolos <em>morpho</em> distinguen entre mayúsculas y minúsculas).</p>
<p>Un problema común es intentar asignar a una variable que aún no se ha declarado:</p>
<pre><code class="language-javascript">a = 5
</code></pre>
<p>Para solucionar esto, prefije con <code>var</code>:</p>
<pre><code class="language-javascript">var a = 5
</code></pre>
<h2 id="mtrxincmptbl"><a class="header" href="#mtrxincmptbl">MtrxIncmptbl</a></h2>
<p>Este error se produce cuando se realiza una operación aritmética en dos matrices "incompatibles". Por ejemplo, dos matrices deben tener las mismas dimensiones, es decir, el mismo número de filas y columnas, para sumar o restar,</p>
<pre><code class="language-javascript">var a = Matrix([[1,2],[3,4]])
var b = Matrix([[1]])
print a+b // genera un error 'MtrxIncmptbl'.
</code></pre>
<p>O para multiplicarse, el número de columnas de la matriz de la izquierda debe ser igual al número de filas de la matriz de la derecha.</p>
<pre><code class="language-javascript">var a = Matrix([[1,2],[3,4]])
var b = Matrix([1,2])
print a*b // ok
print b*a // genera un error 'MtrxIncmptbl'.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="funciones-integradas"><a class="header" href="#funciones-integradas">Funciones integradas</a></h1>
<p>Morpho proporciona una serie de funciones integradas.</p>
<h2 id="aleatorio"><a class="header" href="#aleatorio">Aleatorio</a></h2>
<p>La función <code>random</code> genera un número aleatorio a partir de una distribución uniforme en el intervalo [0,1].</p>
<pre><code class="language-javascript">print random() 
</code></pre>
<p>Véase también <code>randomnormal</code> y <code>randomint</code>.</p>
<h2 id="randomnormal"><a class="header" href="#randomnormal">Randomnormal</a></h2>
<p>La función <code>randomnormal</code> genera un número aleatorio a partir de una distribución normal (gaussiana) con varianza unitaria y desplazamiento cero.</p>
<pre><code class="language-javascript">print randomnormal() 
</code></pre>
<p>Véase también <code>random</code> y <code>randomint</code>.</p>
<h2 id="randomint"><a class="header" href="#randomint">Randomint</a></h2>
<p>La función <code>randomint</code> genera un entero aleatorio con un valor máximo especificado.</p>
<pre><code class="language-javascript">print randomint(10) // Genera un entero aleatorio [0,10]
</code></pre>
<h2 id="isnil"><a class="header" href="#isnil">isnil</a></h2>
<p>Devuelve <code>true</code> si un valor es <code>nil</code> o <code>false</code> en caso contrario.</p>
<h2 id="isint"><a class="header" href="#isint">isint</a></h2>
<p>Devuelve <code>true</code> si un valor es un entero o <code>false</code> en caso contrario.</p>
<h2 id="isfloat"><a class="header" href="#isfloat">isfloat</a></h2>
<p>Devuelve <code>true</code> si un valor es un número de coma flotante o <code>false</code> en caso contrario.</p>
<h2 id="isbool"><a class="header" href="#isbool">isbool</a></h2>
<p>Devuelve <code>true</code> si un valor es booleano o <code>false</code> en caso contrario.</p>
<h2 id="isobject"><a class="header" href="#isobject">isobject</a></h2>
<p>Devuelve <code>true</code> si un valor es un objeto o <code>false</code> en caso contrario.</p>
<h2 id="isstring"><a class="header" href="#isstring">isstring</a></h2>
<p>Devuelve <code>true</code> si un valor es una cadena o <code>false</code> en caso contrario.</p>
<h2 id="isclass"><a class="header" href="#isclass">isclass</a></h2>
<p>Devuelve <code>true</code> si un valor es una clase o <code>false</code> en caso contrario.</p>
<h2 id="isrange"><a class="header" href="#isrange">isrange</a></h2>
<p>Devuelve <code>true</code> si un valor es un rango o <code>false</code> en caso contrario.</p>
<h2 id="isdictionary"><a class="header" href="#isdictionary">isdictionary</a></h2>
<p>Devuelve <code>true</code> si un valor es un diccionario o <code>false</code> en caso contrario.</p>
<h2 id="islist"><a class="header" href="#islist">islist</a></h2>
<p>Devuelve <code>true</code> si un valor es una lista o <code>false</code> en caso contrario.</p>
<h2 id="isarray"><a class="header" href="#isarray">isarray</a></h2>
<p>Devuelve <code>true</code> si un valor es una matriz o <code>false</code> en caso contrario.</p>
<h2 id="ismatrix"><a class="header" href="#ismatrix">ismatrix</a></h2>
<p>Devuelve <code>true</code> si un valor es una matriz o <code>false</code> en caso contrario.</p>
<h2 id="issparse"><a class="header" href="#issparse">issparse</a></h2>
<p>Devuelve <code>true</code> si un valor es una matriz dispersa o <code>false</code> en caso contrario.</p>
<h2 id="isinf"><a class="header" href="#isinf">isinf</a></h2>
<p>Devuelve <code>true</code> si un valor es infinito o <code>false</code> en caso contrario.</p>
<h2 id="isnan"><a class="header" href="#isnan">isnan</a></h2>
<p>Devuelve <code>true</code> si un valor no es un número o <code>false</code> en caso contrario.</p>
<h2 id="iscallable"><a class="header" href="#iscallable">iscallable</a></h2>
<p>Devuelve <code>true</code> si un valor es invocable o <code>false</code> en caso contrario.</p>
<h2 id="isfinite"><a class="header" href="#isfinite">isfinite</a></h2>
<p>Devuelve <code>true</code> si un valor es finito o <code>false</code> en caso contrario.</p>
<pre><code class="language-javascript">print isfinite(1) // esperado: true 
print isfinite(1/0) // esperado: false 
</code></pre>
<h2 id="isnumber"><a class="header" href="#isnumber">isnumber</a></h2>
<p>Devuelve <code>true</code> si un valor es un número real, o <code>false</code> en caso contrario.</p>
<pre><code class="language-javascript">print isnumber(1) // esperado: true 
print isnumber(Object()) // esperarado: false
</code></pre>
<h2 id="ismesh"><a class="header" href="#ismesh">ismesh</a></h2>
<p>Devuelve <code>true</code> si un valor es una <code>Malla</code>, o <code>false</code> en caso contrario.</p>
<h2 id="isselection"><a class="header" href="#isselection">isselection</a></h2>
<p>Devuelve <code>true</code> si un valor es una <code>Selección</code>, o <code>false</code> en caso contrario.</p>
<h2 id="isfield"><a class="header" href="#isfield">isfield</a></h2>
<p>Devuelve <code>true</code> si un valor es un <code>Field</code>, o <code>false</code> en caso contrario.</p>
<h2 id="apply"><a class="header" href="#apply">Apply</a></h2>
<p>Apply llama a una función con los argumentos proporcionados como una lista:</p>
<pre><code class="language-javascript">apply(f, [0.5, 0.5]) // llama f(0.5, 0.5) 

</code></pre>
<p>A menudo es útil cuando una función o método y/o el número de parámetros no se conoce de antemano. El primer parámetro que se aplica puede ser cualquier objeto invocable, incluida una invocación de método o un cierre.</p>
<p>También puede omitir la lista y usar apply con varios argumentos:</p>
<pre><code class="language-javascript">apply(f, 0.5, 0.5) // llama f(0.5, 0.5)

</code></pre>
<p>Hay un caso extremo que se produce cuando se desea llamar a una función que acepta una sola lista como parámetro. En este caso, incluya la lista en otra lista:</p>
<pre><code class="language-javascript">apply(f, [[1,2]]) // equivalente a f([1,2])
</code></pre>
<h2 id="abs"><a class="header" href="#abs">Abs</a></h2>
<p>Devuelve el valor absoluto de un número:</p>
<pre><code class="language-javascript">print abs(-10) // imprime 10 
</code></pre>
<h2 id="sign"><a class="header" href="#sign">Sign</a></h2>
<p>Da el signo de un número:</p>
<pre><code class="language-javascript">print sign(4) // esperado: 1
print sign(-10.0) // esperado: -1
print sign(0) // esperado: 0
</code></pre>
<h2 id="arctan"><a class="header" href="#arctan">Arctan</a></h2>
<p>Devuelve el arcotangente de un valor de entrada que se encuentra entre <code>-Inf</code> e <code>Inf</code>. Puedes usar un argumento:</p>
<pre><code class="language-javascript">print arctan(0) // esperado: 0
</code></pre>
<p>o use dos argumentos para devolver el ángulo en el cuadrante correcto:</p>
<pre><code class="language-javascript">print arctan(x, y)
</code></pre>
<p>Tenga en cuenta que el orden <code>x</code>, <code>y</code> difiere de algunos otros idiomas.</p>
<h2 id="exp"><a class="header" href="#exp">Exp</a></h2>
<p>Función exponencial <code>e^x</code>. Inverso de <code>log</code>.</p>
<pre><code class="language-javascript">print exp(0) // espera: 1 
print exp(Pi*im) // espera: -1 + 0IM
</code></pre>
<h2 id="log"><a class="header" href="#log">Log</a></h2>
<p>Función logaritmo natural. Inverso de <code>exp</code>.</p>
<pre><code class="language-javascript">print log(1) // esperado: 0 
</code></pre>
<h2 id="log10"><a class="header" href="#log10">Log10</a></h2>
<p>Función logarítmica de base 10.</p>
<pre><code class="language-javascript">print log10(10) // esperado: 1
</code></pre>
<h2 id="sin"><a class="header" href="#sin">Sin</a></h2>
<p>Función trigonométrica seno.</p>
<pre><code class="language-javascript">print sin(0) // esperado: 0 
</code></pre>
<h2 id="sinh"><a class="header" href="#sinh">Sinh</a></h2>
<p>Función trigonométrica sinusoidal hiperbólica.</p>
<pre><code class="language-javascript">print sinh(0) // esperado: 0 
</code></pre>
<h2 id="cos"><a class="header" href="#cos">Cos</a></h2>
<p>Función trigonométrica del coseno.</p>
<pre><code class="language-javascript">print cos(0) // esperado: 1
</code></pre>
<h2 id="cosh"><a class="header" href="#cosh">Cosh</a></h2>
<p>Función trigonométrica del coseno hiperbólico.</p>
<pre><code class="language-javascript">print cosh(0) // esperado: 1
</code></pre>
<h2 id="tan"><a class="header" href="#tan">Tan</a></h2>
<p>Función trigonométrica tangente.</p>
<pre><code class="language-javascript">print tan(0) // esperado: 0 
</code></pre>
<h2 id="tanh"><a class="header" href="#tanh">Tanh</a></h2>
<p>Función trigonométrica tangente hiperbólica.</p>
<pre><code class="language-javascript">print tanh(0) // esperado: 0 
</code></pre>
<h2 id="asin"><a class="header" href="#asin">Asin</a></h2>
<p>Función trigonométrica sinusoidal inversa. Devuelve un valor en el intervalo '[-Pi/2,Pi/2]'.</p>
<pre><code class="language-javascript">print asin(0) // esperado: 0 
</code></pre>
<h2 id="acos"><a class="header" href="#acos">Acos</a></h2>
<p>Función trigonométrica del coseno inverso. Devuelve un valor en el intervalo '[-Pi/2,Pi/2]'.</p>
<pre><code class="language-javascript">print acos(1) // esperado: 0 
</code></pre>
<h2 id="sqrt"><a class="header" href="#sqrt">Sqrt</a></h2>
<p>Función de raíz cuadrada.</p>
<pre><code class="language-javascript">print sqrt(4) // esperado: 2
</code></pre>
<h2 id="min"><a class="header" href="#min">Min</a></h2>
<p>Busca el valor mínimo de sus argumentos. Si alguno de los argumentos son objetos y son enumerables (por ejemplo, una <code>lista</code>), <code>min</code> buscará dentro de ellos un valor mínimo. Acepta cualquier número de argumentos.</p>
<pre><code class="language-javascript">print min(3,2,1) // espera: 1 
print min([3,2,1]) // espera: 1 
print min([3,2,1],[0,-1,2]) // esperado: -2 
</code></pre>
<h2 id="max"><a class="header" href="#max">Max</a></h2>
<p>Busca el valor máximo de sus argumentos. Si alguno de los argumentos son objetos y son enumerables (por ejemplo, una <code>Lista</code>), <code>max</code> buscará dentro de ellos un valor máximo. Acepta cualquier número de argumentos.</p>
<pre><code class="language-javascript">print min(3,2,1) // esperado: 3 
print min([3,2,1]) // esperaso: 3
print min([3,2,1],[0,-1,2]) // esperado: 3 
</code></pre>
<h2 id="bounds"><a class="header" href="#bounds">Bounds</a></h2>
<p>Devuelve los resultados de 'min' y 'max' como una lista, proporcionando un conjunto de límites para sus argumentos y cualquier objeto enumerable dentro de ellos.</p>
<pre><code class="language-javascript">print bounds(1,2,3) // esperado: [1,3]
print bounds([3,2,1],[0,-1,2]) // esperado: [-1,3]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="tipos-de-datos"><a class="header" href="#tipos-de-datos">Tipos de datos</a></h2>
<p>Esta sección describe los diversos tipos de datos como <code>Lista</code>, objetos <code>Matriz</code>, etc.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="array"><a class="header" href="#array">Array</a></h1>
<p>Las matrices son objetos de colección que pueden tener cualquier número de índices. Su tamaño se establece cuando se crean:</p>
<pre><code class="language-javascript">var a[5]
var b[2,2]
var c[nv,nv,nv]
</code></pre>
<p>Los valores se pueden recuperar con los índices adecuados:</p>
<pre><code class="language-javascript">print a[0,0]
</code></pre>
<p>Las matrices se pueden indexar con segmentos:</p>
<pre><code>print a[[0,2,4],2]
print a[1,0..2]
</code></pre>
<p>Cualquier valor morpho se puede almacenar en un elemento de matriz</p>
<pre><code class="language-javascript">a[0,0] = [1,2,3]
</code></pre>
<h2 id="dimensions"><a class="header" href="#dimensions">Dimensions</a></h2>
<p>Obtenga las dimensiones de un objeto Array:</p>
<pre><code class="language-javascript">var a[2,2]
print a.dimensions() // esperado: [ 2, 2 ]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="complejo"><a class="header" href="#complejo">Complejo</a></h1>
<p>Morpho proporciona números complejos. La palabra clave <code>im</code> se utiliza para denotar la parte imaginaria de un número complejo:</p>
<pre><code class="language-javascript">var a=1+5im 
print a*a
</code></pre>
<p>Imprima valores en el círculo unitario en el plano complejo:</p>
<pre><code class="language-javascript">import constants 
for (phi in 0..Pi:Pi/5) print exp(im*phi)
</code></pre>
<p>Obtén las partes real e imaginaria de un número complejo:</p>
<pre><code class="language-javascript">print real(a) 
print imag(a) 
</code></pre>
<p>o alternativamente:</p>
<pre><code class="language-javascript">print a.real()
print a.imag() 
</code></pre>
<p>[showsuptopics]: # subtopics</p>
<h2 id="angle"><a class="header" href="#angle">Angle</a></h2>
<p>Devuelve el ángulo <code>phi</code> asociado a la representación polar de un número complejo <code>r*exp(im*phi)</code>:</p>
<pre><code class="language-javascript">print z.angle() 
</code></pre>
<h2 id="conj"><a class="header" href="#conj">Conj</a></h2>
<p>Devuelve el conjugado complejo de un número:</p>
<pre><code class="language-javascript">print z.conj() 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lista"><a class="header" href="#lista">Lista</a></h1>
<p>Las listas son objetos de colección que contienen una secuencia de valores, cada uno asociado a un índice entero.</p>
<p>Crea una lista como esta:</p>
<pre><code class="language-javascript">var list = [1, 2, 3]
</code></pre>
<p>Busque valores mediante notación de índice:</p>
<pre><code class="language-javascript">list[0]
</code></pre>
<p>La indexación también se puede realizar con segmentos: list[0..2] list[[0,1,3]]</p>
<p>Puede cambiar las entradas de la lista de la siguiente manera:</p>
<pre><code class="language-javascript">list[0] = "Hola"
</code></pre>
<p>Crea una lista vacía:</p>
<pre><code class="language-javascript">var list = []
</code></pre>
<p>Recorrer en bucle los elementos de una lista:</p>
<pre><code class="language-javascript">for (i in list) print i
</code></pre>
<h2 id="append"><a class="header" href="#append">Append</a></h2>
<p>Agrega un elemento al final de una lista:</p>
<pre><code class="language-javascript">var list = []
list.append("Foo")
</code></pre>
<h2 id="insert"><a class="header" href="#insert">Insert</a></h2>
<p>Inserta un elemento en una lista en un índice especificado:</p>
<pre><code class="language-javascript">var list = [1,2,3]
list.insert(1, "Foo")
print list // imprime [ 1, Foo, 2, 3 ]
</code></pre>
<h2 id="pop"><a class="header" href="#pop">Pop</a></h2>
<p>Elimine el último elemento de una lista, devolviendo el elemento eliminado:</p>
<pre><code class="language-javascript">print list.pop()
</code></pre>
<p>Si se proporciona un argumento entero, devuelve y elimina ese elemento:</p>
<pre><code class="language-javascript">var a = [1,2,3]
print a.pop(1) // imprime '2'
print a        // imprime [ 1, 3 ]
</code></pre>
<h2 id="sort"><a class="header" href="#sort">Sort</a></h2>
<p>Ordena el contenido de una lista en orden ascendente:</p>
<pre><code class="language-javascript">list.sort()
</code></pre>
<p>Tenga en cuenta que esto ordena la lista "in situ" (es decir, modifica el orden de la lista en la que se invoca) y, por lo tanto, devuelve <code>nil</code>.</p>
<p>Puede proporcionar su propia función para compararla en la lista</p>
<pre><code class="language-javascript">list.sort(fn (a, b) a-b)
</code></pre>
<p>Esta función debe devolver un valor negativo si <code>a&lt;b</code>, un valor positivo si <code>a&gt;b</code> y <code>0</code> si <code>a</code> y <code>b</code> son iguales.</p>
<h2 id="order"><a class="header" href="#order">Order</a></h2>
<p>Devuelve una lista de índices que, si se usaran en orden, ordenarían una lista. Por ejemplo</p>
<pre><code class="language-javascript">var list = [2,3,1]
print list.order() // esperado: [2,0,1]
</code></pre>
<p>produciría <code>[2,0,1]</code></p>
<h2 id="remove"><a class="header" href="#remove">Remove</a></h2>
<p>Elimine cualquier aparición de un valor de una lista:</p>
<pre><code class="language-javascript">var list = [1,2,3]
list.remove(1)
</code></pre>
<h2 id="ismember"><a class="header" href="#ismember">ismember</a></h2>
<p>Comprueba si un valor es miembro de una lista:</p>
<pre><code class="language-javascript">var list = [1,2,3]
print list.ismember(1) // esperado: true
</code></pre>
<h2 id="add"><a class="header" href="#add">Add</a></h2>
<p>Une dos listas:</p>
<pre><code class="language-javascript">var l1 = [1,2,3], l2 = [4, 5, 6]
print l1+l2 // esperado: [1,2,3,4,5,6]
</code></pre>
<h2 id="tuples"><a class="header" href="#tuples">Tuples</a></h2>
<p>Genere todas las 2 tuplas posibles a partir de una lista:</p>
<pre><code class="language-javascript">var t = [ 1, 2, 3].tuples(2)

</code></pre>
<p>produce <code>[ [ 1, 1 ], [ 1, 2 ], [ 1, 3 ] ... ] </code>.</p>
<pre><code class="language-javascript">
</code></pre>
<h2 id="sets"><a class="header" href="#sets">Sets</a></h2>
<p>Genere todos los conjuntos posibles de orden 2 a partir de una lista.</p>
<pre><code class="language-javascript">var t = [ 1, 2, 3 ].sets(2)

</code></pre>
<p>produce <code>[ [ 1, 2 ], [ 1, 3 ], [ 2, 3 ] ]</code>.</p>
<p>Tenga en cuenta que los conjuntos incluyen solo elementos distintos de la lista (no se repite ningún elemento) y el orden no es importante, por lo tanto, solo se devuelve uno de <code>[ 1, 2 ]</code> y <code>[ 2, 1 ]</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="matriz"><a class="header" href="#matriz">Matriz</a></h1>
<p>La clase Matrix proporciona compatibilidad con matrices. Una matriz se puede inicializar con un tamaño dado,</p>
<pre><code class="language-javascript">var a = Matrix(nrows,ncols)
</code></pre>
<p>donde todos los elementos se establecen inicialmente en cero. Alternativamente, se puede crear una matriz a partir de una matriz,</p>
<pre><code class="language-javascript">var a = Matrix([[1,2], [3,4]])
</code></pre>
<p>o una matriz dispersa,</p>
<pre><code class="language-javascript">var a = Sparse([[0,0,1],[1,1,1],[2,2,1]])
var b = Matrix(a)
</code></pre>
<p>Puedes crear un vector columna como este,</p>
<pre><code class="language-javascript">var v = Matrix([1,2])
</code></pre>
<p>Finalmente, puede crear una matriz ensamblando otras matrices como esta,</p>
<pre><code class="language-javascript">var a = Matrix([[0,1],[1,0]])
var b = Matrix([[a,0],[0,a]]) // produce una matriz de 4x4 
</code></pre>
<p>Una vez creada una matriz, se pueden utilizar todos los operadores aritméticos regulares con operandos de matriz, p. ej.</p>
<pre><code class="language-javascript">a+b
a*b
</code></pre>
<p>Puede recuperar entradas de matriz individuales con índices especificados:</p>
<pre><code class="language-javascript">print a[0,0]
</code></pre>
<p>o cree una submatriz usando sectores:</p>
<pre><code>print a[0..1,0..1]
</code></pre>
<p>El operador de división se utiliza para resolver un sistema lineal, p. ej.</p>
<pre><code class="language-javascript">var a = Matrix([[1,2],[3,4]])
var b = Matrix([1,2])
</code></pre>
<pre><code class="language-javascript">print b/a
</code></pre>
<p>da como resultado la solución del sistema a*x = b.</p>
<h2 id="assign"><a class="header" href="#assign">Assign</a></h2>
<p>Copia el contenido de la matriz B en la matriz A:</p>
<pre><code class="language-javascript">A.assign(B)
</code></pre>
<p>Las dos matrices deben tener las mismas dimensiones.</p>
<h2 id="dimensions-1"><a class="header" href="#dimensions-1">Dimensions</a></h2>
<p>Devuelve las dimensiones de una matriz:</p>
<pre><code class="language-javascript">var A = Matrix([1,2,3]) // Crear una matriz de columnas 
print A.dimensions()    // esperado: [ 3, 1 ]
</code></pre>
<h2 id="eigenvalues"><a class="header" href="#eigenvalues">Eigenvalues</a></h2>
<p>Devuelve una lista de valores propios de una matriz:</p>
<pre><code class="language-javascript">var A = Matrix([[0,1],[1,0]])
print A.eigenvalues() // esperado: [1,-1]
</code></pre>
<h2 id="eigensystem"><a class="header" href="#eigensystem">Eigensystem</a></h2>
<p>Devuelve los valores propios y los vectores propios de una matriz:</p>
<pre><code class="language-javascript">var A = Matrix([[0,1],[1,0]])
print A.eigensystem() 
</code></pre>
<p>Eigensystem devuelve una lista de dos elementos: El primer elemento es una lista de valores propios. El segundo elemento es una matriz que contiene los vectores propios correspondientes como sus columnas:</p>
<pre><code class="language-javascript">print A.eigensystem()[0]
// [ 1, -1 ]
print A.eigensystem()[1]
// [ 0.707107 -0.707107 ]
// [ 0.707107 0.707107 ]
</code></pre>
<h2 id="inner"><a class="header" href="#inner">Inner</a></h2>
<p>Calcula el producto interno de Frobenius entre dos matrices:</p>
<pre><code class="language-javascript">var prod = A.inner(B)
</code></pre>
<h2 id="outer"><a class="header" href="#outer">Outer</a></h2>
<p>Calcula el producto externo entre dos vectores:</p>
<pre><code class="language-javascript">var prod = A.outer(B)
</code></pre>
<p>Tenga en cuenta que <code>outer</code> siempre trata ambos vectores como vectores columna.</p>
<h2 id="inverse"><a class="header" href="#inverse">Inverse</a></h2>
<p>Devuelve el inverso de una matriz si es invertible. Genera un error <code>MtrxSnglr</code> si la matriz es singular. P. ej..</p>
<pre><code class="language-javascript">var m = Matrix([[1,2],[3,4]])
var mi = m.inverse()
</code></pre>
<p>produce la inversa de la matriz <code>m</code>, tal que mi*m es la matriz identidad.</p>
<h2 id="norm"><a class="header" href="#norm">Norm</a></h2>
<p>Devuelve una norma de matriz. De forma predeterminada, se devuelve la norma L2:</p>
<pre><code class="language-javascript">var a = Matrix([1,2,3,4])
print a.norm() // esperado: sqrt(30) = 5.47723...
</code></pre>
<p>Puede seleccionar una norma diferente proporcionando un argumento:</p>
<pre><code class="language-javascript">import constants
print a.norm(1) // experado: 10 (la norma L1 es la suma de valores absolutos) 
print a.norm(3) // experado: 4.64159 (Una elección inusual de norma)
print a.norm(Inf) // esperado: 4 (La norma Inf corresponde al valor absoluto máximo)
</code></pre>
<h2 id="reshape"><a class="header" href="#reshape">Reshape</a></h2>
<p>Cambia las dimensiones de una matriz de modo que el número total de elementos permanezca constante:</p>
<pre><code class="language-javascript">var A = Matrix([[1,3],[2,4]])
A.reshape(1,4) // 1 fila, 4 columnas
print A // esperado: [ 1, 2, 3, 4 ]
</code></pre>
<p>Tenga en cuenta que los elementos se almacenan en orden principal de columna.</p>
<h2 id="sum"><a class="header" href="#sum">Sum</a></h2>
<p>Devuelve la suma de todas las entradas de una matriz:</p>
<pre><code class="language-javascript">var sum = A.sum() 
</code></pre>
<h2 id="traspose"><a class="header" href="#traspose">Traspose</a></h2>
<p>Devuelve la transpuesta de una matriz:</p>
<pre><code class="language-javascript">var At = A.transpose()
</code></pre>
<h2 id="trace"><a class="header" href="#trace">Trace</a></h2>
<p>Calcula la traza (la suma de los elementos diagonales) de una matriz cuadrada:</p>
<pre><code class="language-javascript">var tr = A.trace()
</code></pre>
<h2 id="roll"><a class="header" href="#roll">Roll</a></h2>
<p>Rota los valores de una matriz alrededor de un eje determinado en un desplazamiento determinado:</p>
<pre><code class="language-javascript">var r = A.roll(shift, axis)
</code></pre>
<p>Los elementos que ruedan más allá de la última posición se vuelven a introducir en la primera.</p>
<h2 id="identitymatrix"><a class="header" href="#identitymatrix">IdentityMatrix</a></h2>
<p>Construye una matriz de identidad de un tamaño especificado:</p>
<pre><code class="language-javascript">var a = IdentityMatrix(size)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rango"><a class="header" href="#rango">Rango</a></h1>
<p>Los rangos representan una secuencia de valores numéricos. Hay dos formas de crearlos en función de si se incluye el valor superior o no:</p>
<pre><code class="language-javascript">var a = 1..5  // versión inclusiva, es decir, [1,2,3,4,5]
var b = 1...5 // versión exclusiva, es decir, [1,2,3,4]
</code></pre>
<p>De forma predeterminada, el incremento entre valores es 1, pero puede usar un valor diferente como este:</p>
<pre><code class="language-javascript">var a = 1..5:0.5 // 1 - 5 con un incremento de 0,5.
</code></pre>
<p>También puede crear objetos Range mediante la función constructora adecuada:</p>
<pre><code class="language-javascript">var a = Range(1,5,0.5)
</code></pre>
<p>Los rangos son particularmente útiles en la escritura de bucles:</p>
<pre><code class="language-javascript">for (i in 1..5) print i
</code></pre>
<p>Se pueden convertir fácilmente en una lista de valores:</p>
<pre><code class="language-javascript">var c = List(1..5)
</code></pre>
<p>Para encontrar el número de elementos en un rango, use el método <code>count</code></p>
<pre><code class="language-javascript">print (1..5).count()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sparse"><a class="header" href="#sparse">Sparse</a></h1>
<p>La clase Sparse proporciona compatibilidad con matrices dispersas. Una matriz dispersa vacía se puede inicializar con un tamaño dado,</p>
<pre><code class="language-javascript">var a = Sparse(nrows,ncols)
</code></pre>
<p>Alternativamente, se puede crear una matriz a partir de una matriz de tripletes,</p>
<pre><code class="language-javascript">var a = Sparse([[row, col, value] ...])
</code></pre>
<p>Por ejemplo,</p>
<pre><code class="language-javascript">var a = Sparse([[0,0,2], [1,1,-2]])
</code></pre>
<p>crea la matriz</p>
<pre><code class="language-javascript">[ 2 0 ]
[ 0 -2 ]
</code></pre>
<p>Una vez que se crea una matriz dispersa, puede usar todos los operadores aritméticos regulares con operandos de matriz, p. ej.</p>
<pre><code class="language-javascript">a+b
a*b
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cuerda-string"><a class="header" href="#cuerda-string">Cuerda (String)</a></h1>
<p>Las cadenas representan información textual. Están escritas en Morpho así:</p>
<pre><code class="language-javascript">var a = “hola mundo"
</code></pre>
<p>Se admiten caracteres Unicode, incluidos los emojis.</p>
<p>También puede crear cadenas utilizando la función constructora <code>String</code>, que toma cualquier número de parámetros:</p>
<pre><code class="language-javascript">var a = String("Hola", "Mundo")
</code></pre>
<p>Una característica muy útil, llamada <em>string interpolation</em>, permite que los resultados de cualquier expresión morpho se puedan interpolar en una cadena. Aquí, los valores de <code>i</code> y <code>func(i)</code> se insertarán en la cadena a medida que se crea:</p>
<pre><code class="language-javascript">print “${i}: ${func(i)}”
</code></pre>
<p>Para obtener un carácter individual, utilice la notación de índice</p>
<pre><code class="language-javascript">print “morpho”[0]
</code></pre>
<p>Puede recorrer cada carácter de la siguiente manera:</p>
<pre><code class="language-javascript">for (c in “morpho”) print c
</code></pre>
<p>Tenga en cuenta que las cadenas son inmutables y, por lo tanto</p>
<pre><code class="language-javascript">var a = “morpho”
a[0] = 4
</code></pre>
<p>genera un error.</p>
<h2 id="split"><a class="header" href="#split">split</a></h2>
<p>El método split divide una cadena en una lista de subcadenas. Se necesita un argumento, que es una cadena de caracteres que se usará para dividir la cadena:</p>
<pre><code class="language-javascript">print "1,2,3".split(",")
</code></pre>
<p>da</p>
<pre><code class="language-javascript">[ 1, 2, 3 ]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tupla"><a class="header" href="#tupla">Tupla</a></h1>
<p>Las tuplas son objetos de colección que contienen una secuencia de valores, cada uno asociado a un índice entero. A diferencia de las listas, no se pueden cambiar después de la creación.</p>
<p>Crea una tupla como esta:</p>
<pre><code class="language-javascript">var tuple = (1, 2, 3)
</code></pre>
<p>Busque valores mediante notación de índice:</p>
<pre><code class="language-javascript">tuple[0]
</code></pre>
<p>La indexación también se puede realizar con segmentos:</p>
<pre><code>tuple[0..2]
</code></pre>
<p>Bucle sobre los elementos de una tupla:</p>
<pre><code class="language-javascript">for (i in tuple) print i
</code></pre>
<h2 id="ismember-1"><a class="header" href="#ismember-1">ismember</a></h2>
<p>Comprueba si un valor es miembro de una tupla:</p>
<pre><code class="language-javascript">var tuple = (1,2,3)
print tuple.ismember(1) // esperado: true
</code></pre>
<h2 id="join"><a class="header" href="#join">Join</a></h2>
<p>Une dos listas:</p>
<pre><code class="language-javascript">var t1 = (1,2,3), t2 = (4, 5, 6)
print t1.join(t2) // esperado: (1,2,3,4,5,6)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="geometría-computacional"><a class="header" href="#geometría-computacional">Geometría Computacional</a></h2>
<p>En esta sección se proporciona la documentación de mallas, selecciones, campos y funcionalidades.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="campo"><a class="header" href="#campo">Campo</a></h1>
<p>Los campos se utilizan para almacenar información, incluidos números o matrices, asociados con los elementos de un objeto <code>Mesh</code>.</p>
<p>Puede crear un <code>Campo</code> aplicando una función a cada uno de los vértices,</p>
<pre><code class="language-javascript">var f = Field(mesh, fn (x, y, z) x+y+z)
</code></pre>
<p>o suministrando un único valor constante,</p>
<pre><code class="language-javascript">var f = Field(mesh, Matrix([1,0,0]))
</code></pre>
<p>A continuación, se pueden añadir y restar campos utilizando los operadores <code>+</code> y <code>-</code>.</p>
<p>Para acceder a los elementos de un <code>Campo</code>, utilice la notación de índice:</p>
<pre><code class="language-javascript">print f[grade, element, index]
</code></pre>
<p>dónde</p>
<ul>
<li><code>grade</code> es el grado que se va a seleccionar</li>
<li><code>element</code> es el ID del elemento</li>
<li><code>index</code> es el índice del elemento</li>
</ul>
<p>Como abreviatura, es posible omitir el grado y el índice; A continuación, se supone que ambos son <code>0</code>:</p>
<pre><code class="language-javascript">print f[2]
</code></pre>
<h2 id="malla"><a class="header" href="#malla">Malla</a></h2>
<p>Devuelve la malla asociada a un objeto Field:</p>
<pre><code class="language-javascript">var f.mesh() 
</code></pre>
<h2 id="grade"><a class="header" href="#grade">Grade</a></h2>
<p>Para crear campos que incluyan grados que no sean solo vértices, use la opción <code>grade</code> para <code>Field</code>. Esto puede ser solo un índice de calificación,</p>
<pre><code class="language-javascript">var f = Field(mesh, 0, grade=2)
</code></pre>
<p>que crea un campo vacío con <code>0</code> para cada una de las facetas de la malla <code>mall</code>.</p>
<p>Puede almacenar más de un elemento por elemento proporcionando una lista a la opción <code>grade</code> que indique cuántos elementos desea almacenar en cada grado. Por ejemplo,</p>
<pre><code class="language-javascript">var f = Field(mesh, 1.0, grade=[0,2,1])
</code></pre>
<p>almacena dos números en los elementos Line (Grado 1) y un número en los elementos Facetas (Grado 2). Cada número del campo se inicializa con el valor <code>1.0</code>.</p>
<h2 id="shape"><a class="header" href="#shape">Shape</a></h2>
<p>El método <code>shape</code> devuelve una lista que indica el número de elementos almacenados en cada elemento de un grado en particular. Tiene el mismo formato que la lista que se proporciona a la opción 'grade' del constructor 'Field'. Por ejemplo,</p>
<pre><code class="language-javascript">[1,0,2]
</code></pre>
<p>indicaría un elemento almacenado en cada vértice y dos elementos almacenados en cada faceta.</p>
<h2 id="op"><a class="header" href="#op">Op</a></h2>
<p>El método <code>op</code> aplica una función a cada elemento almacenado en un <code>Campo</code>, devolviendo el resultado como elementos de un nuevo objeto <code>Campo</code>. Por ejemplo,</p>
<pre><code class="language-javascript">f.op(fn (x) x.norm())
</code></pre>
<p>llama al método <code>norm</code> en cada elemento almacenado en <code>f</code>.</p>
<p>Se pueden proporcionar objetos <code>Field</code> adicionales como argumentos adicionales a <code>op</code>. Estos deben tener la misma forma (el mismo número de elementos almacenados en cada grado). La función suministrada a 'op' ahora se llamará con el elemento correspondiente de cada campo como argumentos. Por ejemplo,</p>
<pre><code class="language-javascript">f.op(fn (x,y) x.inner(y), g)
</code></pre>
<p>calcula un producto interno elemental entre los elementos de los campos <code>f</code> y <code>g</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="funcionales"><a class="header" href="#funcionales">Funcionales</a></h1>
<p>Una serie de <code>funcionals</code> están disponibles en Morpho. Cada uno de ellos representa una integral sobre algunos objetos <code>Mesh</code> y <code>Field</code> (en una <code>Selection</code> particular) y se utilizan para definir energías y restricciones en un <code>OptimizationProblem</code> proporcionado por el módulo <code>optimize</code>.</p>
<p>Muchas funciones están integradas. Las funcionalidades adicionales están disponibles importando el módulo <code>funcionals</code>:</p>
<pre><code class="language-javascript">import functionals
</code></pre>
<p>Los funcionales proporcionan una serie de métodos estándar:</p>
<ul>
<li><code>total</code>(mesh) - devuelve el valor de la integral con una malla, selección y campos proporcionados</li>
<li><code>integrand</code>(mesh) - devuelve la contribución a la integral de cada elemento</li>
<li><code>gradiente</code> (malla) - devuelve el gradiente del funcional con respecto a los movimientos de los vértices.</li>
<li><code>fieldgradient</code>(malla, campo): devuelve el gradiente del funcional con respecto a los componentes del campo</li>
</ul>
<p>Cada uno de ellos puede llamarse con una malla, un campo y una selección.</p>
<h2 id="lenght"><a class="header" href="#lenght">Lenght</a></h2>
<p>Un funcional <code>Lenght</code> calcula la longitud de un elemento de línea en una malla.</p>
<p>Evalúe la longitud de un bucle circular:</p>
<pre><code class="language-javascript">import constants
import meshtools
var m = LineMesh(fn (t) [cos(t), sin(t), 0], 0...2*Pi:Pi/20, closed=true)
var le = Length()
print le.total(m)
</code></pre>
<h2 id="areaenclosed"><a class="header" href="#areaenclosed">AreaEnclosed</a></h2>
<p>Un funcional <code>AreaEnclosed</code> calcula el área delimitada por un bucle de elementos de línea.</p>
<pre><code class="language-javascript">var la = AreaEnclosed()
</code></pre>
<h2 id="area"><a class="header" href="#area">Area</a></h2>
<p>Un funcional <code>Area</code> calcula el área de los elementos de área en una malla:</p>
<pre><code class="language-javascript">var la = Area()
print la.total(mesh)
</code></pre>
<h2 id="volumeenclosed"><a class="header" href="#volumeenclosed">VolumeEnclosed</a></h2>
<p>Un funcional <code>VolumeEnclosed</code> se usa para calcular el volumen encerrado por una superficie. Tenga en cuenta que esta estimación puede resultar inexacta para superficies muy deformadas.</p>
<pre><code class="language-javascript">var lv = VolumeEnclosed()
</code></pre>
<h2 id="volume"><a class="header" href="#volume">Volume</a></h2>
<p>Un funcional <code>Volume</code> calcula el volumen de los elementos de volumen.</p>
<pre><code class="language-javascript">var lv = Volume()
</code></pre>
<h2 id="scalarpotential"><a class="header" href="#scalarpotential">ScalarPotential</a></h2>
<p>La función <code>ScalarPotential</code> se aplica a elementos puntuales.</p>
<pre><code class="language-javascript">var ls = ScalarPotential(potential)
</code></pre>
<p>Debe proporcionar una función (que puede ser anónima) que devuelva el potencial. Opcionalmente, puede proporcionar una función que devuelva el gradiente también en la inicialización:</p>
<pre><code class="language-javascript">var ls = ScalarPotential(potential, gradient)
</code></pre>
<p>Esta función se utiliza a menudo para restringir la malla al conjunto de niveles de una función. Por ejemplo, para confinar un conjunto de puntos a una esfera:</p>
<pre><code class="language-javascript">import optimize
fn sphere(x,y,z) { return x^2+y^2+z^2-1 }
fn grad(x,y,z) { return Matrix([2*x, 2*y, 2*z]) }
var lsph = ScalarPotential(sphere, grad)
problem.addlocalconstraint(lsph)
</code></pre>
<p>Vea el ejemplo de Thomson para el uso de esta técnica.</p>
<h2 id="linearelasticity"><a class="header" href="#linearelasticity">LinearElasticity</a></h2>
<p>El funcional <code>LinearElasticity</code> mide la energía elástica lineal lejos de un estado de referencia.</p>
<p>Debe inicializar con una malla de referencia:</p>
<pre><code class="language-javascript">var le = LinearElasticity(mref)
</code></pre>
<p>Configure manualmente la relación de Poisson y el grado en el que operar:</p>
<pre><code class="language-javascript">le.poissonratio = 0.2
le.grade = 2
</code></pre>
<h2 id="equielement"><a class="header" href="#equielement">EquiElement</a></h2>
<p>El funcional <code>EquiElement</code> mide la discrepancia entre el tamaño de los elementos adyacentes a cada vértice. Se puede utilizar para igualar elementos con fines de regularización.</p>
<h2 id="linecurvaturesq"><a class="header" href="#linecurvaturesq">LineCurvatureSq</a></h2>
<p>El funcional <code>LineCurvatureSq</code> mide la curvatura integrada al cuadrado de una secuencia de elementos de línea.</p>
<h2 id="linetorsionsq"><a class="header" href="#linetorsionsq">LineTorsionSq</a></h2>
<p>El funcional <code>LineTorsionSq</code> mide la torsión integrada al cuadrado de una secuencia de elementos de línea.</p>
<h2 id="meancurvaturesq"><a class="header" href="#meancurvaturesq">MeanCurvatureSq</a></h2>
<p>El funcional <code>MeanCurvatureSq</code> calcula la curvatura media integrada sobre una superficie.</p>
<h2 id="gausscurvature"><a class="header" href="#gausscurvature">GaussCurvature</a></h2>
<p>La <code>GaussCurvature</code> calcula la curvatura gaussiana integrada sobre una superficie.</p>
<p>Tenga en cuenta que para las superficies con un contorno, el integrando es correcto solo para los puntos interiores. Para calcular la curvatura geodésica del límite en ese caso, puede establecer la bandera opcional <code>geodesic</code> en <code>true</code> y calcular el total en la selección del límite. A continuación se muestra un ejemplo de una malla de disco 2D.</p>
<pre><code class="language-javascript">var mesh = Mesh(“disk.mesh”)
mesh.addgrade(1)
</code></pre>
<pre><code class="language-javascript">var whole = Selection(mesh, fn(x,y,z) true)
var bnd = Selection(mesh, boundary=true)
var interior = whole.difference(bnd)
</code></pre>
<pre><code class="language-javascript">var gauss = GaussCurvature()
print gauss.total(mesh, selection=interior) // esperado: 0
gauss.geodesic = true
print gauss.total(mesh, selection=bnd) // esperado: 2*Pi
</code></pre>
<h2 id="gradsq"><a class="header" href="#gradsq">GradSq</a></h2>
<p>El funcional <code>GradSq</code> mide la integral del gradiente al cuadrado de un campo. El campo puede ser una función escalar, vectorial o matricial.</p>
<p>Inicialice con el campo obligatorio:</p>
<pre><code class="language-javascript">var le=GradSq(phi)
</code></pre>
<h2 id="nematic"><a class="header" href="#nematic">Nematic</a></h2>
<p>El funcional <code>Nematic</code> mide la energía elástica de un cristal líquido nemático.</p>
<pre><code class="language-javascript">var lf=Nematic(nn)
</code></pre>
<p>Hay una serie de parámetros opcionales que se pueden utilizar para establecer las constantes de separación, torsión y plegado:</p>
<pre><code class="language-javascript">var lf=Nematic(nn, ksplay=1, ktwist=0.5, kbend=1.5, pitch=0.1)
</code></pre>
<p>Estos se almacenan como propiedades del objeto y se pueden recuperar de la siguiente manera:</p>
<pre><code class="language-javascript">print lf.ksplay
</code></pre>
<h2 id="nematicelectric"><a class="header" href="#nematicelectric">NematicElectric</a></h2>
<p>El funcional <code>NematicElectric</code> mide la integral de un término de acoplamiento nemático y eléctrico integral((n.E)^2) donde el campo eléctrico E puede calcularse a partir de un potencial escalar o suministrarse como un vector.</p>
<p>Inicialice con un campo de director <code>nn</code> y un potencial escalar <code>phi</code>:</p>
<pre><code class="language-javascript">var lne = NematicElectric(nn, phi)
</code></pre>
<h2 id="normsq"><a class="header" href="#normsq">NormSq</a></h2>
<p>El funcional <code>NormSq</code> mide la norma L2 al cuadrado de un campo.</p>
<h2 id="lineintegral"><a class="header" href="#lineintegral">LineIntegral</a></h2>
<p>El funcional <code>LineIntegral</code> calcula la integral de línea de una función. Se proporciona una función integrando que toma una matriz de posición como argumento.</p>
<p>Para calcular ‘<code>ntegral(x^2+y^2)</code> sobre un elemento de línea:</p>
<pre><code class="language-javascript">var la=LineIntegral(fn (x) x[0]^2+x[1]^2)
</code></pre>
<p>La función <code>tangent()</code> devuelve un vector unitario tangente al elemento actual:</p>
<pre><code class="language-javascript">var la=LineIntegral(fn (x) x.inner(tangent()))
</code></pre>
<p>También puede integrar funciones que impliquen campos:</p>
<pre><code class="language-javascript">var la=LineIntegral(fn (x, n) n.inner(tangent()), n)
</code></pre>
<p>donde <code>n</code> es un campo vectorial. El valor interpolado local de este campo se pasa a la función integrando. Se puede utilizar más de un campo; se pasan como argumentos a la función integrando en el orden en que se proporcionan a <code>LineIntegral</code>.</p>
<p>El gradiente de un campo está disponible dentro de una función integrando usando la función <code>gradient()</code>.</p>
<h2 id="areaintegral"><a class="header" href="#areaintegral">AreaIntegral</a></h2>
<p>El funcional <code>AreaIntegral</code> calcula la integral de área de una función. Se proporciona una función integrando que toma una matriz de posición como argumento.</p>
<p>Para calcular la integral(x*y) sobre un elemento de área:</p>
<pre><code class="language-javascript">var la=AreaIntegral(fn (x) x[0]*x[1])
</code></pre>
<p>También puede integrar funciones que impliquen campos:</p>
<pre><code class="language-javascript">var la=AreaIntegral(fn (x, phi) phi^2, phi)
</code></pre>
<p>Se puede acceder a la faceta normal local en un integrando usando la función <code>normal()</code>:</p>
<pre><code class="language-javascript">var la=AreaIntegral(fn (x) x.inner(normal())^2)
</code></pre>
<p>Se puede utilizar más de un campo; se pasan como argumentos a la función integrando en el orden en que se proporcionan a <code>AreaIntegral</code>.</p>
<p>El gradiente de un campo está disponible dentro de una función integrando usando la función <code>gradient()</code>.</p>
<h2 id="volumeintegral"><a class="header" href="#volumeintegral">VolumeIntegral</a></h2>
<p>El funcional <code>VolumeIntegral</code> calcula la integral de volumen de una función. Se proporciona una función integrando que toma una matriz de posición como argumento.</p>
<p>Para calcular integral(x_y_z) sobre un elemento de volumen:</p>
<pre><code class="language-javascript">var la=VolumeIntegral(fn (x) x[0]*x[1]*x[2])
</code></pre>
<p>También puede integrar funciones que impliquen campos:</p>
<pre><code class="language-javascript">var la=VolumeIntegral(fn (x, phi) phi^2, phi)
</code></pre>
<p>Se puede utilizar más de un campo; se pasan como argumentos a la función integrando en el orden en que se proporcionan a <code>VolumeIntegral</code>.</p>
<p>El gradiente de un campo está disponible dentro de una función integrando usando la función <code>gradient()</code>.</p>
<h2 id="hydrogel"><a class="header" href="#hydrogel">Hydrogel</a></h2>
<p>El funcional <code>Hydrogel</code> calcula la energía de Flory-Rehner sobre un elemento:</p>
<pre><code class="language-javascript">(a*phi*log(phi) + b*(1-phi)+log(1-phi) + c*phi*(1-phi))*V + 
d*(log(phiref/phi)/3 - (phiref/phi)^(2/3) + 1)*V0
</code></pre>
<p>Los tres primeros términos provienen de la energía de mezcla de Flory-Huggins, mientras que el cuarto término proporcional a d proviene de la energía elástica de Flory-Rehner.</p>
<p>El valor de phi se calcula a partir de una malla de referencia que se proporciona al inicializar el Funcional:</p>
<pre><code class="language-javascript">var lfh = Hydrogel(mref)
</code></pre>
<p>Aquí, a, b, c, d y phiref son parámetros que puede proporcionar (son <code>nil</code> por defecto), V es el volumen actual y V0 es el volumen de referencia de un elemento determinado. También debe proporcionar el valor inicial de phi, etiquetado como phi0, que se supone que es el mismo para todos los elementos.  Configure manualmente los coeficientes y la pendiente en los que operar:</p>
<pre><code class="language-javascript">lfh.a = 1; lfh.b = 1; lfh.c = 1; lfh.d = 1;
lfh.grade = 2, lfh.phi0 = 0.5, lfh.phiref = 0.1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="malla-1"><a class="header" href="#malla-1">Malla</a></h1>
<p>La clase <code>Mesh</code> proporciona soporte para mallas. Las mallas pueden constar de diferentes tipos de elementos, incluidos vértices, elementos de línea, facetas o elementos de área, tetraedros o elementos de volumen.</p>
<p>Para crear una malla, puede importarla desde un archivo:</p>
<pre><code class="language-javascript">var m = Mesh(“sphere.mesh”)
</code></pre>
<p>o utilice una de las funciones disponibles en los paquetes <code>meshtools</code> o <code>implicitmesh</code>.</p>
<p>Se hace referencia a cada tipo de elemento como perteneciente a un <code>grade</code> diferente. Los elementos puntuales (vértices) son <em>grade 0</em>; Los elementos en forma de línea (bordes) son <em>grade 1</em>; Los elementos similares a áreas (facetas, triángulos) son <em>grade 2</em>, etc.</p>
<p>El paquete <code>plot</code> incluye funciones para visualizar mallas.</p>
<h2 id="save"><a class="header" href="#save">Save</a></h2>
<p>Guarda una malla como un archivo .mesh.</p>
<pre><code class="language-javascript">m.save(“new.mesh”)
</code></pre>
<h2 id="vertexposition"><a class="header" href="#vertexposition">Vertexposition</a></h2>
<p>Recupera la posición de un vértice dado un id:</p>
<pre><code class="language-javascript">print m.vertexposition(id)
</code></pre>
<h2 id="setvertexposition"><a class="header" href="#setvertexposition">Setvertexposition</a></h2>
<p>Establece la posición de un vértice dado un id y un vector de posición:</p>
<pre><code class="language-javascript">print m.setvertexposition(1, Matrix([0,0,0]))
</code></pre>
<h2 id="addgrade"><a class="header" href="#addgrade">Addgrade</a></h2>
<p>Añade una nueva calificación a una malla. Esto se usa comúnmente cuando, por ejemplo, un archivo de malla incluye facetas pero no bordes. Para agregar los bordes que faltan:</p>
<pre><code class="language-javascript">m.addgrade(1)
</code></pre>
<h2 id="addsymmetry"><a class="header" href="#addsymmetry">Addsymmetry</a></h2>
<p>Añade una simetría a una malla. Experimental en la versión 0.5.</p>
<h2 id="maxgrade"><a class="header" href="#maxgrade">Maxgrade</a></h2>
<p>Devuelve el elemento de grado más alto presente:</p>
<pre><code class="language-javascript">print m.maxgrade()
</code></pre>
<h2 id="count"><a class="header" href="#count">Count</a></h2>
<p>Cuenta el número de elementos. Si no se proporciona ningún argumento, devuelve el número de vértices. De lo contrario, devuelve el número de elementos presentes de una calificación determinada:</p>
<pre><code class="language-javascript">print m.count(2) // Devuelve el número de elementos similares a áreas. 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="selección"><a class="header" href="#selección">Selección</a></h1>
<p>La clase Selection permite seleccionar componentes de una malla para su uso posterior. Puede proporcionar una función que se aplique a las coordenadas de cada vértice de la malla o seleccionar componentes como límites.</p>
<p>Crea una selección vacía:</p>
<pre><code class="language-javascript">var s = Selection(mesh)
</code></pre>
<p>Seleccione los vértices por encima del plano z=0 usando una función anónima:</p>
<pre><code class="language-javascript">var s = Selection(mesh, fn (x,y,z) z&gt;0)
</code></pre>
<p>Seleccione la frontera de una malla:</p>
<pre><code class="language-javascript">var s = Selection(mesh, boundary=true)
</code></pre>
<p>Los objetos de selección se pueden componer mediante operaciones de conjunto:</p>
<pre><code class="language-javascript">var s = s1.union(s2)
</code></pre>
<p>o</p>
<pre><code class="language-javascript">var s = s1.intersection(s2)
</code></pre>
<p>Para agregar calificaciones adicionales, use el método addgrade. Por ejemplo, para agregar áreas:</p>
<pre><code class="language-javascript">s.addgrade(2)
</code></pre>
<p>[showsubtopics]: # subtemas</p>
<h2 id="addgrade-1"><a class="header" href="#addgrade-1">addgrade</a></h2>
<p>Añade elementos de la calificación especificada a una selección. Por ejemplo, para añadir aristas a una selección existente, utilice</p>
<pre><code class="language-javascript">s.addgrade(1)
</code></pre>
<p>De forma predeterminada, esto solo agrega un elemento si <em>todos</em> los vértices del elemento están seleccionados actualmente. A veces, es útil poder agregar elementos para los que solo se seleccionan algunos vértices. El argumento opcional <code>partials</code> le permite hacer esto:</p>
<pre><code class="language-javascript">s.addgrade(1, partials=true)
</code></pre>
<p>Tenga en cuenta que este método modifica la selección existente y no genera un nuevo objeto Selection.</p>
<h2 id="removegrade"><a class="header" href="#removegrade">removegrade</a></h2>
<p>Elimina elementos de la calificación especificada de una selección. Por ejemplo, para eliminar aristas de una selección existente, utilice</p>
<pre><code class="language-javascript">s.removegrade(1)
</code></pre>
<p>Tenga en cuenta que este método modifica la selección existente y no genera un nuevo objeto Selection.</p>
<h2 id="idlistforgrade"><a class="header" href="#idlistforgrade">idlistforgrade</a></h2>
<p>Devuelve una lista de identificadores de elementos incluidos en la selección.</p>
<p>Para saber qué bordes están seleccionados:</p>
<pre><code class="language-javascript">var edges = s.idlistforgrade(1)
</code></pre>
<h2 id="isselected"><a class="header" href="#isselected">isselected</a></h2>
<p>Comprueba si se ha seleccionado un identificador de elemento, devolviendo <code>true</code> o <code>false</code> en consecuencia.</p>
<p>Para comprobar si se ha seleccionado el borde número 5:</p>
<pre><code class="language-javascript">var f = s.isselected(1, 5))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="es"><a class="header" href="#es">E/S</a></h2>
<p>En esta sección se proporciona la documentación del objeto <code>File</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="archivo"><a class="header" href="#archivo">Archivo</a></h1>
<p>La clase <code>File</code> proporciona la capacidad de leer y escribir en archivos, o de obtener el contenido de un archivo en formatos convenientes.</p>
<p>Para abrir un archivo, cree un objeto File con el nombre de archivo como argumento</p>
<pre><code class="language-javascript">var f = File("myfile.txt")
</code></pre>
<p>que abre <code>’’myfile.txt’’</code> para <em>leer</em>. Para abrir un archivo para escribirlo o anexarlo, debe proporcionar un selector de modo</p>
<pre><code class="language-javascript">var g = File("myfile.txt", “write”)
</code></pre>
<p>o</p>
<pre><code class="language-javascript">var g = File("myfile.txt", “append”)
</code></pre>
<p>Una vez abierto el archivo, puede leer o escribir llamando a los métodos adecuados:</p>
<pre><code class="language-javascript">f.lines()            // lee el contenido del archivo en una matriz de líneas.
f.readline()         // lee una sola línea
f.readchar()         // lee un solo carácter.
f.write(string)      // escribe los argumentos en el archivo.
</code></pre>
<p>Una vez que haya terminado con el archivo, ciérrelo con</p>
<pre><code class="language-javascript">f.close()
</code></pre>
<h2 id="lines"><a class="header" href="#lines">lines</a></h2>
<p>Devuelve el contenido de un archivo como una matriz de cadenas; Cada elemento corresponde a una sola línea.</p>
<p>Lea el contenido de un archivo e imprima línea por línea:</p>
<pre><code class="language-javascript">var f = File("input.txt")
var s = f.lines()
for (i in s) print i
f.close()
</code></pre>
<h2 id="readline"><a class="header" href="#readline">readline</a></h2>
<p>Lee una sola línea de un archivo; Devuelve el resultado como una cuerda.</p>
<p>Lea el contenido de un archivo e imprima cada línea:</p>
<pre><code class="language-javascript">var f = File("input.txt")
while (!f.eof()) {
  print f.readline()
}
f.close()
</code></pre>
<h2 id="readchar"><a class="header" href="#readchar">readchar</a></h2>
<p>Lee un solo carácter de un archivo; Devuelve el resultado como una cadena.</p>
<h2 id="write"><a class="header" href="#write">write</a></h2>
<p>Escribe en un archivo.</p>
<p>Escriba el contenido de una lista en un archivo:</p>
<pre><code class="language-javascript">var f = File("output.txt", "w")
for (k, i in list) f.write("${i}: ${k}")
f.close()
</code></pre>
<h2 id="close"><a class="header" href="#close">close</a></h2>
<p>Cierra un archivo abierto.</p>
<h2 id="eof"><a class="header" href="#eof">eof</a></h2>
<p>Devuelve true si está al final del archivo; false de lo contrario</p>
<h1 id="folder"><a class="header" href="#folder">Folder</a></h1>
<p>La clase <code>Folder</code> le permite averiguar si una ruta de archivo se refiere a una carpeta y encontrar el contenido de esa carpeta.</p>
<p>Averigüe si una ruta de acceso hace referencia a una carpeta:</p>
<pre><code class="language-javascript">print Folder.isfolder(“path/folder”)

</code></pre>
<p>Obtener una lista del contenido de una carpeta:</p>
<pre><code class="language-javascript">print Folder.contents(“path/folder”)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="json"><a class="header" href="#json">JSON</a></h1>
<p>La clase <code>JSON</code> proporciona funcionalidad de importación y exportación para el formato de archivo de intercambio JSON (JavaScript Object Notation) tal como se define en IETF RFC 7159.</p>
<p>Para analizar una cadena que contiene JSON, use el método <code>parse</code>:</p>
<pre><code class="language-javascript">var a = JSON.parse("[1,2,3,4]")
print a // esperado: [ 1, 2, 3, 4 ]
</code></pre>
<p>Los elementos de la cadena JSON se convierten en valores morpho equivalentes.</p>
<p>Para convertir tipos de datos básicos a JSON, use el método <code>tostring</code>:</p>
<pre><code class="language-javascript">var b = JSON.tostring([1,2,3])
</code></pre>
<p>El exportador admite <code>nil</code>, valores booleanos <code>true</code> y <code>false</code>, números, <code>String</code>s, así como objetos <code>List</code> y <code>Dictionary</code> que pueden contener cualquiera de los tipos admitidos.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="módulos-1"><a class="header" href="#módulos-1">Módulos</a></h2>
<p>Esta sección proporciona la documentación de los diversos módulos estándar enviados con Morpho.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="color"><a class="header" href="#color">Color</a></h1>
<p>El módulo <code>color</code> proporciona soporte para trabajar con color. Los colores se representan en morpho mediante objetos <code>Color</code>. El módulo predefine algunos colores, incluidos <code>Red</code>, <code>Green</code>, <code>Blue</code>, <code>Black</code>, <code>White</code>.</p>
<p>Para usar el módulo, use import como de costumbre:</p>
<pre><code class="language-javascript">import color
</code></pre>
<p>Cree un objeto Color a partir de un par RGB:</p>
<pre><code class="language-javascript">var col = Color(0.5,0.5,0.5) // Un rayo 50% gris
</code></pre>
<p>El módulo <code>color</code> también proporciona <code>ColorMap</code>s, que dan una secuencia de colores en función de un parámetro; estos son útiles para trazar los valores de un <code>Campo</code>, por ejemplo.</p>
<h2 id="rgb"><a class="header" href="#rgb">RGB</a></h2>
<p>Obtiene los componentes rgb de un objeto <code>Color</code> o <code>ColorMap</code> como una lista. Toma un solo argumento en el rango de 0 a 1, aunque el resultado solo dependerá de este argumento si el objeto es un <code>ColorMap</code>.</p>
<pre><code class="language-javascript">var col = Color(0.1,0.5,0.7)
print col.rgb(0)
</code></pre>
<h2 id="red"><a class="header" href="#red">Red</a></h2>
<p>Objeto <code>Color</code> incorporado para su uso con los módulos 'graphics' y <code>plot</code>.</p>
<h2 id="green"><a class="header" href="#green">Green</a></h2>
<p>Objeto <code>Color</code> incorporado para su uso con los módulos 'graphics' y <code>plot</code>.</p>
<h2 id="blue"><a class="header" href="#blue">Blue</a></h2>
<p>Objeto <code>Color</code> incorporado para su uso con los módulos 'graphics' y <code>plot</code>.</p>
<h2 id="white"><a class="header" href="#white">White</a></h2>
<p>Objeto <code>Color</code> incorporado para su uso con los módulos 'graphics' y <code>plot</code>.</p>
<h2 id="black"><a class="header" href="#black">Black</a></h2>
<p>Objeto <code>Color</code> incorporado para su uso con los módulos 'graphics' y <code>plot</code>.</p>
<h2 id="cyan"><a class="header" href="#cyan">Cyan</a></h2>
<p>Objeto <code>Color</code> incorporado para su uso con los módulos 'graphics' y <code>plot</code>.</p>
<h2 id="magenta"><a class="header" href="#magenta">Magenta</a></h2>
<p>Objeto <code>Color</code> incorporado para su uso con los módulos 'graphics' y <code>plot</code>.</p>
<h2 id="yellow"><a class="header" href="#yellow">Yellow</a></h2>
<p>Objeto <code>Color</code> incorporado para su uso con los módulos 'graphics' y <code>plot</code>.</p>
<h2 id="brown"><a class="header" href="#brown">Brown</a></h2>
<p>Objeto <code>Color</code> incorporado para su uso con los módulos 'graphics' y <code>plot</code>.</p>
<h2 id="orange"><a class="header" href="#orange">Orange</a></h2>
<p>Objeto <code>Color</code> incorporado para su uso con los módulos 'graphics' y <code>plot</code>.</p>
<h2 id="pink"><a class="header" href="#pink">Pink</a></h2>
<p>Objeto <code>Color</code> incorporado para su uso con los módulos 'graphics' y <code>plot</code>.</p>
<h2 id="purple"><a class="header" href="#purple">Purple</a></h2>
<p>Objeto <code>Color</code> incorporado para su uso con los módulos 'graphics' y <code>plot</code>.</p>
<h2 id="colormap-mapa-de-colores"><a class="header" href="#colormap-mapa-de-colores">Colormap (Mapa de colores)</a></h2>
<p>El módulo <code>color</code> proporciona <code>ColorMap</code>s, que son subclases de <code>Color</code> que asignan un solo parámetro en el rango de 0 a 1 en un continuo de colores. <code>Color</code> y <code>Colormap</code> tienen la misma interfaz.</p>
<p>Obtenga los componentes rojos, verdes o azules de un mapa de colores o colores:</p>
<pre><code class="language-javascript">var col = HueMap()
print col.red(0.5) // el argumento puede estar en el rango de 0 a 1
</code></pre>
<p>Obtenga los tres componentes en una lista:</p>
<pre><code class="language-javascript">col.rgb(0)
</code></pre>
<p>Crea una escala de grises:</p>
<pre><code class="language-javascript">var c = Gray(0.2) // 20% gris
</code></pre>
<p>Mapas de colores disponibles: <code>GradientMap</code>,  <code>GrayMap</code>, <code>HueMap</code>, <code>ViridisMap</code>, <code>MagmaMap</code>, <code>InfernoMap</code> y <code>PlasmaMap</code>.</p>
<h2 id="gradientmap"><a class="header" href="#gradientmap">GradientMap</a></h2>
<p><code>GradientMap</code> es un <code>Colormap</code> que muestra una secuencia blanco-verde-púrpura.</p>
<h2 id="graymap-mapa-de-grises"><a class="header" href="#graymap-mapa-de-grises">GrayMap (Mapa de grises)</a></h2>
<p><code>GrayMap</code> es un <code>Colormap</code> que muestra escalas de grises.</p>
<h2 id="huemap-mapa-de-tonos"><a class="header" href="#huemap-mapa-de-tonos">HueMap (Mapa de tonos)</a></h2>
<p><code>HueMap</code> es un <code>Colormap</code> que muestra colores vivos. Es periódico en el intervalo de 0 a 1.</p>
<h2 id="viridismap"><a class="header" href="#viridismap">ViridisMap</a></h2>
<p><code>ViridisMap</code> es un <code>Colormap</code> que muestra una secuencia púrpura-verde-amarilla. Es perceptualmente uniforme y está destinado a mejorar la accesibilidad de las visualizaciones para los espectadores con deficiencia en la visión del color.</p>
<h2 id="magmamap"><a class="header" href="#magmamap">MagmaMap</a></h2>
<p><code>MagmaMap</code> es un <code>Colormap</code> que muestra una secuencia negro-rojo-amarillo. Es perceptualmente uniforme y está destinado a mejorar la accesibilidad de las visualizaciones para los espectadores con deficiencia en la visión del color.</p>
<h2 id="infernomap"><a class="header" href="#infernomap">InfernoMap</a></h2>
<p><code>InfernoMap</code> es un <code>Colormap</code> que muestra una secuencia negro-rojo-amarillo. Es perceptualmente uniforme y está destinado a mejorar la accesibilidad de las visualizaciones para los espectadores con deficiencia en la visión del color.</p>
<h2 id="plasmamap"><a class="header" href="#plasmamap">PlasmaMap</a></h2>
<p><code>InfernoMap</code> es un <code>Colormap</code> que muestra una secuencia azul-rojo-amarillo. Es perceptualmente uniforme y está destinado a mejorar la accesibilidad de las visualizaciones para los espectadores con deficiencia en la visión del color.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constantes"><a class="header" href="#constantes">Constantes</a></h1>
<p>El módulo de constantes contiene una serie de constantes matemáticas útiles. Impórtalo como cualquier otro módulo:</p>
<pre><code class="language-javascript">import constants
</code></pre>
<p>Constantes disponibles:</p>
<ul>
<li><code>E</code> la base de los logaritmos naturales.</li>
<li>Relación <code>Pi</code> entre el perímetro de un círculo y su diámetro.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="delaunay-1"><a class="header" href="#delaunay-1">Delaunay</a></h1>
<p>El módulo <code>delaunay</code> crea triangulaciones de Delaunay a partir de nubes de puntos. Es dimensionalmente independiente, por lo que genera tetraedros en 3D y simplificaciones de orden superior más allá.</p>
<p>Para usar el módulo, primero impórtelo:</p>
<pre><code class="language-javascript">import delaunay
</code></pre>
<p>Para crear una triangulación de Delaunary a partir de una lista de puntos:</p>
<pre><code class="language-javascript">var pts = []
for (i in 0...100) pts.append(Matrix([random(), random()]))
var del=Delaunay(pts)
print del.triangulate()
</code></pre>
<p>El módulo también proporciona <code>DelaunayMesh</code> para crear directamente mallas a partir de triangulaciones de Delaunay.</p>
<h2 id="triangulate"><a class="header" href="#triangulate">Triangulate</a></h2>
<p>El método de <code>triangulación</code> realiza la triangulación de Delaunay. Para usarlo, primero construya un objeto <code>Delaunay</code> con la nube de puntos de interés:</p>
<pre><code class="language-javascript">var del=Delaunay(pts)
</code></pre>
<p>A continuación, llame a <code>triangular</code>:</p>
<pre><code class="language-javascript">var tri = del.triangulate()
</code></pre>
<p>Esto devuelve una lista de triángulos <code>[ [i, j, k], ... ] </code>.</p>
<h2 id="circumsphere-circunsfera"><a class="header" href="#circumsphere-circunsfera">Circumsphere (Circunsfera)</a></h2>
<p>La clase <code>Circumsphere</code> calcula la circunsfera de un conjunto de puntos, es decir, una esfera tal que todos los puntos están en la superficie de la esfera. Es utilizado internamente por el módulo <code>delaunay</code>.</p>
<p>Cree una <code>Circumsphere</code> a partir de una lista de puntos y un triángulo especificado por índices en esa lista:</p>
<pre><code class="language-javascript">var sph = Circumsphere(pts, [i,j,k]) 
</code></pre>
<p>Pruebe si un punto arbitrario está dentro de la <code>Circumsphere</code> o no:</p>
<pre><code class="language-javascript">print sph.pointinsphere(pt)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gráficos"><a class="header" href="#gráficos">Gráficos</a></h1>
<p>El módulo <code>graphics</code> proporciona una serie de clases para proporcionar capacidades de visualización simples. Para utilizarlo, primero hay que importar el módulo:</p>
<pre><code class="language-javascript">import graphics
</code></pre>
<p>La clase <code>Graphics</code> actúa como un contenedor abstracto de información gráfica; para iniciar realmente la pantalla, consulte la clase <code>Show</code>. Puedes crear una escena vacía como esta,</p>
<pre><code class="language-javascript">var g = Graphics()
</code></pre>
<p>Se pueden agregar elementos adicionales usando el método <code>display</code>.</p>
<pre><code class="language-javascript">g.display(element)
</code></pre>
<p>Morpho proporciona las siguientes clases fundamentales de elementos gráficos:</p>
<pre><code class="language-javascript">TriangleComplex
</code></pre>
<p>También puede usar funciones como <code>Arrow</code>, <code>Tube</code> y <code>Cylinder</code> para crear estos elementos convenientemente.</p>
<p>Para combinar objetos gráficos, utilice el operador add:</p>
<pre><code class="language-javascript">var g1 = Graphics(), g2 = Graphics()
// ...
Show(g1+g2)
</code></pre>
<h2 id="show"><a class="header" href="#show">Show</a></h2>
<p><code>Show</code> se utiliza para lanzar una pantalla gráfica interactiva utilizando la aplicación externa <code>morphoview</code>. <code>Show</code> toma un objeto <code>Graphics</code> como argumento:</p>
<pre><code class="language-javascript">var g = Graphics()
Show(g)
</code></pre>
<h2 id="trianglecomplex"><a class="header" href="#trianglecomplex">TriangleComplex</a></h2>
<p>Un <code>TriangleComplex</code> es un elemento gráfico que se puede utilizar como parte de una representación gráfica. Consta de una lista de vértices y una matriz de conectividad que selecciona qué vértices se utilizan en cada triángulo.</p>
<p>Para crear uno, llame al constructor con los siguientes argumentos:</p>
<pre><code class="language-javascript">TriangleComplex(position, normals, colors, connectivity)
</code></pre>
<ul>
<li><code>position</code> es una 'matriz' que contiene las posiciones de los vértices como <em>columnas</em>.</li>
<li><code>normals</code> es una 'matriz' con una normal para cada vértice.</li>
<li><code>colors</code> es el color del objeto.</li>
<li><code>conectivity</code> es una matriz <code>Sparse</code> donde cada columna representa un triángulo y las filas corresponden a vértices.</li>
</ul>
<p>También puede proporcionar argumentos opcionales:</p>
<ul>
<li><code>transmit</code> establece la transparencia del objeto. Este parámetro solo es utilizado por el módulo povray a partir de ahora. El valor predeterminado es 0.</li>
<li><code>filter</code> establece la transparencia del objeto mediante un efecto de filtro. Este parámetro solo es utilizado por el módulo povray a partir de ahora. El valor predeterminado es 0. Para conocer la diferencia entre <code>transmit</code> y <code>filter</code>, consulte la <a href="http://xahlee.info/3d/povray-glassy.html">documentación de POVRay</a>.</li>
</ul>
<p>Agregue a un objeto <code>Gráficos</code> usando el método <code>display</code>.</p>
<h2 id="arrow"><a class="header" href="#arrow">Arrow</a></h2>
<p>La función <code>Arrow</code> crea una flecha. Se necesitan dos argumentos:</p>
<pre><code class="language-javascript">arrow(start, end)
</code></pre>
<ul>
<li><code>start</code> y <code>end</code> son los dos vértices. La flecha apunta a <code>inicio</code> &gt; <code>fin</code>.</li>
</ul>
<p>También puede proporcionar argumentos opcionales:</p>
<ul>
<li><code>aspectratio</code> controla el ancho de la flecha en relación con su longitud</li>
<li><code>n</code> es un número entero que controla la calidad de la pantalla. Una <code>n</code> más alta conduce a una flecha más redonda.</li>
<li><code>color</code> es el color de la flecha. Puede ser una lista de valores RGB o un objeto <code>Color</code></li>
<li><code>transmit</code> establece la transparencia de la flecha. Este parámetro solo es utilizado por el módulo povray a partir de ahora. El valor predeterminado es 0.</li>
<li><code>filter</code> establece la transparencia de la flecha usando un efecto de filtro. Este parámetro solo es utilizado por el módulo povray a partir de ahora. El valor predeterminado es 0. Para conocer la diferencia entre 'transmitir' y 'filtrar', consulte la <a href="http://xahlee.info/3d/povray-glassy.html">documentación de POVRay</a>.</li>
</ul>
<p>Mostrar una flecha:</p>
<pre><code class="language-javascript">var g = Graphics([])
g.display(Arrow([-1/2,-1/2,-1/2], [1/2,1/2,1/2], aspectratio=0.05, n=10))
Show(g)
</code></pre>
<h2 id="cylinder"><a class="header" href="#cylinder">Cylinder</a></h2>
<p>La función <code>Cylinder</code> crea un cilindro. Se necesitan dos argumentos necesarios:</p>
<pre><code class="language-javascript">cylinder(start, end)
</code></pre>
<ul>
<li><code>start</code> y <code>end</code> son los dos vértices.</li>
</ul>
<p>También puede proporcionar argumentos opcionales:</p>
<ul>
<li><code>aspectratio</code> controla la anchura del cilindro en relación con su longitud.</li>
<li><code>n</code> es un número entero que controla la calidad de la pantalla. Una <code>n</code> más alta conduce a un cilindro más redondo.</li>
<li><code>color</code> es el color del cilindro. Puede ser una lista de valores RGB o un objeto <code>Color</code>.</li>
<li><code>transmit</code> establece la transparencia del cilindro. Este parámetro solo es utilizado por el módulo povray a partir de ahora. El valor predeterminado es 0.</li>
<li><code>filter</code> establece la transparencia del cilindro mediante un efecto de filtro. Este parámetro solo es utilizado por el módulo povray a partir de ahora. El valor predeterminado es 0. Para conocer la diferencia entre 'transmitir' y 'filtrar', consulte la <a href="http://xahlee.info/3d/povray-glassy.html">documentación de POVRay</a>.</li>
</ul>
<p>Mostrar un cilindro:</p>
<pre><code class="language-javascript">var g = Graphics()
g.display(Cylinder([-1/2,-1/2,-1/2], [1/2,1/2,1/2], aspectratio=0.1, n=10))
Show(g)
</code></pre>
<h2 id="tube"><a class="header" href="#tube">Tube</a></h2>
<p>La función <code>Tube</code> conecta una secuencia de puntos para formar un tubo.</p>
<pre><code class="language-javascript">Tube(points, radius)
</code></pre>
<ul>
<li><code>puntos</code> es una lista de puntos; esto puede ser una lista de listas o una <code>Matriz</code> con las posiciones como columnas.</li>
<li><code>radius</code> es el radio del tubo.</li>
</ul>
<p>También puede proporcionar argumentos opcionales:</p>
<ul>
<li><code>n</code> es un número entero que controla la calidad de la pantalla. Una 'n' más alta conduce a un tubo más redondo.</li>
<li><code>color</code> es el color del tubo. Puede ser una lista de valores RGB o un objeto <code>Color</code>.</li>
<li><code>closed</code> es un <code>bool</code> que indica si el tubo debe cerrarse para formar un bucle.</li>
<li><code>transmit</code> establece la transparencia del tubo. Este parámetro solo es utilizado por el módulo povray a partir de ahora. El valor predeterminado es 0.</li>
<li><code>filter</code> establece la transparencia del tubo mediante un efecto de filtro. Este parámetro solo es utilizado por el módulo povray a partir de ahora. El valor predeterminado es 0. Para conocer la diferencia entre 'transmitir' y 'filtrar', consulte la <a href="http://xahlee.info/3d/povray-glassy.html">documentación de POVRay</a>.</li>
</ul>
<p>Dibuja un cuadrado:</p>
<pre><code class="language-javascript">var a = Tube([[-1/2,-1/2,0],[1/2,-1/2,0],[1/2,1/2,0],[-1/2,1/2,0]], 0.1, closed=true)
var g = Graphics()
g.display(a)
</code></pre>
<h2 id="sphere"><a class="header" href="#sphere">Sphere</a></h2>
<p>La función <code>Sphere</code> crea una esfera.</p>
<pre><code class="language-javascript">Sphere(center, radius)
</code></pre>
<ul>
<li><code>center</code> es la posición del centro de la esfera; puede ser una lista o una columna <code>Matrix</code>.</li>
<li><code>radius</code> es el radio de la esfera</li>
</ul>
<p>También puede proporcionar argumentos opcionales:</p>
<ul>
<li><code>color</code> es el color de la esfera. Puede ser una lista de valores RGB o un objeto <code>Color</code>.</li>
<li><code>transmit</code> establece la transparencia de la esfera. Este parámetro solo es utilizado por el módulo povray a partir de ahora. El valor predeterminado es 0.</li>
<li><code>filter</code> establece la transparencia de la esfera usando un efecto de filtro. Este parámetro solo es utilizado por el módulo povray a partir de ahora. El valor predeterminado es 0. Para conocer la diferencia entre 'transmitir' y 'filtrar', consulte la <a href="http://xahlee.info/3d/povray-glassy.html">documentación de POVRay</a>.</li>
</ul>
<p>Dibuja algunas esferas de tamaño aleatorio:</p>
<pre><code class="language-javascript">var g = Graphics()
for (i in 0...10) {
  g.display(Sphere([random()-1/2, random()-1/2, random()-1/2], 0.1*(1+random()),       color=Gray(random())))
}
Show(g)
</code></pre>
<h2 id="text"><a class="header" href="#text">Text</a></h2>
<p>Un objeto <code>Text</code> se utiliza para mostrar texto.</p>
<pre><code class="language-javascript">Text(text, position)
</code></pre>
<ul>
<li><code>text</code> es el texto que se mostrará como una cuerda.</li>
<li><code>position</code> es la posición en la que se va a mostrar el texto.</li>
</ul>
<p>También puede proporcionar argumentos opcionales:</p>
<ul>
<li><code>color</code> es el color del texto. Debe ser un objeto <code>Color</code>.</li>
<li><code>dirn</code> es la dirección a lo largo de la cual se dibuja el texto. Debe ser una <code>List</code> o una <code>Matrix</code>.</li>
<li><code>size</code> es el tamaño de fuente que se va a utilizar</li>
<li><code>vertical</code> es la dirección vertical del texto</li>
<li><code>font</code> es el objeto <code>Font</code> que se va a utilizar.</li>
</ul>
<p>Dibuja varios fragmentos de texto alrededor del eje y:</p>
<pre><code class="language-javascript">var g = Graphics()
for (phi in 0..Pi:Pi/8) {
  g.display(Text("Hola Mundo", [0,0,0], size=72, dirn=[0,1,0], vertical=[cos(phi),0,sin(phi)]))
}
Show(g)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implicitmesh-malla-implícita"><a class="header" href="#implicitmesh-malla-implícita">Implicitmesh (Malla implícita)</a></h1>
<p>El módulo <code>implicitmesh</code> le permite construir mallas a partir de funciones implícitas. Por ejemplo, la esfera unitaria podría especificarse mediante la función 'x^2+y^2+z^2-1 == 0'.</p>
<p>Para usar el módulo, primero impórtelo:</p>
<pre><code class="language-javascript">import implicitmesh
</code></pre>
<p>Para crear una esfera, primero cree un objeto ImplicitMeshBuilder con la función implícita que desea usar:</p>
<pre><code class="language-javascript">var impl = ImplicitMeshBuilder(fn (x,y,z) x^2+y^2+z^2-1)
</code></pre>
<p>Puede utilizar una función (o método) existente, así como una función anónima como la anterior.</p>
<p>A continuación, construye la malla,</p>
<pre><code class="language-javascript">var mesh = impl.build(stepsize=0.25)
</code></pre>
<p>El método <code>build</code> toma una serie de argumentos opcionales:</p>
<ul>
<li><code>start</code> - el punto de partida. Si no se proporciona, se utiliza el valor Matrix([1,1,1]).</li>
<li><code>stepsize</code> - escala de longitud aproximada a utilizar.</li>
<li><code>maxiterations</code>: número máximo de iteraciones a utilizar. Si se supera este límite, se devolverá una malla parcialmente construida.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kdtree"><a class="header" href="#kdtree">KDTree</a></h1>
<p>El módulo <code>kdtree</code> implementa un árbol k-dimensional, una estructura de datos de partición espacial que se puede utilizar para acelerar los cálculos de geometría computacional.</p>
<p>Para usar el módulo, primero impórtelo:</p>
<pre><code class="language-javascript">import kdtree
</code></pre>
<p>Para crear un árbol a partir de una lista de puntos:</p>
<pre><code class="language-javascript">var pts = []
for (i in 0...100) pts.append(Matrix([random(), random(), random()]))
var tree=KDTree(pts)
</code></pre>
<p>Añade más puntos:</p>
<pre><code class="language-javascript">tree.insert(Matrix([0,0,0]))
</code></pre>
<p>Compruebe si un punto dado está presente en el árbol:</p>
<pre><code class="language-javascript">tree.ismember(Matrix([1,0,0]))
</code></pre>
<p>Encuentre todos los puntos dentro de un cuadro delimitador determinado:</p>
<pre><code class="language-javascript">var pts = tree.search([[-1,1], [-1,1], [-1,1]])
for (x in pts) print x.location
</code></pre>
<p>Encuentre el punto más cercano a un punto determinado:</p>
<pre><code class="language-javascript">var pt = tree.nearest(Matrix([0.1, 0.1, 0.5]))
print pt.location
</code></pre>
<h2 id="insert-1"><a class="header" href="#insert-1">Insert</a></h2>
<p>Inserta un nuevo punto en un árbol k-d. Devuelve un objeto KDTreeNode.</p>
<pre><code class="language-javascript">var node = tree.insert(Matrix([0,0,0]))
</code></pre>
<p>Tenga en cuenta que, por razones de rendimiento, si el conjunto de puntos se conoce de antemano, generalmente es mejor construir el árbol usando la función constructora KDTree en lugar de uno por uno con insert.</p>
<h2 id="ismember-2"><a class="header" href="#ismember-2">Ismember</a></h2>
<p>Comprueba si un punto es miembro de un árbol k-d. Devuelve <code>verdadero</code> o <code>falso</code>.</p>
<pre><code class="language-javascript">print tree.ismember(Matrix([0,0,0]))
</code></pre>
<h2 id="más-cercano"><a class="header" href="#más-cercano">Más cercano</a></h2>
<p>Busca el punto en un árbol k-d más cercano a un punto de interés. Devuelve un objeto KDTreeNode.</p>
<pre><code class="language-javascript">var pt = tree.nearest(Matrix([0.1, 0.1, 0.5]))
</code></pre>
<p>Para obtener la ubicación de este punto más cercano, acceda a la propiedad location:</p>
<pre><code class="language-javascript">print pt.location
</code></pre>
<h2 id="buscar"><a class="header" href="#buscar">Buscar</a></h2>
<p>Busca todos los puntos de un árbol k-d que se encuentran dentro de un cuadro delimitador cuboidal. Devuelve una lista de objetos KDTreeNode.</p>
<p>Encuentre y muestre todos los puntos que se encuentran en un cuboide 0&lt;=x&lt;=1, 0&lt;=y&lt;=2, 1&lt;=z&lt;=2:</p>
<pre><code class="language-javascript">var result = tree.search([[0,1], [0,2], [1,2]])
for (x in result) print x.location
</code></pre>
<h2 id="kdtreenode"><a class="header" href="#kdtreenode">KDTreeNode</a></h2>
<p>Un objeto correspondiente a un solo nodo en un árbol k-d. Para obtener la ubicación del nodo, acceda a la propiedad <code>location</code>:</p>
<pre><code class="language-javascript">print node.location
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="meshgen-1"><a class="header" href="#meshgen-1">Meshgen</a></h1>
<p>El módulo <code>meshgen</code> se utiliza para crear objetos <code>Mesh</code> correspondientes a un dominio específico. Proporciona la clase <code>MeshGen</code> para realizar el mallado, que se crean con los siguientes argumentos:</p>
<pre><code class="language-javascript">MeshGen(domain, boundingbox)
</code></pre>
<p>Los dominios se especifican mediante una función escalar que es positiva en la región que se va a mallar y localmente suave. Por ejemplo, para mallar el disco de la unidad:</p>
<pre><code class="language-javascript">var dom = fn (x) -(x[0]^2+x[1]^2-1)
</code></pre>
<p>A continuación, se crea un objeto <code>MeshGen</code> y se utiliza para construir la <code>Mesh</code> de la siguiente manera:</p>
<pre><code class="language-javascript">var mg = MeshGen(dom, [-1..1:0.2, -1..1:0.2])
var m = mg.build()
</code></pre>
<p>Se debe especificar un cuadro delimitador para la malla como una <code>Lista</code> de objetos <code>Rango</code>, uno para cada dimensión. El incremento en cada <code>Rango</code> da una escala aproximada para el tamaño de los elementos generados.</p>
<p>Para facilitar la creación conveniente de dominios, se proporciona una clase <code>Domain</code> que proporciona operaciones de conjunto <code>unión</code>, <code>intersección</code> y <code>diferencia</code>.</p>
<p><code>MeshGen</code> acepta una serie de argumentos opcionales:</p>
<ul>
<li><code>weight</code> Una función de peso escalar que controla la densidad de la malla.</li>
<li><code>quiet</code> Establécido en 'true' para suprimir la salida de <code>MeshGen</code>.</li>
<li><code>method</code> una lista de opciones que controla el método utilizado.</li>
</ul>
<p>Algunas opciones de métodos que están disponibles incluyen:</p>
<ul>
<li><code>”FixedStepSize”</code> Usa un tamaño de paso fijo en la optimización.</li>
<li><code>”StartGrid”</code> Comienza desde una cuadrícula regular de puntos (el valor predeterminado).</li>
<li><code>”StartRandom”</code> Comienza a partir de una colección de puntos generada aleatoriamente.</li>
</ul>
<p>También hay una serie de propiedades de un objeto <code>MeshGen</code> que se pueden establecer antes de llamar a <code>build</code> para controlar el funcionamiento de la generación de malla:</p>
<ul>
<li><code>stepsize</code>, <code>steplimit</code> Tamaño de paso utilizado internamente por el <code>Optimizador</code></li>
<li><code>fscale</code>, una "presión" interna</li>
<li><code>ttol</code> hasta dónde se permite que se muevan los vértices antes de la retriangulación</li>
<li>Tolerancia a la energía <code>etol</code> para el problema de optimización</li>
<li><code>maxiterations</code> Número máximo de iteraciones de minimización + retriangulación (el valor predeterminado es 100)</li>
</ul>
<p><code>MeshGen</code> elige valores predeterminados que cubren un rango razonable de usos.</p>
<h2 id="domain-dominio"><a class="header" href="#domain-dominio">Domain (Dominio)</a></h2>
<p>La clase <code>Domain</code> se utiliza para construir convenientemente un dominio mediante la composición de elementos más simples.</p>
<p>Cree un <code>Dominio</code> a partir de una función escalar que sea positiva en la región de interés:</p>
<pre><code class="language-javascript">var dom = Domain(fn (x) -(x[0]^2+x[1]^2-1))
</code></pre>
<p>Puede pasarlo a <code>MeshGen</code> para especificar la región que se va a mallar:</p>
<pre><code class="language-javascript">var mg = MeshGen(dom, [-1..1:0.2, -1..1:0.2])
</code></pre>
<p>Puede combinar objetos <code>Dominio</code> utilizando las operaciones de conjunto <code>unión</code>, <code>intersección</code> y <code>diferencia</code>:</p>
<pre><code class="language-javascript">var a = CircularDomain(Matrix([-0.5,0]), 1)
var b = CircularDomain(Matrix([0.5,0]), 1)
var c = CircularDomain(Matrix([0,0]), 0.3)
var dom = a.union(b).difference(c)
</code></pre>
<h2 id="circulardomain-dominio-circular"><a class="header" href="#circulardomain-dominio-circular">CircularDomain (Dominio circular)</a></h2>
<p>Construye convenientemente un objeto <code>Domain</code> correspondiente a un disco. Requiere la posición del centro y un radio como argumentos.</p>
<p>Cree un dominio correspondiente a la unidad de disco:</p>
<pre><code class="language-javascript">var c = CircularDomain([0,0], 1)
</code></pre>
<h2 id="rectangulardomain-dominio-rectangular"><a class="header" href="#rectangulardomain-dominio-rectangular">RectangularDomain (Dominio Rectangular)</a></h2>
<p>Construye convenientemente un objeto <code>Domain</code> correspondiente a un rectángulo. Requiere una lista de rangos como argumentos. Funciona en dimensiones arbitrarias</p>
<p>Crea un <code>Domain</code> cuadrado:</p>
<pre><code class="language-javascript">var c = RectangularDomain([-1..1, -1..1])
</code></pre>
<h2 id="halfspacedomain-dominio-halfspace"><a class="header" href="#halfspacedomain-dominio-halfspace">HalfSpaceDomain (Dominio HalfSpace)</a></h2>
<p>Construye convenientemente un objeto <code>Domain</code> correspondiente a un medio espacio definido por un plano en <code>x0</code> y una <code>n</code> normal:</p>
<pre><code class="language-javascript">var hs = HalfSpaceDomain(x0, n)
</code></pre>
<p>Tenga en cuenta que <code>n</code> es una normal "externa", por lo que apunta a la región <em>excluida</em>.</p>
<p>Medio espacio correspondiente a la región permitida <code>x&lt;0</code>:</p>
<pre><code class="language-javascript">var hs = HalfSpaceDomain(Matrix([0,0,0]), Matrix([1,0,0]))
</code></pre>
<p>Tenga en cuenta que los <code>HalfSpaceDomain</code> no se pueden mallar directamente, ya que corresponden a una región infinita. Sin embargo, son útiles para combinarlos con otros dominios.</p>
<p>Cree la mitad de un disco cortando un <code>HalfSpaceDomain</code> de un <code>CircularDomain</code>:</p>
<pre><code class="language-javascript">var c = CircularDomain([0,0], 1)
var hs = HalfSpaceDomain(Matrix([0,0]), Matrix([-1,0]))
var dom = c.difference(hs) 
var mg = MeshGen(dom, [-1..1:0.2, -1..1:0.2], quiet=false)
var m = mg.build()
</code></pre>
<h2 id="mshgndim"><a class="header" href="#mshgndim">MshGnDim</a></h2>
<p>El módulo <code>MeshGen</code> actualmente admite mallas de 2 y 3 dimensiones. El mallado de mayor dimensión estará disponible en una versión futura; Póngase en contacto con el desarrollador si está interesado en esta funcionalidad.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="meshslice-1"><a class="header" href="#meshslice-1">Meshslice</a></h1>
<p>El módulo <code>meshslice</code> se utiliza para cortar un objeto <code>Mesh</code> a lo largo de un plano dado, produciendo un nuevo objeto <code>Mesh</code> de menor dimensionalidad. También puede usar <code>meshslice</code> para proyectar objetos <code>Field</code> en la nueva malla.</p>
<p>Para usar el módulo, comience importándolo:</p>
<pre><code class="language-javascript">import meshslice 
</code></pre>
<p>A continuación, construya un objeto <code>MeshSlicer</code>, pasando la malla que desea cortar en el constructor:</p>
<pre><code class="language-javascript">var slice = MeshSlicer(mesh)
</code></pre>
<p>A continuación, realice un corte llamando al método <code>slice</code>, pasando el plano por el que desea cortar. Este método devuelve un nuevo objeto <code>Mesh</code> que comprende el sector. Un plano está definido por un punto que se encuentra en el plano <code>pt</code> y una dirección normal al plano <code>dirn</code>:</p>
<pre><code class="language-javascript">var slc = slice.slice(pt, dirn)
</code></pre>
<p>Después de haber realizado un corte, puede proyectar cualquier objeto <code>Field</code> asociado en la malla cortada llamando al método <code>slicefield</code>:</p>
<pre><code class="language-javascript">var phi = Field(mesh, fn (x,y,z) x+y+z)
var sphi = slice.slicefield(phi)
</code></pre>
<p>El nuevo campo devuelto por <code>slicefield</code> vive en la malla cortada. Puede segmentar cualquier número de campos.</p>
<p>Puede realizar varios sectores con el mismo <code>MeshSlicer</code> simplemente llamando a <code>slice</code> de nuevo con un plano diferente.</p>
<h2 id="slcempty"><a class="header" href="#slcempty">SlcEmpty</a></h2>
<p>Este error se produce si intenta usar <code>slicefield</code> en un <code>MeshSlicer</code> sin haber realizado un segmento. Por ejemplo:</p>
<pre><code class="language-javascript">var slice = MeshSlicer(mesh)
slice.slicefield(phi) // arroja SlcEmpty
slice.slice([0,0,0],[1,0,0]) 
</code></pre>
<p>Para solucionarlo, llame a <code>slice</code> antes de <code>slicefield</code>:</p>
<pre><code class="language-javascript">var slice = MeshSlicer(mesh)
slice.slice([0,0,0],[1,0,0]) 
slice.slicefield(phi) // Ahora se corta correctamente 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="meshtools"><a class="header" href="#meshtools">Meshtools</a></h1>
<p>El paquete Meshtools contiene una serie de funciones y clases para ayudar a crear y manipular mallas.</p>
<h2 id="areamesh-1"><a class="header" href="#areamesh-1">AreaMesh</a></h2>
<p>Esta función crea una malla compuesta de triángulos a partir de una función paramétrica. Para usarlo:</p>
<pre><code class="language-javascript">var m = AreaMesh(function, range1, range2, closed=boolean)
</code></pre>
<p>dónde</p>
<ul>
<li><code>function</code> es una función paramétrica que tiene un parámetro. Debe devolver una lista de coordenadas o una matriz de columnas correspondiente a este parámetro.</li>
<li><code>range1</code> es el rango que se utilizará para el primer parámetro de la función paramétrica.</li>
<li><code>range2</code> es el rango que se usará para el segundo parámetro de la función paramétrica.</li>
<li><code>closed</code> es un parámetro opcional que indica si se debe crear un bucle cerrado o no. Puede proporcionar una lista en la que cada elemento indique si el parámetro relevante está cerrado o no.</li>
</ul>
<p>Para usar <code>AreaMesh</code>, importe el módulo <code>meshtools</code>:</p>
<pre><code class="language-javascript">import meshtools
</code></pre>
<p>Crea un cuadrado:</p>
<pre><code class="language-javascript">var m = AreaMesh(fn (u,v) [u, v, 0], 0..1:0.1, 0..1:0.1)
</code></pre>
<p>Crea un tubo:</p>
<pre><code class="language-javascript">var m = AreaMesh(fn (u, v) [v, cos(u), sin(u)], -Pi...Pi:Pi/4,
                 -1..1:0.1, closed=[true, false])
</code></pre>
<p>Crea un toroide:</p>
<pre><code class="language-javascript">var c=0.5, a=0.2
var m = AreaMesh(fn (u, v) [(c + a*cos(v))*cos(u),
                            (c + a*cos(v))*sin(u),
                            a*sin(v)], 0...2*Pi:Pi/16, 0...2*Pi:Pi/8, closed=true)
</code></pre>
<h2 id="linemesh-1"><a class="header" href="#linemesh-1">LineMesh</a></h2>
<p>Esta función crea una malla compuesta por elementos de línea a partir de una función paramétrica. Para usarlo:</p>
<pre><code class="language-javascript">var m = LineMesh(function, range, closed=boolean)
</code></pre>
<p>dónde</p>
<ul>
<li><code>function</code> es una función paramétrica que tiene un parámetro. Debe devolver una lista de coordenadas o una matriz de columnas correspondiente a este parámetro.</li>
<li><code>range</code> es el rango que se utilizará para la función paramétrica.</li>
<li><code>closed</code> es un parámetro opcional que indica si se debe crear un bucle cerrado o no.</li>
</ul>
<p>Para usar <code>LineMesh</code>, importe el módulo <code>meshtools</code>:</p>
<pre><code class="language-javascript">import meshtools
</code></pre>
<p>Crea un círculo:</p>
<pre><code class="language-javascript">import constants
var m = LineMesh(fn (t) [sin(t), cos(t), 0], 0...2*Pi:2*Pi/50, closed=true)
</code></pre>
<h2 id="polyhedronmesh-1"><a class="header" href="#polyhedronmesh-1">PolyhedronMesh</a></h2>
<p>Esta función crea una malla correspondiente a un poliedro.</p>
<pre><code class="language-javascript">var m = PolyhedronMesh(vertices, faces)
</code></pre>
<p>donde <code>vértices</code> es una lista de vértices y <code>faces</code> es una lista de caras especificadas como una lista de índices de vértices.</p>
<p>Para usar <code>PolyhedronMesh</code>, importe el módulo <code>meshtools</code>:</p>
<pre><code class="language-javascript">import meshtools
</code></pre>
<p>Crea un cubo:</p>
<pre><code class="language-javascript">var m = PolyhedronMesh([ [-0.5, -0.5, -0.5], [ 0.5, -0.5, -0.5],
                         [-0.5,  0.5, -0.5], [ 0.5,  0.5, -0.5],
                         [-0.5, -0.5,  0.5], [ 0.5, -0.5,  0.5],
                         [-0.5,  0.5,  0.5], [ 0.5,  0.5,  0.5]],
                       [ [0,1,3,2], [4,5,7,6], [0,1,5,4], 
                         [3,2,6,7], [0,2,6,4], [1,3,7,5] ])
</code></pre>
<p><em>Nota</em> que los vértices de cada lista de caras deben especificarse estrictamente en orden cíclico.</p>
<h2 id="delaunaymesh-1"><a class="header" href="#delaunaymesh-1">DelaunayMesh</a></h2>
<p>La función constructora <code>DelaunayMesh</code> crea un objeto <code>Mesh</code> directamente a partir de una nube de puntos utilizando el triangulador de Delaunay.</p>
<pre><code class="language-javascript">var pts = []
for (i in 0...100) pts.append(Matrix([random(), random()]))
var m=DelaunayMesh(pts)
Show(plotmesh(m))
</code></pre>
<p>Puede controlar la dimensión de salida de la malla (por ejemplo, para crear una malla 2D incrustada en el espacio 3D) utilizando la propiedad opcional <code>outputdim</code>.</p>
<pre><code class="language-javascript">var m = DelaunayMesh(pts, outputdim=3)
</code></pre>
<h2 id="equitriangulate-equiangulado"><a class="header" href="#equitriangulate-equiangulado">Equitriangulate (Equiangulado)</a></h2>
<p>Intenta equiangular una malla, intercambiando elementos para mejorar su regularidad.</p>
<pre><code class="language-javascript">equiangulate(mesh)
</code></pre>
<p>Esta función toma argumentos opcionales:</p>
<ul>
<li><code>quiet</code>: Establézcalo en mensajes fieles a silencio.</li>
<li><code>fix</code>: Proporciona una 'Selección' que contiene aristas que no deben modificarse por equiangulación.</li>
</ul>
<p><em>Nota</em> esta función modifica la malla en su lugar; no crea una nueva malla.</p>
<h2 id="changemeshdimension"><a class="header" href="#changemeshdimension">ChangeMeshDimension</a></h2>
<p>Cambia la dimensión en la que se incrusta una malla. Por ejemplo, es posible que haya creado una malla en 2D que ahora desee utilizar en 3D.</p>
<p>Utilizar:</p>
<pre><code class="language-javascript">var new = ChangeMeshDimension(mesh, dim)
</code></pre>
<p>donde <code>mesh</code> es la malla que desea cambiar, y <code>dim</code> es la nueva dimensión de incrustación.</p>
<h2 id="meshbuilder-1"><a class="header" href="#meshbuilder-1">MeshBuilder</a></h2>
<p>La clase <code>MeshBuilder</code> simplifica la creación de mallas por parte del usuario. Para usar esta clase, comience creando un objeto <code>MeshBuilder</code>:</p>
<pre><code class="language-javascript">var build = MeshBuilder()
</code></pre>
<p>A continuación, puede añadir vértices, aristas, etc. uno por uno utilizando <code>addvertex</code>, <code>addedge</code>, <code>addface</code> y <code>addelement</code>. Cada uno de ellos devuelve un identificador de elemento:</p>
<pre><code class="language-javascript">var id1=build.addvertex(Matrix([0,0,0]))
var id2=build.addvertex(Matrix([1,1,1]))
build.addedge([id1, id2])
</code></pre>
<p>Una vez que la malla esté lista, llame al método <code>build</code> para construir la <code>malla</code>:</p>
<pre><code class="language-javascript">var m = build.build()
</code></pre>
<p>Puede especificar la dimensión de la <code>Malla</code> explícitamente al inicializar el <code>MeshBuilder</code>:</p>
<pre><code class="language-javascript">var mb = MeshBuilder(dimension=2)
</code></pre>
<p>o implícitamente al agregar el primer vértice:</p>
<pre><code class="language-javascript">var mb = MeshBuilder() 
mb.addvertex([0,1]) // Una malla 2D
</code></pre>
<h2 id="mshblddimincnstnt"><a class="header" href="#mshblddimincnstnt">MshBldDimIncnstnt</a></h2>
<p>Este error se produce si intenta agregar un vértice que no es consistente con la dimensión de la malla, p. ej.</p>
<pre><code class="language-javascript">var mb = MeshBuilder(dimension=2) 
mb.addvertex([1,0,0]) // ¡Arroja un error! 
</code></pre>
<p>Para solucionar este problema, asegúrese de que todos los vértices tengan la dimensión correcta.</p>
<h2 id="mshblddimunknwn"><a class="header" href="#mshblddimunknwn">MshBldDimUnknwn</a></h2>
<p>Este error se produce si intenta agregar un elemento a un objeto <code>MeshBuilder</code> pero aún no ha especificado la dimensión (en la inicialización) o agregando un vértice.</p>
<pre><code class="language-javascript">var mb = MeshBuilder() 
mb.addedge([0,1]) // No se han agregado vértices 
</code></pre>
<p>Para solucionar esto, agregue primero los vértices.</p>
<h2 id="meshrefiner"><a class="header" href="#meshrefiner">MeshRefiner</a></h2>
<p>La clase <code>MeshRefiner</code> se utiliza para refinar las mallas y para corregir las estructuras de datos asociadas que dependen de la malla.</p>
<p>Para prepararse para el refinamiento, primero cree un objeto <code>MeshRefiner</code> con un objeto <code>Mesh</code>,</p>
<pre><code class="language-javascript">var mr = MeshRefiner(mesh)
</code></pre>
<p>o con una lista de objetos que puede incluir una <code>Mesh</code>, así como <code>Field</code> y 'Selection`.</p>
<pre><code class="language-javascript">var mr = MeshRefiner([mesh, field, selection ... ])
</code></pre>
<p>Para realizar el refinamiento, llame al método <code>refine</code>. Puedes refinar todos los elementos,</p>
<pre><code class="language-javascript">var dict = mr.refine()
</code></pre>
<p>o refinar los elementos seleccionados usando una <code>Selección</code>,</p>
<pre><code class="language-javascript">var dict = mr.refine(selection=select)
</code></pre>
<p>El método <code>refine</code> devuelve un <code>Dictionary</code> que asigna objetos antiguos a objetos nuevos y refinados. Utilícelo para actualizar sus estructuras de datos.</p>
<pre><code class="language-javascript">var newmesh = dict[oldmesh]
</code></pre>
<h2 id="meshpruner"><a class="header" href="#meshpruner">MeshPruner</a></h2>
<p>La clase <code>MeshPruner</code> se usa para podar detalles excesivos de las mallas (un proceso que a veces se denomina engrosado) y para corregir estructuras de datos asociadas que dependen de la malla.</p>
<p>Primero cree un objeto <code>MeshPruner</code> ya sea con un <code>Mesh</code>,</p>
<pre><code class="language-javascript">var mp = MeshPruner(mesh)
</code></pre>
<p>o con una lista de objetos que puede incluir una <code>Mesh</code>, así como <code>Field</code> y 'Selection`.</p>
<pre><code class="language-javascript">var mp = MeshPruner([mesh, field, selection ... ])
</code></pre>
<p>Para realizar el engrosado, llame al método <code>prune</code> con una <code>Selección</code>,</p>
<pre><code class="language-javascript">var dict = mp.prune(select)
</code></pre>
<p>El método <code>prune</code> devuelve un <code>Dictionary</code> que asigna objetos antiguos a objetos nuevos y refinados. Utilícelo para actualizar sus estructuras de datos.</p>
<pre><code class="language-javascript">var newmesh = dict[oldmesh]
</code></pre>
<h2 id="meshmerge"><a class="header" href="#meshmerge">MeshMerge</a></h2>
<p>La clase <code>MeshMerge</code> se utiliza para combinar mallas en una sola malla, eliminando cualquier elemento duplicado.</p>
<p>Para usarlo, cree un objeto <code>MeshMerge</code> con una lista de mallas para fusionar,</p>
<pre><code class="language-javascript">var mrg = MeshMerge([m1, m2, m3, ... ])
</code></pre>
<p>y luego llame al método <code>merge</code> para devolver una malla combinada:</p>
<pre><code class="language-javascript">var newmesh = mrg.merge()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="optimizar"><a class="header" href="#optimizar">Optimizar</a></h1>
<p>El paquete <code>optimize</code> contiene una serie de funciones y clases para realizar la optimización de formas.</p>
<h2 id="optimizationproblem-problema-de-optimización"><a class="header" href="#optimizationproblem-problema-de-optimización">OptimizationProblem (Problema de optimización)</a></h2>
<p>Un objeto <code>OptimizationProblem</code> define un problema de optimización, que puede incluir funcionalidades para optimizar, así como restricciones globales y locales.</p>
<p>Cree un <code>OptimizationProblem</code> con una malla:</p>
<pre><code class="language-javascript">var problem = OptimizationProblem(mesh)
</code></pre>
<p>Añade una energía:</p>
<pre><code class="language-javascript">var la = Area()
problem.addenergy(la)
</code></pre>
<p>Agregue una energía que funcione en una región seleccionada y con un prefactor opcional:</p>
<pre><code class="language-javascript">problem.addenergy(la, selection=sel, prefactor=2)
</code></pre>
<p>Agregue una restricción:</p>
<pre><code class="language-javascript">problem.addconstraint(la)
</code></pre>
<p>Agregue una restricción local (en este caso, una restricción de conjunto de niveles unilateral):</p>
<pre><code class="language-javascript">var ls = ScalarPotential(fn (x,y,z) z, fn (x,y,z) Matrix([0,0,1]))
problem.addlocalconstraint(ls, onesided=true)
</code></pre>
<h2 id="optimizer-optimizador"><a class="header" href="#optimizer-optimizador">Optimizer (Optimizador)</a></h2>
<p>Los objetos <code>Optimizer</code> se utilizan para optimizar <code>Mesh</code> y <code>Field</code>s. Debe usar la subclase adecuada: <code>ShapeOptimizer</code> o <code>FieldOptimizer</code> respectivamente.</p>
<h2 id="shape-optimizer-optimizador-de-formas"><a class="header" href="#shape-optimizer-optimizador-de-formas">Shape Optimizer (Optimizador de formas)</a></h2>
<p>Un objeto <code>ShapeOptimizer</code> realiza la optimización de la forma: mueve las posiciones de los vértices para reducir la energía total.</p>
<p>Cree un objeto <code>ShapeOptimizer</code> con un <code>OptimizationProblem</code> y un <code>Mesh</code>:</p>
<pre><code class="language-javascript">var sopt = ShapeOptimizer(problem, m)
</code></pre>
<p>Da un paso hacia abajo en el gradiente con un tamaño de paso fijo:</p>
<pre><code class="language-javascript">sopt.relax(5) // Da cinco pasos
</code></pre>
<p>Búsqueda de líneas por el gradiente:</p>
<pre><code class="language-javascript">sopt.linesearch(5) // Realiza cinco búsquedas de línea
</code></pre>
<p>Realice un gradiente conjugado (generalmente da una convergencia más rápida):</p>
<pre><code class="language-javascript">sopt.conjugategradient(5) // Realiza cinco pasos de gradiente conjugado.
</code></pre>
<p>Controle una serie de propiedades del optimizador:</p>
<pre><code class="language-javascript">sopt.stepsize=0.1 // El tamaño del paso a tomar
sopt.steplimit=0.5 // Tamaño máximo de paso para optimizar métodos
sopt.etol = 1e-8 // Tolerancia a la convergencia energética
sopt.ctol = 1e-9 // Tolerancia a la que se satisfacen las restricciones
sopt.maxconstraintsteps = 20 // Número máximo de pasos de restricción que se van a utilizar
</code></pre>
<h2 id="fieldoptimizer-optimizador-de-campo"><a class="header" href="#fieldoptimizer-optimizador-de-campo">FieldOptimizer (Optimizador de campo)</a></h2>
<p>Un objeto <code>FieldOptimizer</code> realiza la optimización del campo: cambia los elementos de un <code>Field</code> para reducir la energía total.</p>
<p>Cree un objeto <code>FieldOptimizer</code> con un <code>OptimizationProblem</code> y un <code>Field</code>:</p>
<pre><code class="language-javascript">var sopt = FieldOptimizer(problem, fld)
</code></pre>
<p>Los optimizadores de campo proporcionan las mismas opciones y métodos que los optimizadores de formas: consulte la documentación de <code>ShapeOptimizer</code> para obtener más detalles.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plot-1"><a class="header" href="#plot-1">Plot</a></h1>
<p>El módulo <code>plot</code> proporciona capacidades de visualización para mallas, selecciones y campos. Estas funciones producen objetos gráficos que se pueden mostrar con <code>Show</code>.</p>
<p>Para usar el módulo, primero impórtelo:</p>
<pre><code class="language-javascript">import plot
</code></pre>
<h2 id="plotmesh"><a class="header" href="#plotmesh">Plotmesh</a></h2>
<p>Visualiza un objeto <code>Mesh</code>(Malla):</p>
<pre><code class="language-javascript">var g = plotmesh(mesh)
</code></pre>
<p>Plotmesh acepta una serie de argumentos opcionales para controlar lo que se muestra:</p>
<ul>
<li><code>selection</code>: solo se dibujan los elementos de una Selection` proporcionada.</li>
<li><code>grade</code> - Dibuja solo la calificación especificada. Esta también puede ser una lista de varios grados para dibujar.</li>
<li><code>color</code> - Dibuja la malla en un <code>Color</code> proporcionado.</li>
<li><code>filter</code> y <code>transmit</code> - Utilizado por el módulo <code>povray</code> para indicar transparencia.</li>
</ul>
<h2 id="etiquetas-de-malla-gráfica"><a class="header" href="#etiquetas-de-malla-gráfica">Etiquetas de malla gráfica</a></h2>
<p>Dibuja los identificadores de los elementos de una <code>Mesh</code>:</p>
<pre><code class="language-javascript">var g = plotmeshlabels(mesh) 
</code></pre>
<p>Plotmeshlabels acepta una serie de argumentos opcionales para controlar la salida:</p>
<ul>
<li><code>grade</code> - Dibuja solo la calificación especificada. Esta también puede ser una lista de varios grados para dibujar.</li>
<li><code>selection</code>: solo se dibujan las etiquetas de una <code>Selección</code> proporcionada.</li>
<li><code>offset</code> - Vector de desplazamiento local para etiquetas. Puede ser una <code>Lista</code>, una <code>Matriz</code> o una función.</li>
<li><code>dirn</code> - Dirección del texto para las etiquetas. Puede ser una <code>Lista</code>, una <code>Matriz</code> o una función.</li>
<li><code>vertical</code> - Dirección vertical del texto. Puede ser una <code>Lista</code>, una <code>Matriz</code> o una función.</li>
<li><code>color</code> - Color de la etiqueta. Puede ser un objeto <code>Color</code> o un <code>Diccionario</code> de colores para cada grado.</li>
<li><code>fontsize</code> - Tamaño de fuente a utilizar.</li>
</ul>
<h2 id="plotselection"><a class="header" href="#plotselection">Plotselection</a></h2>
<p>Visualiza un objeto <code>Selection</code>:</p>
<pre><code class="language-javascript">var g = plotselection(mesh, sel)
</code></pre>
<p>Plotselection acepta una serie de argumentos opcionales para controlar lo que se muestra:</p>
<ul>
<li><code>grade</code> - Dibuja solo la calificación especificada. Esta también puede ser una lista de varios grados para dibujar.</li>
<li><code>filter</code> y <code>transmit</code> - Utilizado por el módulo <code>povray</code> para indicar transparencia.</li>
</ul>
<h2 id="plotfield"><a class="header" href="#plotfield">Plotfield</a></h2>
<p>Visualiza un objeto <code>Field</code> (Campo) escalar:</p>
<pre><code class="language-javascript">var g = plotfield(field)
</code></pre>
<p>Plotfield acepta una serie de argumentos opcionales para controlar lo que se muestra:</p>
<ul>
<li><code>grade</code> - Dibuja el grado especificado.</li>
<li><code>colormap</code> - Un objeto <code>Colormap</code> para usar. El campo se escala automáticamente.</li>
<li><code>scalebar</code> - Un objeto <code>Scalebar</code> que se va a utilizar.</li>
<li><code>style</code> - Estilo de trama. Véase más abajo.</li>
<li><code>filter</code> y <code>transmit</code> - Utilizado por el módulo <code>povray</code> para indicar transparencia.</li>
<li><code>cmin</code> y <code>cmax</code>: se pueden usar para definir el rango de datos cubierto. Los valores más allá de estos límites se colorearán según el límite inferior/superior del mapa de colores en consecuencia.</li>
</ul>
<p>Estilos de trazado admitidos:</p>
<ul>
<li><code>default</code> - Colorea los elementos <code>Mesh</code> por el valor correspondiente del <code>Campo</code>.</li>
<li><code>interpolate</code> - Interpolar cantidades de <code>Field</code> en elementos superiores.</li>
</ul>
<h2 id="barra-de-escala"><a class="header" href="#barra-de-escala">Barra de escala</a></h2>
<p>Representa una barra de escala para un gráfico:</p>
<pre><code class="language-javascript">Show(plotfield(field, scalebar=ScaleBar(posn=[1.2,0,0])))
</code></pre>
<p><code>ScaleBar</code> se puede crear con muchos parámetros ajustables:</p>
<ul>
<li><code>nticks</code> - Número máximo de ticks que se mostrarán.</li>
<li><code>posn</code> - Posición para dibujar la <code>ScaleBar</code>.</li>
<li><code>length</code> - Longitud de la <code>ScaleBar</code> que se va a dibujar.</li>
<li><code>dirn</code> - Dirección en la que se dibujará la 'ScaleBar'.</li>
<li><code>tickdirn</code> - Dirección para dibujar las garrapatas.</li>
<li><code>colormap</code> - 'ColorMap' a utilizar.</li>
<li><code>textdirn</code> - Dirección en la que se dibujarán las etiquetas.</li>
<li><code>textvertical</code> - Dirección vertical de la etiqueta.</li>
<li><code>fontsize</code> - Tamaño de fuente para etiquetas</li>
<li><code>textcolor</code> - Color para etiquetas</li>
</ul>
<p>Puede dibujar la <code>ScaleBar</code> directamente llamando al método <code>draw</code>:</p>
<pre><code class="language-javascript">sb.draw(min, max)
</code></pre>
<p>donde <code>min</code> y <code>max</code> son los valores mínimo y máximo que se mostrarán en la barra de escala.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="povray-1"><a class="header" href="#povray-1">POVRay</a></h1>
<p>El módulo <code>povray</code> proporciona integración con POVRay, un popular paquete de trazado de rayos de código abierto para una representación gráfica de alta calidad. Para usar el módulo, primero impórtelo:</p>
<pre><code class="language-javascript">import povray
</code></pre>
<p>Para trazar un gráfico con rayos, comience por crear un objeto <code>POVRaytracer</code>:</p>
<pre><code class="language-javascript">var pov = POVRaytracer(graphic)
</code></pre>
<p>Cree un archivo .pov que se pueda ejecutar con POVRay:</p>
<pre><code class="language-javascript">pov.write("out.pov")
</code></pre>
<p>Cree, renderice y muestre una escena con POVRay:</p>
<pre><code class="language-javascript">pov.render("out.pov")
</code></pre>
<p>Esto también crea el archivo .png para la escena.</p>
<p>El constructor <code>POVRaytracer</code> admite un argumento opcional <code>camera</code>:</p>
<ul>
<li><code>camera</code> - un objeto 'Cámara' (ver más abajo / ayuda) que contiene la configuración de la cámara povray.</li>
</ul>
<p>El objeto <code>Camera</code> se puede inicializar de la siguiente manera:</p>
<pre><code class="language-javascript">var camera = Camera()
</code></pre>
<p>Este objeto contiene la configuración predeterminada de la cámara, que se puede cambiar usando los siguientes argumentos opcionales, o simplemente estableciendo los atributos después de la creación de instancias:</p>
<ul>
<li><code>antialias</code>: si se suaviza el suavizado de la salida o no (<code>true</code> de forma predeterminada)</li>
<li><code>width</code> - ancho de la imagen (<code>2048</code> por defecto)</li>
<li><code>height</code> - altura de la imagen (<code>1536</code> por defecto)</li>
<li><code>viewangle</code> - ángulo de la cámara (más alto significa una vista más amplia) (<code>24</code> por defecto)</li>
<li><code>viewpoint</code> - posición de la cámara (<code>Matrix([0,0,-5])</code> por defecto)</li>
<li><code>look_at</code> - coordenada para mirar (<code>Matrix([0,0,0])</code> por defecto)</li>
<li><code>sky</code> - orientación que apunta al cielo (<code>Matrix([0,1,0])</code> por defecto)</li>
</ul>
<p>La configuración predeterminada genera una vista centrada razonable del plano x-y.</p>
<p>Estos atributos también se pueden establecer directamente para el objeto <code>POVRaytracer</code>:</p>
<pre><code class="language-javascript">pov.look_at = Matrix([0,0,1])
</code></pre>
<p>El método <code>render</code> admite algunos argumentos booleanos opcionales:</p>
<ul>
<li><code>quiet</code> - si se suprime el analizador y se renderizan las estadísticas de <code>povray</code> o no (<code>false</code> por defecto)</li>
<li><code>display</code>: si se debe activar la pantalla gráfica durante el renderizado o no (<code>true</code> de forma predeterminada)</li>
<li><code>shadowless</code>: si se deben desactivar las sombras durante el renderizado ('false' de forma predeterminada)</li>
<li><code>transparent</code>: si se debe representar el gráfico con un fondo transparente en el PNG de salida ('false' de forma predeterminada)</li>
</ul>
<h1 id="cámara"><a class="header" href="#cámara">Cámara</a></h1>
<p>El objeto <code>Camera</code> se puede inicializar de la siguiente manera:</p>
<pre><code class="language-javascript">var camera = Camera()
</code></pre>
<p>Este objeto contiene la configuración predeterminada de la cámara, que se puede cambiar usando los siguientes argumentos opcionales, o simplemente estableciendo los atributos después de la creación de instancias:</p>
<ul>
<li><code>antialias</code>: si se suaviza el suavizado de la salida o no (<code>true</code> de forma predeterminada)</li>
<li><code>width</code> - ancho de la imagen (<code>2048</code> por defecto)</li>
<li><code>height</code> - altura de la imagen (<code>1536</code> por defecto)</li>
<li><code>viewangle</code> - ángulo de la cámara (más alto significa una vista más amplia) (<code>24</code> por defecto)</li>
<li><code>viewpoint</code> - posición de la cámara (<code>Matrix([0,0,-5])</code> por defecto)</li>
<li><code>look_at</code> - coordenada para mirar (<code>Matrix([0,0,0])</code> por defecto)</li>
<li><code>sky</code> - orientación que apunta al cielo (<code>Matrix([0,1,0])</code> por defecto)</li>
</ul>
<pre><code class="language-javascript">camera.sky = Matrix([0,0,1])
</code></pre>
<p>La configuración predeterminada genera una vista centrada razonable del plano x-y.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vtk"><a class="header" href="#vtk">VTK</a></h1>
<p>El módulo vtk contiene clases para permitir la E/S de mallas y campos utilizando el formato heredado de VTK. Tenga en cuenta que actualmente solo admite campos escalares o vectoriales 2D/3D (matriz de columnas) que se encuentran en los vértices (forma <code>[1,0,0]</code>). Próximamente se admitirán campos tensoriales y campos en celdas.</p>
<h2 id="vtkexporter"><a class="header" href="#vtkexporter">VTKExporter</a></h2>
<p>Esta clase se puede utilizar para exportar los campos y/o una malla en un estado determinado a un único archivo .vtk. Para usarlo, importe el módulo <code>vtk</code>:</p>
<pre><code class="language-javascript">import vtk
</code></pre>
<p>Inicializar el archivo <code>VTKExporter</code></p>
<pre><code class="language-javascript">var vtkE = VTKExporter(obj)
</code></pre>
<p>donde <code>obj</code> puede ser</p>
<ul>
<li>Un objeto <code>Mesh</code>: Esto prepara la malla para la exportación.</li>
<li>Un objeto <code>Campo</code>: Prepara tanto el campo como la malla asociada a él para la exportación.</li>
</ul>
<p>Utilice el método <code>exportar</code> para exportar a un archivo VTK.</p>
<pre><code class="language-javascript">vtkE.export(“output.vtk")
</code></pre>
<p>Opcionalmente, utilice el método <code>addfield</code> para agregar uno o más campos antes de exportar:</p>
<pre><code class="language-javascript">vtkE.addfield(f, fieldname="f")
</code></pre>
<p>dónde,</p>
<ul>
<li><code>f</code> es el objeto de campo que se va a exportar</li>
<li><code>fieldname</code> es un argumento opcional que asigna un nombre al campo en el archivo VTK. Este nombre debe ser una cadena de caracteres sin espacios en blanco incrustados. Si no se proporciona, el nombre sería "escalares" o "vectores" según el tipo de campo**.</li>
</ul>
<p>** Tenga en cuenta que esto actualmente solo admite campos escalares o vectoriales 2D/3D (matriz de columnas) que residen en los vértices ( forma <code>[1,0,0]</code>). Próximamente se admitirán campos tensoriales y campos en celdas.</p>
<p>Ejemplo mínimo:</p>
<pre><code class="language-javascript">import vtk
import meshtools
</code></pre>
<pre><code class="language-javascript">var m1 = LineMesh(fn (t) [t,0,0], -1..1:2)
</code></pre>
<pre><code class="language-javascript">var vtkE = VTKExporter(m1) // Exporta solo la malla 

vtkE.export("mesh.vtk")
</code></pre>
<pre><code class="language-javascript">var f1 = Field(m1, fn(x,y,z) x)
</code></pre>
<pre><code class="language-javascript">var g1 = Field(m1, fn(x,y,z) Matrix([x,2*x,3*x]))
</code></pre>
<pre><code class="language-javascript">vtkE = VTKExporter(f1, fieldname="f") // Exportación de los campos 
</code></pre>
<pre><code class="language-javascript">vtkE.addfield(g1, fieldname="g")
</code></pre>
<pre><code class="language-javascript">vtkE.export("data.vtk")
</code></pre>
<h2 id="vtkimporter"><a class="header" href="#vtkimporter">VTKImporter</a></h2>
<p>Esta clase se puede utilizar para importar los campos y/o la malla en un estado determinado desde un único archivo .vtk. Para usarlo, importe el módulo <code>vtk</code>:</p>
<pre><code class="language-javascript">import vtk
</code></pre>
<p>Inicialice el <code>VTKImporter</code> con el nombre del archivo</p>
<pre><code class="language-javascript">var vtkI = VTKImporter(“output.vtk")
</code></pre>
<p>Utilice el método <code>mesh</code> para obtener la malla:</p>
<pre><code class="language-javascript">var mesh = vtkI.mesh()
</code></pre>
<p>Utilice el método <code>field</code> para obtener el campo:</p>
<pre><code class="language-javascript">var f = vtkI.field(fieldname)
</code></pre>
<p>Utilice el método <code>fieldlist</code> para obtener la lista de los nombres de los campos contenidos en el archivo:</p>
<pre><code class="language-javascript">print vtkI.fieldlist()
</code></pre>
<p>Utilice el método <code>containsfield</code> para comprobar si el archivo contiene un campo por un <code>fieldname</code> determinado:</p>
<pre><code class="language-javascript">if (tkI.containsfield(fieldname)) {
    ... 
}
</code></pre>
<p>donde <code>fieldname</code> es el nombre asignado al campo en el archivo .vtk</p>
<p>Ejemplo mínimo:</p>
<pre><code class="language-javascript">import vtk
import meshtools 
</code></pre>
<pre><code class="language-javascript">var vtkI = VTKImporter("data.vtk")
</code></pre>
<pre><code class="language-javascript">var m = vtkI.mesh()
</code></pre>
<pre><code class="language-javascript">var f = vtkI.field("f")
</code></pre>
<pre><code class="language-javascript">var g = vtkI.field("g")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="acerca-de-esta-versión-en-línea"><a class="header" href="#acerca-de-esta-versión-en-línea">Acerca de esta versión en línea</a></h1>
<p>Esta es una conversión del manual <a href="https://github.com/Morpho-lang/morpho">Morpho</a> del <a href="https://github.com/Morpho-lang/morpho-manual">LyX/TeX</a> original a un formato 'mdBook'.</p>
<p><em>Morpho</em> está diseñado por el Prof. Timothy J. Atherton en la Universidad de Tufts. Esta conversión es mi trabajo de pasatiempo realizado durante mi tiempo en Tufts como becario postdoctoral con él.</p>
<p>Estos son mis pocos objetivos de diseño para esta conversión. Algunos ya se cumplen, otros son un trabajo en progreso:</p>
<ul>
<li>Reproducir fielmente todo el contenido del manual (hecho)</li>
<li>Enfatizar la accesibilidad, especialmente del contenido matemático (wip)</li>
<li>Garantice una fácil ampliación en el futuro agilizando la automatización. (¡Algunas partes no están muy optimizadas en este momento!)</li>
</ul>
<p>Encontré 'mdBook' muy fácil de usar y pude configurar el sitio web básico sin ningún uso de HTML / CSS. Estoy abierto a sugerencias para trasladar esto a otra herramienta.</p>
<p>Para construir el libro, necesitas tener <a href="https://github.com/rust-lang/mdBook">'mdbook'</a> instalado. Puedes instalarlo con 'cargo':</p>
<pre><code class="language-bash">cargo install mdbook
</code></pre>
<p>A continuación, debe generar las figuras y la sección de referencia ejecutando el script 'build.py':</p>
<pre><code class="language-bash">python build.py
</code></pre>
<p>(Asegúrese de cambiar la ruta <code>libmorphofolder</code> a su carpeta libmorpho local en el script <code>build.py</code>. En el futuro, descargaremos automáticamente la ayuda de GitHub.)</p>
<p>Por último, puedes construir el libro ejecutando <code>mdbook</code>:</p>
<pre><code class="language-bash">mdbook build
</code></pre>
<p>Esto generará los archivos HTML en el directorio <code>book</code>. Puede ver el libro abriendo el archivo <code>index.html</code> en su navegador.</p>
<p>Para obtener una vista previa del libro, puede ejecutar el siguiente comando:</p>
<pre><code class="language-bash">mdbook serve --open
</code></pre>
<h2 id="directrices-de-creación"><a class="header" href="#directrices-de-creación">Directrices de creación</a></h2>
<p>Las pautas generales para escribir un libro con <code>mdBook</code> se pueden encontrar en su <a href="https://rust-lang.github.io/mdBook/index.html">guía del usuario</a>.</p>
<p>Las ecuaciones se manejan usando MathJax ligeramente modificado:</p>
<ul>
<li>
<p>Las ecuaciones en línea están delimitadas por <code>\\(</code> y <code>\\)</code> (igual que <code>mdBook</code> por defecto).</p>
</li>
<li>
<p>Las ecuaciones de bloques están delimitadas por <code>$$</code> y <code>$$</code>.</p>
</li>
<li>
<p>La numeración automática y el soporte de referencias cruzadas son limitados, la numeración no incluye los números de capítulo y sección, y las referencias cruzadas se limitan a un solo archivo <code>.md</code>.</p>
<ul>
<li>El etiquetado de una ecuación es el mismo que en TeX:</li>
</ul>
<pre><code>    $$
    \begin{equation}
    y = m x + c
    \label{eq:linear}
    \end{equation}
    $$
</code></pre>
<ul>
<li>Las referencias cruzadas dentro del documento se pueden realizar mediante <code>\eqref</code>:</li>
</ul>
<pre><code>    The linear equation is given by Eq. \eqref{eq:linear}.
</code></pre>
<ul>
<li>Consulte el <a href="examples/electrostatics.html">Ejemplo de electrostática</a> para obtener información sobre el uso.</li>
</ul>
</li>
<li>
<p>El código de Morpho está resaltado por sintaxis usando la sintaxis de JavaScript por ahora:</p>
</li>
</ul>
<pre><code class="language-markdown">```javascript
    var a = 1
```
</code></pre>
<p>se renderiza a</p>
<pre><code class="language-javascript">    var a = 1
</code></pre>
<h2 id="generación-de-los-archivos-markdown-a-partir-del-manual-original"><a class="header" href="#generación-de-los-archivos-markdown-a-partir-del-manual-original">Generación de los archivos MarkDown a partir del manual original</a></h2>
<p>Este mdBook fue generado por una serie de conversiones del <a href="https://github.com/Morpho-lang/morpho/blob/main/manual/src/manual.lyx">archivo original de LyX</a>.</p>
<ol>
<li>Exportar el archivo LyX como un archivo <code>.tex</code></li>
<li>Conviértalo en markdown con MathJax usando Pandoc usando el siguiente comando:</li>
</ol>
<pre><code class="language-bash">    pandoc -s -f latex -t markdown --mathjax manual.tex -o morpho-manual.md
</code></pre>
<ol start="3">
<li>Reemplace <code>$...$</code> con <code>\\(…\\)</code> dentro de este archivo MarkDown para que las matemáticas en línea sean compatibles con MathJax (utilicé un pequeño script <code>re</code> disponible en el repositorio de GitHub en <code>src/replacedollars.py</code>).</li>
</ol>
<h1 id="contribuciones"><a class="header" href="#contribuciones">Contribuciones</a></h1>
<p>¡Las contribuciones son absolutamente bienvenidas! ¡Echa un vistazo a <a href="https://github.com/joshichaitanya3/morpho-manual/issues">Issues</a> en GitHub o haz una solicitud de extracción!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
