<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Morpho Manual</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="beginning.html"><strong aria-hidden="true">1.</strong> Cover</a></li><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">2.</strong> Overview</a></li><li class="chapter-item expanded "><a href="installing_morpho.html"><strong aria-hidden="true">3.</strong> Installing Morpho</a></li><li class="chapter-item expanded "><a href="using_morpho.html"><strong aria-hidden="true">4.</strong> Using Morpho</a></li><li class="chapter-item expanded "><a href="tutorial.html"><strong aria-hidden="true">5.</strong> Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/importing_modules.html"><strong aria-hidden="true">5.1.</strong> Importing Modules</a></li><li class="chapter-item expanded "><a href="tutorial/morpho_language.html"><strong aria-hidden="true">5.2.</strong> Morpho Language</a></li><li class="chapter-item expanded "><a href="tutorial/creating_the_initial_mesh.html"><strong aria-hidden="true">5.3.</strong> Creating the initial mesh</a></li><li class="chapter-item expanded "><a href="tutorial/selections.html"><strong aria-hidden="true">5.4.</strong> Selections</a></li><li class="chapter-item expanded "><a href="tutorial/fields.html"><strong aria-hidden="true">5.5.</strong> Fields</a></li><li class="chapter-item expanded "><a href="tutorial/defining_the_problem.html"><strong aria-hidden="true">5.6.</strong> Defining the problem</a></li><li class="chapter-item expanded "><a href="tutorial/performing_the_optimization.html"><strong aria-hidden="true">5.7.</strong> Performing the optimization</a></li><li class="chapter-item expanded "><a href="tutorial/visualizing_the_results.html"><strong aria-hidden="true">5.8.</strong> Visualizing the results</a></li><li class="chapter-item expanded "><a href="tutorial/refinement.html"><strong aria-hidden="true">5.9.</strong> Refinement</a></li><li class="chapter-item expanded "><a href="tutorial/next_steps.html"><strong aria-hidden="true">5.10.</strong> Next steps</a></li></ol></li><li class="chapter-item expanded "><a href="working_with_meshes.html"><strong aria-hidden="true">6.</strong> Working with meshes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="working_with_meshes/meshgen_module.html"><strong aria-hidden="true">6.1.</strong> The meshgen module</a></li><li class="chapter-item expanded "><a href="working_with_meshes/meshtools_module.html"><strong aria-hidden="true">6.2.</strong> The meshtools module</a></li><li class="chapter-item expanded "><a href="working_with_meshes/vtk_module.html"><strong aria-hidden="true">6.3.</strong> The vtk module</a></li><li class="chapter-item expanded "><a href="working_with_meshes/merging_meshes.html"><strong aria-hidden="true">6.4.</strong> Merging meshes</a></li><li class="chapter-item expanded "><a href="working_with_meshes/slicing_meshes.html"><strong aria-hidden="true">6.5.</strong> Slicing meshes</a></li></ol></li><li class="chapter-item expanded "><a href="visualization.html"><strong aria-hidden="true">7.</strong> Visualization</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="visualization/plot_module.html"><strong aria-hidden="true">7.1.</strong> The plot module</a></li><li class="chapter-item expanded "><a href="visualization/graphics_module.html"><strong aria-hidden="true">7.2.</strong> The graphics module</a></li><li class="chapter-item expanded "><a href="visualization/povray_module.html"><strong aria-hidden="true">7.3.</strong> The povray module</a></li></ol></li><li class="chapter-item expanded "><a href="examples.html"><strong aria-hidden="true">8.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="examples/catenoid.html"><strong aria-hidden="true">8.1.</strong> Catenoid</a></li><li class="chapter-item expanded "><a href="examples/cholesteric.html"><strong aria-hidden="true">8.2.</strong> Cholesteric</a></li><li class="chapter-item expanded "><a href="examples/cube.html"><strong aria-hidden="true">8.3.</strong> Cube</a></li><li class="chapter-item expanded "><a href="examples/delaunay.html"><strong aria-hidden="true">8.4.</strong> Delaunay</a></li><li class="chapter-item expanded "><a href="examples/dla.html"><strong aria-hidden="true">8.5.</strong> DLA</a></li><li class="chapter-item expanded "><a href="examples/electrostatics.html"><strong aria-hidden="true">8.6.</strong> Electrostatics</a></li><li class="chapter-item expanded "><a href="examples/implicitmesh.html"><strong aria-hidden="true">8.7.</strong> Implicitmesh</a></li><li class="chapter-item expanded "><a href="examples/meshgen.html"><strong aria-hidden="true">8.8.</strong> Meshgen</a></li><li class="chapter-item expanded "><a href="examples/meshslice.html"><strong aria-hidden="true">8.9.</strong> Meshslice</a></li><li class="chapter-item expanded "><a href="examples/plot.html"><strong aria-hidden="true">8.10.</strong> Plot</a></li><li class="chapter-item expanded "><a href="examples/povray.html"><strong aria-hidden="true">8.11.</strong> Povray</a></li><li class="chapter-item expanded "><a href="examples/qtensor.html"><strong aria-hidden="true">8.12.</strong> QTensor</a></li><li class="chapter-item expanded "><a href="examples/thomson.html"><strong aria-hidden="true">8.13.</strong> Thomson</a></li><li class="chapter-item expanded "><a href="examples/wrap.html"><strong aria-hidden="true">8.14.</strong> Wrap</a></li></ol></li><li class="chapter-item expanded "><a href="reference.html"><strong aria-hidden="true">9.</strong> Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/language.html"><strong aria-hidden="true">9.1.</strong> Language</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/nested/syntax.html"><strong aria-hidden="true">9.1.1.</strong> Syntax</a></li><li class="chapter-item expanded "><a href="reference/nested/values.html"><strong aria-hidden="true">9.1.2.</strong> Values</a></li><li class="chapter-item expanded "><a href="reference/nested/variables.html"><strong aria-hidden="true">9.1.3.</strong> Variables</a></li><li class="chapter-item expanded "><a href="reference/nested/controlflow.html"><strong aria-hidden="true">9.1.4.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="reference/nested/functions.html"><strong aria-hidden="true">9.1.5.</strong> Functions</a></li><li class="chapter-item expanded "><a href="reference/nested/classes.html"><strong aria-hidden="true">9.1.6.</strong> Classes</a></li><li class="chapter-item expanded "><a href="reference/nested/modules.html"><strong aria-hidden="true">9.1.7.</strong> Modules</a></li><li class="chapter-item expanded "><a href="reference/nested/help.html"><strong aria-hidden="true">9.1.8.</strong> Help</a></li><li class="chapter-item expanded "><a href="reference/nested/builtin.html"><strong aria-hidden="true">9.1.9.</strong> Built-in Functions</a></li></ol></li><li class="chapter-item expanded "><a href="reference/data_types.html"><strong aria-hidden="true">9.2.</strong> Data Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/nested/array.html"><strong aria-hidden="true">9.2.1.</strong> Array</a></li><li class="chapter-item expanded "><a href="reference/nested/complex.html"><strong aria-hidden="true">9.2.2.</strong> Complex</a></li><li class="chapter-item expanded "><a href="reference/nested/list.html"><strong aria-hidden="true">9.2.3.</strong> List</a></li><li class="chapter-item expanded "><a href="reference/nested/matrix.html"><strong aria-hidden="true">9.2.4.</strong> Matrix</a></li><li class="chapter-item expanded "><a href="reference/nested/range.html"><strong aria-hidden="true">9.2.5.</strong> Range</a></li><li class="chapter-item expanded "><a href="reference/nested/sparse.html"><strong aria-hidden="true">9.2.6.</strong> Sparse</a></li><li class="chapter-item expanded "><a href="reference/nested/string.html"><strong aria-hidden="true">9.2.7.</strong> String</a></li></ol></li><li class="chapter-item expanded "><a href="reference/computational_geometry.html"><strong aria-hidden="true">9.3.</strong> Computational Geometry</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/nested/field.html"><strong aria-hidden="true">9.3.1.</strong> Field</a></li><li class="chapter-item expanded "><a href="reference/nested/functionals.html"><strong aria-hidden="true">9.3.2.</strong> Functionals</a></li><li class="chapter-item expanded "><a href="reference/nested/mesh.html"><strong aria-hidden="true">9.3.3.</strong> Mesh</a></li><li class="chapter-item expanded "><a href="reference/nested/selection.html"><strong aria-hidden="true">9.3.4.</strong> Selection</a></li></ol></li><li class="chapter-item expanded "><a href="reference/io.html"><strong aria-hidden="true">9.4.</strong> I/O</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/nested/file.html"><strong aria-hidden="true">9.4.1.</strong> File</a></li></ol></li><li class="chapter-item expanded "><a href="reference/modules.html"><strong aria-hidden="true">9.5.</strong> Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/nested/color.html"><strong aria-hidden="true">9.5.1.</strong> Color</a></li><li class="chapter-item expanded "><a href="reference/nested/delaunay.html"><strong aria-hidden="true">9.5.2.</strong> Delaunay</a></li><li class="chapter-item expanded "><a href="reference/nested/graphics.html"><strong aria-hidden="true">9.5.3.</strong> Graphics</a></li><li class="chapter-item expanded "><a href="reference/nested/implicitmesh.html"><strong aria-hidden="true">9.5.4.</strong> Implicitmesh</a></li><li class="chapter-item expanded "><a href="reference/nested/kdtree.html"><strong aria-hidden="true">9.5.5.</strong> KDTree</a></li><li class="chapter-item expanded "><a href="reference/nested/meshgen.html"><strong aria-hidden="true">9.5.6.</strong> MeshGen</a></li><li class="chapter-item expanded "><a href="reference/nested/meshslice.html"><strong aria-hidden="true">9.5.7.</strong> MeshSlice</a></li><li class="chapter-item expanded "><a href="reference/nested/meshtools.html"><strong aria-hidden="true">9.5.8.</strong> Meshtools</a></li><li class="chapter-item expanded "><a href="reference/nested/optimize.html"><strong aria-hidden="true">9.5.9.</strong> Optimize</a></li><li class="chapter-item expanded "><a href="reference/nested/plot.html"><strong aria-hidden="true">9.5.10.</strong> Plot</a></li><li class="chapter-item expanded "><a href="reference/nested/povray.html"><strong aria-hidden="true">9.5.11.</strong> POVRay</a></li><li class="chapter-item expanded "><a href="reference/nested/vtk.html"><strong aria-hidden="true">9.5.12.</strong> VTK</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Morpho Manual</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><img src="Figures/morphologo.pdf" alt="image" /></p>
<h2 id="version-057"><a class="header" href="#version-057">Version 0.5.7</a></h2>
<p><em>In nova fert animus mutatas dicere formas</em></p>
<p><em>corpora; di, coeptis (nam vos mutastis et illas)</em></p>
<p><em>adspirate meis primaque ab origine mundi</em></p>
<p><em>ad mea perpetuum deducite tempora carmen!</em></p>
<p>Ovid, <em>Metamorphoses</em></p>
<h2 id="acknowledgements" class="unnumbered"><a class="header" href="#acknowledgements">Acknowledgements</a></h2>
<p>The principal architect of <em>morpho</em>, T J Atherton, wishes to thank the
many people who have used various versions of the program or otherwise
contributed to the project:</p>
<p>Andrew DeBenedictis</p>
<p>Danny Goldstein</p>
<p>Ian Hunter</p>
<p>Chaitanya Joshi</p>
<p>Cole Wennerholm</p>
<p>Eoghan Downey</p>
<p>Allison Culbert</p>
<p>Abigail Wilson</p>
<p>Zhaoyu Xie</p>
<p>Matthew Peterson</p>
<p>Chris Burke</p>
<p>Badel Mbanga</p>
<p>Anca Andrei</p>
<p>Mathew Giso</p>
<p>Sam Hocking</p>
<p>Emmett Hamilton</p>
<p>Hudson Ramirez</p>
<p>Paco Navarro</p>
<p><em>This material is based upon work supported by the National Science
Foundation under grants DMR-1654283 and OAC-2003820.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p><em>Morpho</em> aims to solve the following class of problems. Consider a
functional,
$$F=\int_{C}f(q,\nabla q,\nabla^{2}q,...)d^{n}x+\int_{\partial C}g(q,\nabla q,\nabla^{2}q,...)d^{n-1}x,$$
where \(q\) represents a set of fields defined on a manifold \(C\) that
could include scalar, vector, tensor or other quantities and their
derivatives \(\nabla^{n}q\). The functional includes terms in the bulk and
on the boundary \(\partial C\) and might also include geometric properties
of the manifold such as local curvatures. This functional is to be
minimized from an initial guess \( \{ C_{0},q_{0} \}\) with
respect to the fields \(q\) and the shape of the manifold \(C\). Global and
local constraints may be imposed both on \(C\) and \(q\).</p>
<p><em>Morpho</em> is an object-oriented environment: all components of the
problem, including the computational domain, fields, functionals etc.
are all represented as objects that interact with one another. Much of
the effort in writing a <em>morpho</em> program involves creating and
manipulating these objects. The environment is flexible, modular, and
users can easily create new kinds of object, or entirely change how
<em>morpho</em> works.</p>
<p>This manual aims to help users to learn to use <em>morpho</em>. It provides
installation instructions in Chapter
<a href="overview.html#chap:Installing-Morpho">[chap:Installing-Morpho]</a>{reference-type="ref"
reference="chap:Installing-Morpho"}, information about how to run the
program in Chapter
<a href="overview.html#chap:Using-Morpho">[chap:Using-Morpho]</a>{reference-type="ref"
reference="chap:Using-Morpho"}. A detailed tutorial is provided in
Chapter <a href="overview.html#chap:Tutorial">[chap:Tutorial]</a>{reference-type="ref"
reference="chap:Tutorial"} showing how to set up and solve an example
problem. Chapter
<a href="overview.html#chap:Working-with-Meshes">[chap:Working-with-Meshes]</a>{reference-type="ref"
reference="chap:Working-with-Meshes"} provides information about working
with meshes and Chapter
<a href="overview.html#chap:Visualization">[chap:Visualization]</a>{reference-type="ref"
reference="chap:Visualization"} describes how to visualize the results
of your calculation with <em>morpho</em>. The examples provided with morpho are
described in Chapter
<a href="overview.html#chap:Examples">[chap:Examples]</a>{reference-type="ref"
reference="chap:Examples"}. The remaining chapters, comprising the
second part of the manual, provide a reference guide for all areas of
<em>morpho</em> functionality.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-morpho"><a class="header" href="#installing-morpho">Installing <em>Morpho</em></a></h1>
<p><em>Morpho</em> is hosted on a publicly available github repository
<a href="https://github.com/Morpho-lang/morpho">https://github.com/Morpho-lang/morpho</a>. We are continuously working on
improving <em>morpho</em> installation. With this release, <em>morpho</em> on macOS
now has a streamlined installation process using homebrew. Other
platforms must be installed from source and we hope to provide packages
for future releases. Instructions for different platforms are provided
below.</p>
<h3 id="where-morpho-installation-puts-things"><a class="header" href="#where-morpho-installation-puts-things">Where <em>morpho</em> installation puts things</a></h3>
<p>A <em>morpho</em> installation includes help files, modules, and other
resources. By default, these are installed in the <strong>/usr/local/</strong> file
structure<sup class="footnote-reference"><a href="#1">1</a></sup>, including in the following places:</p>
<p><strong>/usr/local/bin</strong> : The morpho and morphoview executables are placed here.</p>
<p><strong>/usr/local/share/morpho</strong> : Help files and modules are stored here.</p>
<p><strong>/usr/local/include/morpho</strong> : Morpho header files for building extensions.</p>
<p><strong>/usr/local/lib/morpho</strong> : Morpho extensions.</p>
<p>It's possible to build <em>morpho</em> to use different locations for resources
and the binary. To do so, set the <code>MORPHORESOURCESDIR</code> option when you
run make, e.g.</p>
<pre><code>sudo make MORPHORESOURCESDIR=X install
</code></pre>
<p>where X is the base folder you wish to use, i.e. the replacement for
<strong>/usr/local</strong>. Subfolders will be created by the installer. To control
where the <em>morpho</em> binary is placed, also set the <code>DESTDIR</code> option,</p>
<pre><code>sudo make MORPHORESOURCESDIR=X DESTDIR=Y install
</code></pre>
<h3 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h3>
<p><em>Morpho</em> leverages a few libraries to provide certain functionality:</p>
<p><strong>glfw</strong> : is used to provide gui functionality for an interactive visualization application, <code>morphoview</code>.</p>
<p><strong>blas/lapack</strong> : are used for dense linear algebra.</p>
<p><strong>suitesparse</strong> : is used for sparse linear algebra[^2].</p>
<p><strong>freetype</strong> : provides text display.</p>
<p><strong>povray</strong> : is a ray-tracer that is used for publication-quality graphics.</p>
<h3 id="macos"><a class="header" href="#macos">macOS</a></h3>
<p>The recommended approach to installing morpho on macOS is to use the
<a href="https://brew.sh">Homebrew</a> package manager.</p>
<ol>
<li>
<p>If you have a previous installation of morpho, we recommend you
remove it by following the instructions for uninstalling <em>morpho</em>
below.</p>
</li>
<li>
<p>Install <a href="https://brew.sh">Homebrew</a>, following instructions on the
homebrew site.</p>
</li>
<li>
<p>In the terminal type:</p>
<pre><code>brew update
brew tap morpho-lang/morpho
brew install morpho
</code></pre>
<p>You may be prompted by homebrew to install additional components.
For some users, it may be necessary to install XCode from the App
Store.</p>
</li>
<li>
<p>We also recommend that you obtain the morpho git repository, because
it contains the manual, examples and other useful materials that
aren't installed by homebrew.</p>
<pre><code>git clone https://github.com/Morpho-lang/morpho.git
</code></pre>
</li>
</ol>
<h3 id="macos-manual-installation"><a class="header" href="#macos-manual-installation">macOS (Manual Installation)</a></h3>
<p>If you ever need to do a manual installation, for example if you want to
use the cutting edge <code>dev</code> branch of morpho, you should follow these
instructions. If you have an Intel mac, you should omit the
<code>-f Makefile.m1</code> flags in the make command below. Note also that some
users may need to preface</p>
<pre><code>make install
</code></pre>
<p>with the sudo command:</p>
<pre><code>sudo make install
</code></pre>
<ol>
<li>
<p>Install the <a href="https://brew.sh">Homebrew</a> package manager, following
instructions on the homebrew site.</p>
</li>
<li>
<p><strong>If you previously installed morpho using homebrew, you must first
remove it. This step is vitally important as the two installed
versions may cause conflicts.</strong></p>
<pre><code>brew uninstall morpho
</code></pre>
</li>
<li>
<p>Install dependencies. Open the Terminal application and type:</p>
<pre><code>brew update
brew install glfw suite-sparse freetype povray
</code></pre>
</li>
<li>
<p>Obtain the source by cloning the github public repository:</p>
<pre><code>git clone https://github.com/Morpho-lang/morpho.git
</code></pre>
</li>
<li>
<p>Navigate to the <code>morpho5</code> folder within the downloaded repository
and build the application[^3]</p>
<pre><code>cd morpho/morpho5
make -f Makefile.m1 install
</code></pre>
</li>
<li>
<p>Navigate to the <code>morphoview</code> folder and build the viewer application</p>
<pre><code>cd morpho/morphoview
make -f Makefile.m1 install
</code></pre>
</li>
<li>
<p>Check that the application works by typing</p>
<pre><code>morpho5
</code></pre>
</li>
</ol>
<p><strong>If you wish to switch back to a homebrew install, follow the
instructions below to uninstall morpho to prevent version conflicts.</strong></p>
<h3 id="linux"><a class="header" href="#linux">Linux</a></h3>
<p>Building on Linux is similar to the macOS manual install. Here we give
commands for Ubuntu, which uses the <code>apt</code> package manager. On other
distributions you will need to find the equivalent packages.</p>
<ol>
<li>
<p>Make sure your version of apt is up to date.</p>
<pre><code>sudo apt update
sudo apt upgrade
</code></pre>
</li>
<li>
<p>Ensure you have basic developer tools installed. Some distributions
omit these to save space.</p>
<pre><code>sudo apt install build-essential
</code></pre>
</li>
<li>
<p>Install <em>morpho</em>'s dependencies using your distribution's package
manager (or manually if you prefer):</p>
<pre><code>sudo apt install libglfw3-dev libsuitesparse-dev liblapacke povraylibfreetype6-dev
</code></pre>
</li>
<li>
<p>Obtain the source by cloning the github public repository:</p>
<pre><code>git clone https://github.com/Morpho-lang/morpho.git
</code></pre>
</li>
<li>
<p>Navigate to the <code>morpho5</code> folder within the downloaded repository
and build the application:</p>
<pre><code>cd morpho/morpho5
sudo make -f Makefile.linux install
</code></pre>
</li>
<li>
<p>Navigate to the <code>morphoview</code> folder and build the viewer
application:</p>
<pre><code>cd ../morphoview
sudo make -f Makefile.linux install
</code></pre>
</li>
<li>
<p>Check that the application works by typing</p>
<pre><code>morpho5
</code></pre>
</li>
</ol>
<h3 id="windows-via-windows-subsystem-for-linux-wsl"><a class="header" href="#windows-via-windows-subsystem-for-linux-wsl">Windows via Windows Subsystem for Linux (WSL)</a></h3>
<h4 id="install-wsl"><a class="header" href="#install-wsl">Install WSL</a></h4>
<p>If you don't have WSL2 installed on your Windows computer, <a href="https://ubuntu.com/tutorials/install-ubuntu-on-wsl2-on-windows-11-with-gui-support#1-overview">follow the
instructions to install the Ubuntu
App</a>.
Follow all the steps in this link to ensure that graphics are working.</p>
<h4 id="install-morpho"><a class="header" href="#install-morpho">Install Morpho</a></h4>
<p>Once the Ubuntu terminal is working in Windows, you can install <em>morpho</em>
the same way as in Linux by running the commands in the instructions in
the Ubuntu terminal.</p>
<p><strong>If you are using WSL2, then the installation is complete.</strong></p>
<h4 id="graphics-on-wsl1"><a class="header" href="#graphics-on-wsl1">Graphics On WSL1</a></h4>
<p>If you instead are working on WSL1, then you need to follow these
instructions to get graphics running. Unless mentioned otherwise, all
the commands below are run in the Ubuntu terminal.</p>
<ol>
<li>
<p>A window manager must be installed so that the WSL can create
windows. On Windows, install
<a href="https://sourceforge.net/projects/vcxsrv/">VcXsrv</a>. It shows up as
XLaunch in the Windows start menu.</p>
</li>
<li>
<p>Open Xlaunch. Then,</p>
<ol>
<li>
<p>choose 'Multiple windows', set display number to 0, and hit
'Next'</p>
</li>
<li>
<p>choose 'start no client' and hit 'Next'</p>
</li>
<li>
<p><strong>Unselect</strong> 'native opengl' and hit 'Next'</p>
</li>
<li>
<p>Hit 'Finish'</p>
</li>
</ol>
</li>
<li>
<p>In Ubuntu download a package containing a full suite of desktop
utilities that allows for the use of windows.</p>
<pre><code>sudo apt install ubuntu-desktop mesa-utils
</code></pre>
<p>Tell ubuntu which display to use</p>
<pre><code>export DISPLAY=localhost:0
</code></pre>
<p>To set the DISPLAY variable on login type</p>
<pre><code>echo export DISPLAY=localhost:0 &gt;&gt; ~/.bashrc 
</code></pre>
<p><em>[Note that this assumes you are using bash as your terminal; you
will may to adjust this line for other terminals].</em></p>
</li>
<li>
<p>Test that the window system is working by running</p>
<pre><code>glxgears
</code></pre>
<p>which should open a window with some gears.</p>
</li>
<li>
<p><strong>Test the thomson example program.</strong> Navigate to the thomson
example in the examples directory and run it. If you are in the
<code>morphoview</code> directory.</p>
<pre><code>cd ../examples/thomson
morpho5 thomson.morpho
</code></pre>
<p>This example starts with randomly distributed charges on a sphere
and minimizing electric potential. It should generate an interactive
figure of points on a sphere.</p>
</li>
</ol>
<h3 id="updating-morpho"><a class="header" href="#updating-morpho">Updating <em>morpho</em></a></h3>
<p>As new versions of <em>morpho</em> are released, you will likely want to
upgrade to the latest version. From the terminal:</p>
<ul>
<li>
<p>If you used homebrew to install morpho, simply type,</p>
<pre><code>brew upgrade morpho
</code></pre>
</li>
<li>
<p>If you installed <em>morpho</em> manually, and still have the git
repository folder on your computer, navigate to this with <code>cd</code> and
type,</p>
<pre><code>git pull
</code></pre>
<p>which downloads any updates. You can then follow the above
instructions to recompile <em>morpho.</em> It's not necessary to reinstall
dependencies, but note that some new releases of <em>morpho</em> may
require additional dependencies.</p>
</li>
<li>
<p>If you no longer have the original <em>morpho</em> git repository folder
from which you installed morpho, simply rerun the installation from
scratch as above. You shouldn't need to reinstall dependencies.</p>
</li>
</ul>
<h3 id="uninstalling-morpho"><a class="header" href="#uninstalling-morpho">Uninstalling <em>morpho</em></a></h3>
<p>If you wish to uninstall morpho, you can do so simply from the terminal
application.</p>
<ul>
<li>
<p>If you used homebrew to install morpho, simply type</p>
<pre><code>brew uninstall morpho
</code></pre>
</li>
<li>
<p>Alternatively, if you did a manual install, you can remove
everything with</p>
<pre><code>rm /usr/local/bin/morpho
rm /usr/local/bin/morphoview
rm -r /usr/local/share/morpho
rm -r /usr/local/lib/morpho
</code></pre>
<p>You may need to prefix these with <code>sudo</code>.</p>
</li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>On the macOS, these files are contained within the homebrew system</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-morpho"><a class="header" href="#using-morpho">Using <em>Morpho</em></a></h1>
<p><em>Morpho</em> is a command line application, like <code>python</code> or <code>lua</code>. It can
be used to run scripts or programs, which are generally given the
<em>.morpho</em> file extension, or run interactively responding to user
commands.</p>
<h2 id="running-a-program"><a class="header" href="#running-a-program">Running a program</a></h2>
<p>To run a program, simply run morpho with the name of the file,</p>
<pre><code>morpho5 script.morpho
</code></pre>
<p><em>Morpho</em> supports a number of switches:</p>
<p>-w</p>
<p>:   Run <em>morpho</em> with more than one worker thread, e.g. <code>-w 4</code> runs
morpho with 4 threads.</p>
<p>-D</p>
<p>:   Display disassembly of the program without running it. <em>[See
developer guide]</em></p>
<p>-d</p>
<p>:   Debugging mode. Morpho will stop and enter the debugger whenever a
<code>@</code> is encountered in the source. <em>[See developer guide]</em></p>
<p>-p</p>
<p>:   Profile the program execution. Useful to identify performance
bottlenecks. <em>[See developer guide]</em></p>
<h2 id="interactive-mode"><a class="header" href="#interactive-mode">Interactive mode</a></h2>
<p>To use <em>morpho</em> interactively, simply load the <em>Terminal</em> application
(or equivalent on your system) and type</p>
<pre><code>morpho5
</code></pre>
<h4 id="command-line-interface-for-morpho"><a class="header" href="#command-line-interface-for-morpho">Command line interface for Morpho</a></h4>
<p><img src="./Figures/commandline.jpg" alt="Command line interface for Morpho" /></p>
<p>As shown in the figure above, (Fig. <a href="using_morpho.html#Command-line-interface-for-Morpho">fig:cli</a>), you'll be greeted by a brief welcome and a
prompt &gt; inviting you to enter <em>morpho</em> commands. For now, try a
classic:</p>
<pre><code>print "Hello World"
</code></pre>
<p>which will display <code>Hello World</code> as output. More information about the
<em>morpho</em> language is provided in the Reference section, especially
chapter <a href="./reference/language.html">Language</a> if you're familiar with C-like languages
such as C, C++, Java, Javascript, etc. things should be quite familiar.</p>
<p>To assist the user, the contents of the reference manual are available
to the user in interactive mode as online help. To get help, simply
type:</p>
<pre><code>help
</code></pre>
<p>or even more briefly,</p>
<pre><code>?
</code></pre>
<p>to see the list of main topics. To find help on a particular topic, for
example <code>for</code> loops, simply type the topic name afterwards:</p>
<pre><code>? for
</code></pre>
<p>Once you're done using <em>morpho</em>, simply type</p>
<pre><code>quit
</code></pre>
<p>to exit the program and return to the shell.</p>
<p>The interactive environment has a few other useful features to assist
the user:</p>
<ul>
<li>
<p><strong>Autocomplete.</strong> As you type, <em>morpho</em> will show you any suggested
commands that it thinks you're trying to enter. For example, if you
type <code>v</code> the command line will show the <code>var</code> keyword. To accept the
suggestion, press the tab key. Multiple suggestions may be
available; use the up and down arrow keys to rotate through them.</p>
</li>
<li>
<p><strong>Command history.</strong> Use the arrow keys to retrieve previously
entered commands. You may then edit them before running them.</p>
</li>
<li>
<p><strong>Line editing.</strong> As you're typing a command, use the left and right
arrows to move the cursor around; you can insert new characters at
the cursor just by typing them or delete characters with the
<code>delete</code> key. Hold down the <code>shift</code> key as you use the left and
right arrow keys to select text; you can then use<code> Ctrl-C</code> to copy
and <code>Ctrl-V</code> to paste. <code>Ctrl-A</code> moves to the start of the line and
<code>Ctrl-E</code> the end.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial"><a class="header" href="#tutorial">Tutorial</a></h1>
<p>To illustrate how to use <em>morpho</em>, we will solve a problem involving
nematic liquid crystals (NLCs), fluids composed of long, rigid molecules
that possess a local average molecular orientation described by a unit
vector field \(\mathbf{\hat{n}}\). Droplets of NLC immersed in a host
isotropic fluid such as water are called <em>tactoids</em> and, unlike droplets
of, say, oil in water that form spheres, tactoids can adopt elongated
shapes.</p>
<p>The functional to be minimized, the free energy of the system, is quite
complex, $$\begin{array}{c}
F=\
\
\end{array}\begin{array}{c}
\underbrace{\frac{1}{2}\int_{C}K_{11}\left(\nabla\cdot\mathbf{n}\right)^{2}+K_{22}(\mathbf{n}\cdot\nabla\times\mathbf{n})^{2}+K_{33}\left|\mathbf{n}\times\nabla\times\mathbf{n}\right|^{2}dA}\
\text{Liquid crystal elastic energy}
\end{array}\begin{array}{c}
+\
\
\end{array}\begin{array}{c}
\underbrace{\sigma\int dl}\
s.t.
\end{array}\begin{array}{c}
-\
\
\end{array}\begin{array}{c}
\underbrace{\frac{W}{2}\int\left(\mathbf{n}\cdot\mathbf{t}\right)^{2}dl}\
\text{anchoring}
\end{array}\label{eq:free}$$</p>
<p>where the three terms include <strong>liquid
crystal elasticity</strong> that drives elongation of the droplet, <strong>surface
tension</strong> <em>(s.t.)</em> that opposes lengthening of the boundary and an
<strong>anchoring term</strong> that imposes a preferred orientation at the boundary.
We need a local constraint, \(\mathbf{n}\cdot\mathbf{n}=1\), and will also
impose a constraint on the volume of the droplet. For simplicity, we'll
solve this problem in 2D. The complete code for this tutorial example is
contained in the <code>examples/tactoid</code> folder in the repository.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="importing-modules"><a class="header" href="#importing-modules">Importing modules</a></h2>
<p><em>Morpho</em> is a modular system and hence we typically begin our program by
telling <em>morpho</em> the modules we need so that they're available for us to
use. To do so, we use the <code>import</code> keyword followed by the name of the
module:</p>
<pre><code class="language-javascript">    import meshtools
    import optimize
    import plot
</code></pre>
<p>We can also use the <code>import</code> keyword to import additional program files
to assist in modularizing large programs. These are the modules we'll
use for this example:</p>
<div class="table-wrapper"><table><thead><tr><th>Module</th><th>Purpose</th></tr></thead><tbody>
<tr><td><code>meshtools</code></td><td>Utility code to create and refine meshes</td></tr>
<tr><td><code>optimize</code></td><td>Perform optimization</td></tr>
<tr><td><code>plot</code></td><td>Visualize results</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="morpho-language"><a class="header" href="#morpho-language">Morpho language</a></h1>
<figure id="fig:Postcard">
<div class="centering">
<embed src="Figures/postcard.pdf" style="width:8in" />
</div>
<figcaption><span id="fig:Postcard"
label="fig:Postcard"></span>Postcard-sized summary of the
<em>morpho</em> language. </figcaption>
</figure>
<p>The <em>morpho</em> language is simple but expressive. If you're familiar with
C-like languages (C, C++, Java, Javascript) you'll find it very natural.
A much more detailed description is provided in Chapter
<a href="tutorial/../reference/language.html">Language</a>, but a brief summary is provided in the above figure and we provide an overview of key ideas to help you follow the tutorial:</p>
<ul>
<li>
<p><strong>Comments.</strong> Any text after <code>//</code> or surrounded by <code>/``*</code> and <code>*``/</code>
is a comment and not processed by morpho:</p>
<pre><code>// This is a comment
/* This too! */
</code></pre>
</li>
<li>
<p><strong>Variables.</strong> To create a variable, use the <code>var</code> keyword; you can
then assign and use the variable arbitrarily:</p>
<pre><code>var a = 1
print a
</code></pre>
</li>
<li>
<p><strong>Functions.</strong> Functions may take parameters, and you call them like
this:</p>
<pre><code>print sin(x)
</code></pre>
<p>and declare them like this:</p>
<pre><code>fn f(x,y) {
    return x^2+y^2
}
</code></pre>
<p>Some functions take optional arguments, which look like this:</p>
<pre><code>var a = foo(quiet=true)
</code></pre>
</li>
<li>
<p><strong>Objects.</strong> <em>Morpho</em> is deeply object-oriented. Most things in
morpho are represented as objects, which provide <em>methods</em> that you
can use to control them. Objects are made by <em>constructor functions</em>
that begin with a capital letter (and may take arguments):</p>
<pre><code>var a = Object()
</code></pre>
<p>Method calls then look like this:</p>
<pre><code>a.foo()
</code></pre>
</li>
<li>
<p><strong>Collections.</strong> <em>Morpho</em> provides a number of collection typesall
of which are objectsincluding Lists,</p>
<pre><code>var a = [1,2,3]
</code></pre>
<p>and Dictionaries:</p>
<pre><code>var b = { "Massachusetts": "Boston", "California": "Sacramento" }
</code></pre>
<p>and Ranges (often used in loops):</p>
<pre><code>var a = 0..10:2 # all even numbers 0-10 inclusive
</code></pre>
<p>There are many others, including Matrices, Sparse matrices, etc.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="creating-the-initial-mesh"><a class="header" href="#creating-the-initial-mesh">Creating the initial mesh</a></h2>
<figure id="fig:Mesh">
<div class="centering">
<p><img src="tutorial/../Figures/Tutorial/0ExampleMesh/meshgrade0.png" style="width:2in"
alt="image" /><img src="tutorial/../Figures/Tutorial/0ExampleMesh/meshgrade1.png"
style="width:2in" alt="image" /><img
src="../Figures/Tutorial/0ExampleMesh/meshgrade2.png" style="width:2in"
alt="image" /></p>
</div>
<figcaption><span id="fig:Mesh" label="fig:Mesh"></span>A <em>Mesh</em>
object contains different kinds of element. In this example, the mesh
contains points, lines and area elements referred to by their
<em>grade</em>.</figcaption>
</figure>
<p>Meshes are discretized regions of space. The very simplest region we can
imagine is a <em>point</em> or <em>vertex</em> described by a set of coordinates
\((x_{1},x_{2},....,x_{D})\) where the number of coordinates \(D\) defines
the dimensionality of the space that the manifold is said to be
<em>embedded</em> in. From more than one point, we can start constructing more
complex regions. First, between two points we can imagine fixing an
imaginary ruler and drawing a straight line or <em>edge</em> between them.
Three points define a plane, and also a triangle; we can therefore
identify the two dimensional area of the plane bounded by the triangle
as a <em>face</em>, as in the face of a polyhedron. Using four points, we can
define the volume bounded by a tetrahedron. Each of these <strong>elements</strong>
has a different dimensionalitycalled a <em>grade</em>and a complete <code>Mesh</code> may
contain elements of many different grades as shown in Fig.
<a href="tutorial/creating_the_initial_mesh.html#fig:Mesh">4.2</a>.</p>
<p><em>Morpho</em> provides a number of ways of creating a mesh. One can load a
mesh from a file, build one manually from a set of points, create one
from a polyhedron, or from the level set (contours) of a function.</p>
<p>For this example, we'll use a predefined mesh file <code>disk.mesh</code>. To
create a Mesh object from this file, we call the <em>Mesh</em> function with
the file name:</p>
<pre><code class="language-javascript">var m = Mesh("disk.mesh")
</code></pre>
<p>Here, the <strong>var</strong> keyword tells morpho to create a new variable <em>m</em>,
which now refers to the newly created <em>Mesh</em> object.</p>
<figure id="fig:InitialMesh">
<div class="centering">
<img src="tutorial/../Figures/Tutorial/1Mesh/mesh.png" style="width:3.5in" />
</div>
<figcaption><span id="fig:InitialMesh"
label="fig:InitialMesh"></span>The initial mesh, loaded from
<code>disk.mesh</code>.</figcaption>
</figure>
<p>The initial mesh is
depicted in Fig. <a href="tutorial/creating_the_initial_mesh.html#fig:InitialMesh">4.3</a>; we'll provide the code to perform the
visualization in section
<a href="tutorial/./visualizing_the_results.html">Visualizing the results</a>.</p>
<p>If you open the file <code>disk.mesh</code>, which you can find in the same folder
as <code>tactoid.morpho</code>, you'll find it has a simple human readable format:</p>
<pre><code>vertices

1 -1. 0. 0 
2 -0.951057 -0.309017 0
...

edges
1 8 2 
2 2 4
...

faces
1 8 2 4 
2 8 4 6
...
</code></pre>
<p>The file is broken into sections, each describing elements of a
different grade. Each line begins either with a section delimiter such
as <em>vertices</em>, <em>edges</em> or <em>faces</em>, or with an id. Vertices are then
defined by a set of coordinates; edges and faces are defined by
providing the respective vertex ids.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="selections"><a class="header" href="#selections">Selections</a></h2>
<p>Sometimes, we want to refer to specific parts of a <code>Mesh</code> object:
elements that match some criterion, for example. <code>Selection</code> objects
enable us to do this. Because selecting the boundary is a very common
activity, the <code>Selection</code> constructor function takes an optional
argument to do this:</p>
<pre><code>var bnd=Selection(m, boundary=true)
</code></pre>
<p>By default, only the boundary elements are included in the <code>Selection</code>.
For a mesh with at most grade 2 elements (facets), the boundaries are
grade 1 elements (lines); for a mesh with grade 3 elements (volumes),
the boundaries are grade 2 elements (facets). Quite often we want the
vertices themselves as well, so we can call a method to achieve that:</p>
<pre><code>bnd.addgrade(0)
</code></pre>
<p>Once a <code>Selection</code> has been created, it can be helpful to visualize it
to ensure the correct elements are selected. We'll talk more about
visualization in section
<a href="tutorial/./visualizing_the_results.html">Visualizing Results</a>, but for now the line</p>
<pre><code>Show(plotselection(m, bnd, grade=1))
</code></pre>
<p>shows a visualization of the mesh with the selected grade 1 elements
shaded red as displayed in Fig.
<a href="tutorial/selections.html#fig:Boundary">4.4</a>{reference-type="ref" reference="fig:Boundary"}.</p>
<p><img src="tutorial/../Figures/Tutorial/2Visualize/selection.png" alt="Selection" />
<em>Selecting the boundary of the mesh</em></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="fields"><a class="header" href="#fields">Fields</a></h2>
<p>Having created our initial computational domain, we will now create a
<code>Field</code> object representing the director field \(\mathbf{n}\):</p>
<pre><code>var nn = Field(m, Matrix([1,0,0]))
</code></pre>
<p>As with the <code>Mesh</code> object earlier, we declare a variable, <em>nn</em>, to refer
to the <code>Field</code> object. We have to provide two arguments to <code>Field</code>: the
<code>Mesh</code> object on which the <code>Field</code> is defined, and something to
initialize it. Here, we want the initial director to have a spatially
uniform value, so we can just provide <code>Field</code> a constant <code>Matrix</code>
object. By default, <em>morpho</em> stores a copy of this matrix on each vertex
in the mesh; Fields can however store information on elements of any
grade (and store both more than one quantity per grade and information
on multiple grades at the same time).</p>
<p>It's possible to initialize a <code>Field</code> with spatially varying values by
providing an <em>anonymous function</em> to <code>Field</code> like this:</p>
<pre><code>var phi = Field(m, fn (x,y,z) x^2+y^2)
</code></pre>
<p>Here, <em>phi</em> is a scalar field that takes on the value \(x^{2}+y^{2}\). The
<strong>fn</strong> keyword is used to define functions.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="defining-the-problem"><a class="header" href="#defining-the-problem">Defining the problem</a></h2>
<p>We now turn to setting up the problem. Each term in the energy
functional (<a href="tutorial/defining_the_problem.html#eq:free">[eq:free]</a>) is represented by a corresponding <em>functional</em>
object, which acts on a <code>Mesh</code> (and possibly a <code>Field</code>) to calculate an
integral quantity such as an energy; Functional objects are also
responsible for calculating gradients of the energy with respect to
vertex positions and components of Fields.</p>
<p>Let's take the terms in (<a href="tutorial/defining_the_problem.html#eq:free">[eq:free]</a>{reference-type="ref"
reference="eq:free"}) one by one: To represent the nematic elasticity we
create a <code>Nematic</code> object:</p>
<pre><code>var lf=Nematic(nn)
</code></pre>
<p>The surface tension term involves the length of the boundary, so we need
a <code>Length</code> object:</p>
<pre><code>var lt=Length()
</code></pre>
<p>The anchoring term doesn't have a simple built in object type, but we
can use a general <code>LineIntegral</code> object to achieve the correct result.</p>
<pre><code>var la=LineIntegral(fn (x, n) n.inner(tangent())^2, nn)
</code></pre>
<p>Notice that we have to supply a functionthe integrandwhich will be
called by <code>LineIntegral</code> when it evaluates the integral. Integrand
functions are called with the local coordinates first (as a <code>Matrix</code>
object representing a column vector) and then the local interpolated
value of any number of <code>Fields</code>. We also make use of the special
function <code>tangent()</code> that locally returns a local tangent to the line.</p>
<p>We also need to impose constraints. Any <em>functional</em> object can be used
equally well as an energy or a constraint, and hence we create a
<code>NormSq</code> (norm-squared) object that will be used to implement the local
unit vector constraint on the director field:</p>
<pre><code>var ln=NormSq(nn)
</code></pre>
<p>and an <code>Area</code> object for the global constraint. This is really a
constraint fixing the volume of fluid in the droplet, but since we're in
2D that becomes a constraint on the area of the mesh:</p>
<pre><code>var laa=Area()
</code></pre>
<p>Now we have a collection of functional objects that we can use to define
the problem. So far, we haven't specified which functionals are energies
and which are constraints; nor have we specified which parts of the mesh
the functionals are to be evaluated over. All that information is
collected in an <code>OptimizationProblem</code> object, which we will now create:</p>
<pre><code>// Set up the optimization problem
var W = 1
var sigma = 1

var problem = OptimizationProblem(m)
problem.addenergy(lf)
problem.addenergy(la, selection=bnd, prefactor=-W/2)
problem.addenergy(lt, selection=bnd, prefactor=sigma)
problem.addconstraint(laa)
problem.addlocalconstraint(ln, field=nn, target=1)
</code></pre>
<p>Notice that some of these functionals only act on a selection such as
the boundary and hence we use the optional <code>selection</code> parameter to
specify this. We can also specify the prefactor of the functional.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="performing-the-optimization"><a class="header" href="#performing-the-optimization">Performing the optimization</a></h2>
<p>We're now ready to perform the optimization, for which we need an
<code>Optimizer</code> object. These come in two flavors: a <code>ShapeOptimizer</code> and a
<code>FieldOptimizer</code> that respectively act on the shape and a field. We
create them with the problem and quantity they're supposed to act on:</p>
<pre><code class="language-javascript">// Create shape and field optimizers
var sopt = ShapeOptimizer(problem, m)
var fopt = FieldOptimizer(problem, nn)
</code></pre>
<p>Having created these, we can perform the optimizion by calling the
<code>linesearch</code> method with a specified number of iterations for each:</p>
<pre><code class="language-javascript">// Optimization loop
for (i in 1..100) {  
    fopt.linesearch(20)
    sopt.linesearch(20)
}
</code></pre>
<p>Each iteration of a <code>linesearch</code> evolves the field (or shape) down the
gradient of the target functional, subject to constraints, and finds an
optimal stepsize to reduce the value of the functional. Here, we
alternate between optimizing the field and optimizing the shape,
performing twenty iterations of each, and overall do this one hundred
times. These numbers have been chosen rather arbitrarily, and if you
look at the output you will notice that <em>morpho</em> doesn't always execute
twenty iterations of each. Rather, at each iteration it checks to see if
the change in energy satisfies, $$|E|&lt;\epsilon,$$ or,
$$\left|\frac{\Delta E}{E}\right|&lt;\epsilon$$ where the value of
\(\epsilon\), the convergence tolerance can be changed by setting the
<code>etol</code> property of the Optimizer object:</p>
<pre><code class="language-javascript">sopt.etol = 1e-7 // default value is 1e-8
</code></pre>
<p>Some other properties of an <code>Optimizer</code> that may be useful for the user to
adjust are as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>Property</th><th>Default value</th><th>Purpose</th></tr></thead><tbody>
<tr><td><code>etol</code></td><td>\(1\times10^{-8}\)</td><td>Energy tolerance (relative error)</td></tr>
<tr><td><code>ctol</code></td><td>\(1\times10^{-10}\)</td><td>Constraint tolerance (how well are constraints satisfied)</td></tr>
<tr><td><code>stepsize</code></td><td>0.1</td><td>Stepsize for <code>relax</code> (changed by linesearch)</td></tr>
<tr><td><code>steplimit</code></td><td>0.5</td><td>Largest stepsize a <code>linesearch</code> can take</td></tr>
<tr><td><code>maxconstraintsteps</code></td><td>20</td><td>Number of steps the optimizer may take to ensure constraints are satisfied</td></tr>
<tr><td><code>quiet</code></td><td>false</td><td>Whether to print output as the optimization happens</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h2 id="sec:Visualizing-results" label="&quot;sec:Visualizing-results&quot;">Visualizing results</h2>
<p><em>Morpho</em> provides a highly flexible graphics system, with an external
viewer application <em>morphoview</em>, to enable rich visualizations of
results. Visualizations typically involve one or more <code>Graphics</code>
objects, which act as a container for graphical elements to be
displayed. Various <em>graphics primitives</em>, such as spheres, cylinders,
arrows, tubes, etc. can be added to a <code>Graphics</code> object to make a
drawing.</p>
<p>We are now ready to visualize the results of the optimization. First,
we'll draw the mesh. Because we're interested in seeing the mesh
structure, we'll draw the edges (i.e. the grade 1 elements). The
function to do this is provided as part of the <code>plot</code> module that we
imported in section <a href="tutorial/./importing_modules.html">Importing modules</a>:</p>
<pre><code class="language-javascript">var g=plotmesh(m, grade=1)
</code></pre>
<p>Next, we'll create a separate <code>Graphics</code> object that contains the
director. Since the director \(\mathbf{n}\) is a unit vector field, and
the sign is not significant (the nematic elastic energy is actually
invariant under \(\mathbf{n}\to-\mathbf{n}\)), an appropriate way to
display a single director is as a cylinder oriented along \(\mathbf{n}\).
We will therefore make a helper function that creates a <code>Graphics</code>
object and draws such a cylinder at every mesh point:</p>
<pre><code class="language-javascript">// Function to visualize a director field
// m - the mesh 
// nn - the director Field to visualize
// dl - scale the director 
fn visualize(m, nn, dl) { 
    var v = m.vertexmatrix()
    var nv = m.count() // Number of vertices
    var g = Graphics() // Create a graphics object
    for (i in 0...nv) {
    var x = v.column(i) // Get the ith vertex
    // Draw a cylinder aligned with nn at this vertex
    g.display(Cylinder(x-nn[i]*dl, x+nn[i]*dl, aspectratio=0.3))
    }
    return g
}
</code></pre>
<p>Once we've defined this function, we can use it:</p>
<pre><code class="language-javascript">var gnn=visualize(m, nn, 0.2)
</code></pre>
<p>The variables \(g\) and \(gnn\) now refer to two separate Graphics objects.
We can combine them using the \(+\) operator, and display them like so:</p>
<pre><code class="language-javascript">var gdisp = g+gnn
Show(gdisp)
</code></pre>
<figure id="fig:FinalResult">
<div class="centering">
<img src="tutorial/../Figures/Tutorial/2Visualize/out.png" style="width:3.5in" />
</div>
<figcaption><span id="fig:FinalResult"
label="fig:FinalResult"></span>Optimized mesh and director
field.</figcaption>
</figure>
<p>The resulting visualization is shown in Fig. <a href="tutorial/visualizing_the_results.html#fig:FinalResult">4.5</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="refinement"><a class="header" href="#refinement">Refinement</a></h1>
<p>We have now solved our first shape optimization problem, and the
complete problem script is provided in the <code>examples/tutorial</code> folder
inside the git repository as <code>tutorial.morpho</code>. The result we have
obtained in Fig. <a href="tutorial/refinement.html#fig:FinalResult">4.5</a> is, however, a very coarse, low resolution
solution comprising only a relatively small number of elements. To gain
an improved solution, we need to <em>refine</em> our mesh. Because modifying
the mesh also requires us to update other data structures like fields
and selections, a special <code>MeshRefiner</code> object is used to perform the
refinement.</p>
<p>To perform refinement we:</p>
<ol>
<li>Create a <code>MeshRefiner</code> object, providing it a list of all the
<code>Mesh</code>, <code>Field</code> and <code>Selection</code> objects (i.e. the mesh and objects
that directly depend on it) that need to be updated:
<pre><code class="language-javascript">var mr=MeshRefiner([m, nn, bnd]) // Set the refiner up
</code></pre>
</li>
<li>Call the <code>refine</code> method on the <code>MeshRefiner</code> object to actually
perform the refinement. This method returns a <code>Dictionary</code> object
that maps the old objects to potentially newly created ones.
<pre><code class="language-javascript">var refmap=mr.refine() // Perform the refinement
</code></pre>
</li>
<li>Tell any other objects that refer to the mesh, fields or selections
to update their references using <code>refmap</code>. For example,
<code>OptimizationProblem</code> and <code>Optimizer</code> objects are typically updated
at this step.
<pre><code class="language-javascript">for (el in [problem, sopt, fopt]) el.update(refmap) // Update the problem
</code></pre>
</li>
<li>Update our own references
<pre><code class="language-javascript">m=refmap[m]; nn=refmap[nn]; bnd=refmap[bnd] // Update variables
</code></pre>
</li>
</ol>
<figure id="fig:Refinement">
<p><img src="tutorial/../Figures/Tutorial/3Refine/out1.png" style="width:2in"
alt="image" /><img src="tutorial/../Figures/Tutorial/3Refine/out2.png" style="width:2in"
alt="image" /><img src="tutorial/../Figures/Tutorial/3Refine/out3.png" style="width:2in"
alt="image" /></p>
<figcaption><span id="fig:Refinement"
label="fig:Refinement"></span>Optimized mesh and director field at three
successive levels of refinement.</figcaption>
</figure>
<p>We insert this code after our optimization section, which causes
<em>morpho</em> to successively optimize and refine[^4]. The resulting
optimized shapes are displayed in Fig.
<a href="tutorial/refinement.html#fig:Refinement">4.6</a>.</p>
<pre><code>// Optimization loop
var refmax = 3
for (refiter in 1..refmax) {
  print "===Refinement level ${refiter}==="
  for (i in 1..100) {
    fopt.linesearch(20)     
    sopt.linesearch(20)   
  }
 
  if (refiter==refmax) break

  // Refinement
  var mr=MeshRefiner([m, nn, bnd]) // Set the refiner up
  var refmap=mr.refine() // Perform the refinement
  for (el in [problem, sopt, fopt]) el.update(refmap) // Update the problem
  m=refmap[m]; nn=refmap[nn]; bnd=refmap[bnd] // Update variables
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="next-steps"><a class="header" href="#next-steps">Next steps</a></h2>
<p>Having completed this tutorial, you may wish to explore the effect of
changing some of the parameters in the file. What happens if you change
<code>sigma</code> and W, the coefficients in front of the terms in the energy?
What happens if you take a different number of steps? Or change
properties of the Optimizers like <code>stepsize</code> and <code>steplimit</code>?</p>
<p>You should look at other example files provided in the <code>examples</code> folder
of the git repository. The remainder of the manual comprises chapters
exploring certain <em>morpho</em> concepts in more detail, followed by a
detailed reference manual for <em>morpho</em> functionality, and a complete
description of the scripting language.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chap:Working-with-Meshes" label="&quot;chap:Working-with-Meshes&quot;">Working with Meshes</h1>
<p>This chapter explains a number of ways the user can create and
manipulate Mesh objects in <em>morpho</em>. The simplest way to create a mesh
for a desired domain is to use the <code>meshgen</code> module, which provides a
very high level and convenient interface. The <code>meshtools</code> module
provides low level mesh creation operations and a number of useful
routines to manipulate meshes. The <code>implicitmesh</code> module produces
surfaces from implicit functions. Finally, you can use an external
program to create a mesh that exports the data in vtk format using the
<code>vtk</code> module.</p>
<p>Mesh creation follows two patterns. Some methods use a <strong>constructor</strong>
pattern where you call a single function that creates the Mesh, e.g.</p>
<pre><code class="language-javascript">var mesh = LineMesh(fn (t) [t,0], -1..1:0.1)
</code></pre>
<p>Other approaches follow a <strong>builder</strong> pattern, where you first create a
special helper object,</p>
<pre><code class="language-javascript">var mb = MeshBuilder()
</code></pre>
<p>and manipulate it, e.g. by adding elements or setting options. The Mesh
is then created by calling the build method:</p>
<pre><code class="language-javascript">var mesh = mb.build() 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="sec:Meshgen" label="&quot;sec:Meshgen&quot;">The meshgen module</h2>
<p>The <code>meshgen</code> module conveniently produces high quality meshes for many
kinds of domain. It follows the builder pattern with a MeshGen helper
object that performs the construction. To use <code>meshgen</code>, the user must
provide a scalar function that is positive everywhere that they want to
be meshed[^5]. For example, the interior of the unit disk in two
dimensions, is described by the function $$f(x,y)=1-(x^{2}+y^{2}).$$ To
create the corresponding Mesh, we must first specify a suitable <em>morpho</em>
function that describes the domain. This function will be called
repeatedly by MeshGen, which will pass it a position vector <code>x</code>. Hence,
the \((x,y)\) components must be accessed from the argument <code>x</code> by
indexing:</p>
<pre><code class="language-javascript">fn disk(x) { 
    return 1-(x[0]^2+x[1]^2) 
}
</code></pre>
<p>Now that the function is specified, we can create a MeshGen object:</p>
<pre><code class="language-javascript">var mg = MeshGen(disk, [-1..1:0.2, -1..1:0.2])
</code></pre>
<p>The second parameter is a list of Ranges that provide overall bounds on
the domain to be meshed. Here we will use \(x,y\in[-1,1]\). By setting the
stepsize, the user can provide MeshGen with an overall suggestion of the
resolution.</p>
<p>Finally, we create the Mesh by calling the build method:</p>
<pre><code class="language-javascript">var m = mg.build() 
</code></pre>
<p>The resulting Mesh is shown in Fig.
<a href="working_with_meshes/meshgen_module.html#fig:MeshGen-disk">5.1</a>{reference-type="ref"
reference="fig:MeshGen-disk"}, left panel. A higher resolution Mesh can
be generated by changing the Range objects passed to MeshGen:</p>
<pre><code>var mg = MeshGen(disk, [-1..1:0.1, -1..1:0.1])
</code></pre>
<p>This generates a much higher resolution Mesh, with approximately four
times the number of vertices as shown in Fig.
<a href="working_with_meshes/meshgen_module.html#fig:MeshGen-disk">5.1</a>{reference-type="ref"
reference="fig:MeshGen-disk"}, right panel.</p>
<figure id="fig:MeshGen-disk">
<p><img src="working_with_meshes/../Figures/MeshChapter/MeshGen/disk.png" style="width:3in"
alt="image" /><img src="working_with_meshes/../Figures/MeshChapter/MeshGen/finedisk.png"
style="width:3in" alt="image" /></p>
<figcaption><span id="fig:MeshGen-disk"
label="fig:MeshGen-disk"></span>Two disks created with different
resolutions with MeshGen.</figcaption>
</figure>
<p>MeshGen can also mesh more complicated domains. To facilitate this, it
provides a Domain class that accepts a scalar function in its
constructor. For example, this code creates an ellipse as shown in Fig.
<a href="working_with_meshes/meshgen_module.html#fig:MeshGen-2">5.2</a>,
left panel:</p>
<pre><code>var e0 = Domain(fn (x) -((x[0]/2)^2+x[1]^2-1)) 
var mg = MeshGen(e0, [-2..2:0.2, -1..1:0.2])
var m = mg.build()
</code></pre>
<p>The benefit of this is that Domain objects can be combined using set
operation methods <code>union</code>, <code>intersection</code> and <code>difference</code>. To
illustrate the possibilities with this, we use a special constructor to
create three domains corresponding to disks,</p>
<pre><code>var a = CircularDomain(Matrix([-0.5,0]), 1)
var b = CircularDomain(Matrix([0.5,0]), 1)
var c = CircularDomain(Matrix([0,0]), 0.3)
</code></pre>
<p>then combine them,</p>
<pre><code>var dom = a.union(b).difference(c)
</code></pre>
<p>and mesh the resulting domain,</p>
<pre><code>var mg = MeshGen(dom, [-2..2:0.1, -1..1:0.1], quiet=false)
var m = mg.build()
</code></pre>
<p>with the result shown in Fig. <a href="working_with_meshes/meshgen_module.html#fig:MeshGen-2">5.2</a>, right panel.</p>
<figure id="fig:MeshGen-2">
<p><img src="working_with_meshes/../Figures/MeshChapter/MeshGen/ellipse.png" style="width:3in"
alt="image" /><img
src="../Figures/MeshChapter/MeshGen/overlappingdisks.png" style="width:3in"
alt="image" /></p>
<figcaption><span id="fig:MeshGen-2" label="fig:MeshGen-2"></span>More
complex domains can be created with MeshGen by combining
domains.</figcaption>
</figure>
<p>Three dimensional meshes are created very similarly. Here we create a
spherical mesh, displayed in Fig.
<a href="working_with_meshes/meshgen_module.html#fig:MeshGen-3">5.3</a></p>
<pre><code>var dh = 0.2 
var dom = Domain(fn (x) -(x[0]^2+x[1]^2+x[2]^2-1))
var mg = MeshGen(dom, [-1..1:dh, -1..1:dh, -1..1:dh])
var m = mg.build()
</code></pre>
<figure id="fig:MeshGen-3">
<div class="centering">
<img src="working_with_meshes/../Figures/MeshChapter/MeshSlicer/mesh.png" style="width:3.5in" />
</div>
<figcaption><span id="fig:MeshGen-3"
label="fig:MeshGen-3"></span>Spherical mesh created with
MeshGen</figcaption>
</figure><div style="break-before: page; page-break-before: always;"></div><h2 id="the-meshtools-module"><a class="header" href="#the-meshtools-module">The meshtools module</a></h2>
<p>Meshtools provides many useful functions for working with Meshes,
including constructors to create certain kinds of Mesh and also classes
for refining, coarsening and merging Meshes.</p>
<h4 id="linemesh"><a class="header" href="#linemesh">LineMesh</a></h4>
<p>The <code>LineMesh</code> function is a convenient way to create a Mesh from a
one-parameter parametric function. You must specify the function to use
and a Range of points to generate. <code>LineMesh</code> then evaluates each point
in the Range and joins them together with a line element.</p>
<p>This is useful to generate meshes such as a simple straight line (Fig.
<a href="working_with_meshes/meshtools_module.html#fig:LineMesh">5.4</a>{reference-type="ref" reference="fig:LineMesh"},
left panel):</p>
<pre><code>var m = LineMesh(fn (t) [t,0], -1..1:0.1)
</code></pre>
<p>You can also request the ends of the Mesh be joined together to form a
loop by specifying <code>closed</code>. This code generates a circle (Fig.
<a href="working_with_meshes/meshtools_module.html#fig:LineMesh">5.4</a>{reference-type="ref" reference="fig:LineMesh"},
center panel):</p>
<pre><code>var m = LineMesh(fn (t) [cos(t),sin(t)], -Pi...Pi:2*Pi/10, closed=true)
</code></pre>
<p>You can increase the resolution of the circle by changing the stepsize
in the Range, for example to <code>2``*``Pi/20</code> to double the number of
points. Note the use of the exclusive Range operator here, <code>...</code>, rather
than <code>..</code>to avoid duplicating the point at (1,0).</p>
<p>The output Mesh can be of any dimension, such as this helix in 3D (Fig.
<a href="working_with_meshes/meshtools_module.html#fig:LineMesh">5.4</a>{reference-type="ref" reference="fig:LineMesh"},
right panel). Notice that here we use a regular function rather than an
anonymous function:</p>
<pre><code>fn helix(t) { 
  return [cos(2*Pi*t),t/2,sin(2*Pi*t)] 
}
var m = LineMesh(helix, -2..2:1/20)
</code></pre>
<figure id="fig:LineMesh">
<p><img src="working_with_meshes/../Figures/MeshChapter/LineMesh/line.png" style="width:2in"
alt="image" /><img src="working_with_meshes/../Figures/MeshChapter/LineMesh/circle.png"
style="width:2in" alt="image" /><img
src="../Figures/MeshChapter/LineMesh/helix.png" style="width:2in"
alt="image" /></p>
<figcaption><span id="fig:LineMesh" label="fig:LineMesh"></span>Using
LineMesh to create meshes from parametric functions: A straight line, a
circle and a helix.</figcaption>
</figure>
<h4 id="areamesh"><a class="header" href="#areamesh">AreaMesh</a></h4>
<p><code>AreaMesh</code> is similar to <code>LineMesh</code> function creates a Mesh from a
parametric function, which now takes two parameters. To create a square,</p>
<pre><code>var m = AreaMesh(fn (u,v) [u,v,0], -1..1:0.2, -1..1:0.2)
</code></pre>
<p>where notice that a separate Range is required for \(u\) and \(v\). By
default, the output of AreaMesh only contains grade 0 and grade 2
elements, i.e. vertices and facets, as is visible in Fig.
<a href="working_with_meshes/meshtools_module.html#fig:AreaMesh-1">5.5</a>{reference-type="ref"
reference="fig:AreaMesh-1"}(left). To add in grade 1 elements if
required, call the <code>addgrade</code> method on the Mesh:</p>
<pre><code>m.addgrade(1)
</code></pre>
<p>This gives the result shown in Fig.
<a href="working_with_meshes/meshtools_module.html#fig:AreaMesh-1">5.5</a>{reference-type="ref"
reference="fig:AreaMesh-1"}(right).</p>
<figure id="fig:AreaMesh-1">
<p><img src="working_with_meshes/../Figures/MeshChapter/AreaMesh/square.png" style="width:3in"
alt="image" /><img src="working_with_meshes/../Figures/MeshChapter/AreaMesh/square2.png"
style="width:3in" alt="image" /></p>
<figcaption><span id="fig:AreaMesh-1"
label="fig:AreaMesh-1"></span>Using AreaMesh to create a flat square
mesh. Left: By default, only grade 0 and 2 elements are generated.
Right: The grade 1 elements can be added in with
<code>addgrade</code>.</figcaption>
</figure>
<p>As with LineMesh, the Meshes can be closed in one or both directions,
enabling the creation of a cylinder,</p>
<pre><code>m = AreaMesh(fn (u, v) [v, cos(u), sin(u)], 
               -Pi...Pi:Pi/16,
               -2..2:0.1, closed=[true, false])
</code></pre>
<p>and a torus,</p>
<pre><code>var c=1, a=0.5 m = AreaMesh(fn (u, v) [(c + a*cos(v))*cos(u), 
                                       (c + a*cos(v))*sin(u),  
                                        a*sin(v)],
                            0...2*Pi:Pi/16,
                            0...2*Pi:Pi/8, closed=true)
</code></pre>
<p>The results of these are displayed in Fig.
<a href="working_with_meshes/meshtools_module.html#fig:AreaMesh-2">5.6</a>{reference-type="ref" reference="fig:AreaMesh-2"}.
Note that the meshes generated by more modules that incorporate some
degree of quality control, e.g. <code>implicitmesh</code> or <code>meshgen</code>, are
generally better and should be used in preference to those created by
AreaMesh.</p>
<figure id="fig:AreaMesh-2">
<p><img src="working_with_meshes/../Figures/MeshChapter/AreaMesh/tube.png" style="width:3in"
alt="image" /><img src="working_with_meshes/../Figures/MeshChapter/AreaMesh/torus.png"
style="width:3in" alt="image" /></p>
<figcaption><span id="fig:AreaMesh-2" label="fig:AreaMesh-2"></span>A
cylinder and torus created with AreaMesh.</figcaption>
</figure>
<h4 id="polyhedronmesh"><a class="header" href="#polyhedronmesh">PolyhedronMesh</a></h4>
<figure id="fig:PolyhedronMesh">
<p><img src="working_with_meshes/../Figures/MeshChapter/PolyhedronMesh/cubevertices.png"
style="width:2in" alt="image" /><img
src="../Figures/MeshChapter/PolyhedronMesh/cubeface.png" style="width:2in"
alt="image" /><img src="working_with_meshes/../Figures/MeshChapter/PolyhedronMesh/cube.png"
style="width:2in" alt="image" /></p>
<figcaption><span id="fig:PolyhedronMesh"
label="fig:PolyhedronMesh"></span>Creating a cube with PolyhedronMesh.
(Left) First the vertices are specified. (Center) Faces are specified as
an ordered sequence of points. (Right) PolyhedronMesh adds additional
vertices to create</figcaption>
</figure>
<p>PolyhedronMesh helps to create Meshes corresponding to polyhedra. To
make a cube, for example, we specify the eight vertices (see Fig.
<a href="working_with_meshes/meshtools_module.html#fig:PolyhedronMesh">5.7</a>{reference-type="ref"
reference="fig:PolyhedronMesh"}, left),</p>
<pre><code>var vertices = [[-0.5, -0.5, -0.5],
                [ 0.5, -0.5, -0.5],
                [-0.5,  0.5, -0.5],
                [ 0.5,  0.5, -0.5], 
                [-0.5, -0.5,  0.5],
                [ 0.5, -0.5,  0.5],
                [-0.5,  0.5,  0.5],
                [ 0.5,  0.5,  0.5]]
</code></pre>
<p>and the six faces,</p>
<pre><code>var faces = [ [0,1,3,2], [4,5,7,6],
              [0,1,5,4], [3,2,6,7],
              [0,2,6,4], [1,3,7,5] ]
</code></pre>
<p>Note that the vertex ids must be given <em>in order</em> going around each face
(see Fig. <a href="working_with_meshes/meshtools_module.html#fig:PolyhedronMesh">5.7</a>{reference-type="ref"
reference="fig:PolyhedronMesh"}, center). Once the faces are specified,
we can create the mesh,</p>
<pre><code>var m = PolyhedronMesh(vertices, faces)
m.addgrade(1)
</code></pre>
<p>Note that PolyhedronMesh automatically creates additional vertices and
generates triangles to complete the mesh (Fig.
<a href="working_with_meshes/meshtools_module.html#fig:PolyhedronMesh">5.7</a>{reference-type="ref"
reference="fig:PolyhedronMesh"}, right). We then added line elements
(grade 1) as these are not automatically created by PolyhedronMesh.</p>
<h4 id="delaunaymesh"><a class="header" href="#delaunaymesh">DelaunayMesh</a></h4>
<figure id="fig:DelaunayMesh">
<p><img src="working_with_meshes/../Figures/MeshChapter/DelaunayMesh/points.png"
style="width:3in" alt="image" /><img
src="../Figures/MeshChapter/DelaunayMesh/mesh.png" style="width:3in"
alt="image" /></p>
<figcaption><span id="fig:DelaunayMesh"
label="fig:DelaunayMesh"></span>Delaunay triangulation of (left) a
random oint cloud gives (right) a tetrahedralization.</figcaption>
</figure>
<p>The DelaunayMesh constructor function performs a delaunay
"triangulation" of a point set. For example, creating a random cloud of
points (Fig. <a href="working_with_meshes/meshtools_module.html#fig:DelaunayMesh">5.8</a>{reference-type="ref"
reference="fig:DelaunayMesh"}, left panel):</p>
<pre><code>var pts = []
for (i in 0...100) pts.append(Matrix([2*random()-1, 2*random()-1, 2*random()-1])) 
</code></pre>
<p>we can then call DelaunayMesh to construct a tetrahedralization.
DelaunayMesh only generates elements of the highest grade (in 2D, area
elements, in 3D volume elements) so if edges are needed these can be
added with <code>addgrade</code>.</p>
<pre><code>var m=DelaunayMesh(pts)
m.addgrade(1)
</code></pre>
<p>The resulting tetrahedralization is shown in Fig.
<a href="working_with_meshes/meshtools_module.html#fig:DelaunayMesh">5.8</a>{reference-type="ref"
reference="fig:DelaunayMesh"}, right panel.</p>
<h4 id="subsec:ChangeMeshDimension" label="&quot;subsec:ChangeMeshDimension&quot;">ChangeMeshDimension[]</h4>
<p>Occasionally, one wishes to take a mesh embedded in one space, say two
dimensions, and embed it in a space of different dimensionality. For
example, you may wish to use a 2D mesh generated with MeshGen in 3D
space. The function <code>ChangeMeshDimension</code> provides a convenient way to
do this:</p>
<pre><code>var new = ChangeMeshDimension(mesh, dim)
</code></pre>
<p>where <code>dim</code> is the target dimension of the new mesh.</p>
<h4 id="meshbuilder"><a class="header" href="#meshbuilder">MeshBuilder</a></h4>
<p>The MeshBuilder class facilitates manual construction of a Mesh object.
It is primarily intended to be used by other mesh building algorithms,
but is occasionally useful. To begin, create a MeshBuilder object:</p>
<pre><code>var mb = MeshBuilder()
</code></pre>
<p>You can then add vertices and other elements one by one by calling
appropriate methods. Let's build a tetrahedron by first adding the
vertices:</p>
<pre><code>mb.addvertex([0, 0, 0.612372])
mb.addvertex([-0.288675, -0.5, -0.204124])
mb.addvertex([-0.288675, 0.5, -0.204124])
mb.addvertex([0.57735, 0, -0.204124])
</code></pre>
<p>We then need to add edges connecting these vertices, and faces as well.
We could do this one by one, giving a list of vertex ids for each
element in turn,</p>
<pre><code>mb.addedge([0,1])
mb.addedge([0,2]) 
// ... etc. 
</code></pre>
<p>but there's a smarter way for this case. Notice that the vertex ids
corresponding to the edges of the tetrahedron correspond to the sets of
size 2 generated from the list <code>[``0,1,2,3``]</code> as can be seen by running
this code:</p>
<pre><code>var vids = [0,1,2,3]
for (s in vids.sets(2)) print s 
</code></pre>
<p>We can therefore generate the edges automatically,</p>
<pre><code>var vids = [0,1,2,3]
for (s in vids.sets(2)) mb.addedge(s)
</code></pre>
<p>and the faces as well, which are the sets of size 3,</p>
<pre><code>for (s in vids.sets(3)) mb.addface(s)
</code></pre>
<p>We can finish by adding a single grade 3 element corresponding to the
volume:</p>
<pre><code>mb.addvolume(vids)
</code></pre>
<p>Once all these have been added, call the <code>build</code> method to create a Mesh
object:</p>
<pre><code>var m = mb.build()
</code></pre>
<p>and the resulting Mesh is shown in Fig.
<a href="working_with_meshes/meshtools_module.html#fig:MeshBuilder">5.9</a>.</p>
<figure id="fig:MeshBuilder">
<div class="centering">
<img src="working_with_meshes/../Figures/MeshChapter/MeshBuilder/tetrahedron.png" style="width:3.5in" />
</div>
<figcaption><span id="fig:MeshBuilder"
label="fig:MeshBuilder"></span>Tetrahedron created with
MeshBuilder.</figcaption>
</figure><div style="break-before: page; page-break-before: always;"></div><h2 id="the-vtk-module"><a class="header" href="#the-vtk-module">The vtk module</a></h2>
<p>The vtk module provides importing and exporting facilities for the
popular VTK file format, which is used by many other programs such as
<code>paraview</code>. Unlike morpho <em>.mesh</em> files, VTK files can include both Mesh
and Field data. To load a mesh from a VTK file, use a VTKImporter
object:</p>
<pre><code>import vtk 
var mv = VTKImporter("file.vtk")
var m = mv.mesh()
</code></pre>
<p>Fields can be loaded in a similar way. Each field in the VTK file has an
identifier, which is passed to the <code>field</code> method as a string.</p>
<pre><code>var f = mv.field("F")
var g = mv.field("G")
</code></pre>
<p>Exporting requires a VTKExporter class,</p>
<pre><code>import meshtools 
import vtk 
var m1 = LineMesh(fn (t) [t,0,0], -1..1:2)
var g1 = Field(m1, fn(x,y,z) Matrix([x,2*x,3*x]))

var vtkE = VTKExporter(g1, fieldname="g")
vtkE.export("data.vtk")</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="merging-meshes"><a class="header" href="#merging-meshes">Merging meshes</a></h2>
<p>A potential strategy to create meshes for complicated domains is to
begin by creating several simpler meshes and then merging them together
into one larger mesh. The MeshMerge class in the <code>meshtools</code> package
allows us to do this. To use it, we create a MeshMerge object with a
list of meshes we wish to merge</p>
<pre><code>var mrg = MeshMerge([m1, m2, m3, ... ])
</code></pre>
<p>and then call the merge method to perform the merge and return the
resulting Mesh:</p>
<pre><code>var newmesh = mrg.merge()
</code></pre>
<p>As an example of this, we will build a mesh that might be an initial
guess for a membrane held between two square fixed boundaries. We'll do
this by creating one octant and then reflecting it along different axes.
The basic unit is constructed with PolyhedronMesh, as shown in Fig.
<a href="working_with_meshes/merging_meshes.html#fig:MeshMerge">5.11</a>{reference-type="ref" reference="fig:MeshMerge"}:</p>
<pre><code>var a = 0.5 // Vertical separation
var r = 0.5 // Size of hole
var L = 1  // Size of box 

// One octant of the mesh 
var vertices = [ [r,0,a], [L,0,a], [L,r,a], [L,L,a],
                 [r,L,a], [0,L,a], [0,r,a], [r,r,a],
                 [r,0,0], [r,r,0], [0,r,0] ]
var faces = [ [0,1,2,7], [2,3,4,7], [7,4,5,6], [0,8,9,7], [6,7,9,10] ]

var m1 = PolyhedronMesh(vertices, faces)
m1.addgrade(1)
</code></pre>
<p>We now need to create code that reflects a Mesh about one or more axes.
There's more than one way this could be done, but we will here create a
MeshReflector class that follows the builder pattern:</p>
<pre><code>class MeshReflector {
  init(mesh) {
    self.mesh = mesh
    self.dim = mesh.vertexmatrix().dimensions()[0] // Get Mesh dimension
  }

  // Construct a matrix that reflects about one or more axes    
  _reflectionmatrix(axis) { 
    var rmat = Matrix(self.dim,self.dim)
    for (i in 0...self.dim) rmat[i,i]=1
    if (isint(axis)) rmat[axis,axis]*=-1
    else if (isobject(axis)) for (i in axis) rmat[i,i]*=-1
    return rmat
  }

  reflect(axis) { // Reflect the mesh about the given axis or axes
    var rmat = self._reflectionmatrix(axis)
    // Clone and transform the mesh
    var m = self.mesh.clone()
    for (vid in 0...m.count()) {
      m.setvertexposition(vid, rmat * m.vertexposition(vid))
    }
    return m
  }
} 
</code></pre>
<p>Having defined this class, we create a MeshReflector and use it to build
seven reflected copies:</p>
<pre><code>var mr = MeshReflector(m1)

// Merge reflected meshed together
var merge = MeshMerge([ m1,
                        mr.reflect(0),
                        mr.reflect(1),
                        mr.reflect(2),
                        mr.reflect([0,1]),
                        mr.reflect([1,2]),
                        mr.reflect([2,0]),
                        mr.reflect([0,1,2])
                      ])
var m = merge.merge()
</code></pre>
<p>The resulting mesh is shown in Fig.
<a href="working_with_meshes/merging_meshes.html#fig:MeshMerge">5.11</a>{reference-type="ref" reference="fig:MeshMerge"},
right panel. Note that MeshMerge automatically removes duplicate
elements as the merge is performed, so that</p>
<pre><code>print m1.count(1)
</code></pre>
<p>reports that there were 35 line elements in the original mesh, while</p>
<pre><code>print m.count(1)
</code></pre>
<p>yields \(256=8\times(35-6/2)\) line elements, because there are 6 shared
edges for each copy.</p>
<figure id="fig:MeshMerge">
<p><img src="working_with_meshes/../Figures/MeshChapter/MeshMerge/unit.png" style="width:3in"
alt="image" /><img src="working_with_meshes/../Figures/MeshChapter/MeshMerge/final.png"
style="width:3in" alt="image" /></p>
<figcaption><span id="fig:MeshMerge" label="fig:MeshMerge"></span>By
reflecting a small mesh segment (left) about various axes, we can
assemble a larger mesh (right).</figcaption>
</figure>
<div style="break-before: page; page-break-before: always;"></div><h2 id="slicing-meshes"><a class="header" href="#slicing-meshes">Slicing meshes</a></h2>
<p>The <code>meshslice</code> module is designed to help visualize a "slice" through
the mesh and associated Fields, which is often useful when working with
three or higher dimensional meshes. To illustrate its use, we'll reuse
the spherical mesh created with MeshGen in Section
<a href="working_with_meshes/slicing_meshes.html#sec:Meshgen">[sec:Meshgen]</a>{reference-type="ref"
reference="sec:Meshgen"} above (see Fig.
<a href="working_with_meshes/slicing_meshes.html#fig:MeshGen-3">5.3</a>{reference-type="ref" reference="fig:MeshGen-3"}).
Ensure that the mesh has grade 2 elements present with <code>addgrade</code> if
necessary. We'll also create a simple scalar field:</p>
<pre><code>var u = Field(m, fn (x,y,z) x*y)
</code></pre>
<p>To take a slice, first create a MeshSlicer object with the mesh we want
to slice:</p>
<pre><code>var ms=MeshSlicer(m)
</code></pre>
<p>Then call the <code>slice</code> method, which requires us to specify a slicing
plane. Planes are defined by a point \((x,y,z)\) and a normal vector
\((n_{x},n_{y},n_{z})\), which are passed as arguments:</p>
<pre><code>var slc=ms.slice([0,0,0],[0,0,1]) // position, normal
</code></pre>
<p>After taking a slice, we can then slice any number of Field objects as
well:</p>
<pre><code>var uslc=ms.slicefield(u)
</code></pre>
<p>A single MeshSlicer can take any number of slices from the same Mesh;
<code>slicefield</code> always uses the most recent slice taken. Results from the
example are shown in Fig. <a href="working_with_meshes/slicing_meshes.html#fig:MeshSlicer">5.12</a>{reference-type="ref"
reference="fig:MeshSlicer"}. As can be seen, the results of slicing a
Mesh typically produce meshes that are quire irregular, with narrow
triangles and unequally sized elements. Hence, these meshes are intended
mostly for visualization purposes rather than use in calculations.</p>
<figure id="fig:MeshSlicer">
<p><img src="working_with_meshes/../Figures/MeshChapter/MeshSlicer/slicemesh.png"
style="width:3in" alt="image" /><img
src="../Figures/MeshChapter/MeshSlicer/field.png" style="width:3in"
alt="image" /></p>
<figcaption><span id="fig:MeshSlicer"
label="fig:MeshSlicer"></span>Sliced plane of the spherical Mesh shown
in Fig. <a href="working_with_meshes/slicing_meshes.html#fig:MeshGen-3" data-reference-type="ref"
data-reference="fig:MeshGen-3">5.3</a>, together with a sliced scalar
field plotted with plotfield.</figcaption>
</figure>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chap:Visualization" label="&quot;chap:Visualization&quot;">Visualization</h1>
<p>This chapter describes ways to use <em>morpho</em> to visualize output. Easy to
use functions to visualize geometric objects are found in the <code>plot</code>
module, while you can draw arbitrary objects using the <code>graphics</code>
module. Publication quality output can be generated conveniently using
the <code>povray</code> module.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="the-plot-module"><a class="header" href="#the-plot-module">The plot module</a></h2>
<figure id="fig:PlotMesh">
<div class="centering">
<p><span class="sans-serif">A</span><img
src="../Figures/VisChapter/plotmesh/square.png" style="width:2in"
alt="image" /><span class="sans-serif">B</span><img
src="../Figures/VisChapter/plotmesh/square2.png" style="width:2in"
alt="image" /><span class="sans-serif">C</span><img
src="../Figures/VisChapter/plotmesh/square3.png" style="width:2in"
alt="image" /></p>
</div>
<figcaption><strong><span id="fig:PlotMesh"
label="fig:PlotMesh"></span>Using plotmesh.</strong> <strong>A</strong>
By default, the highest grade element is displayed. <strong>B</strong>
Other grades, here points and edges, can be shown by setting the
<code>grade</code> option. <strong>C</strong> The color of the mesh can
be chosen with the color option.</figcaption>
</figure>
<p>The <code>plot</code> module offers a convenient way to visualize Meshes, Fields
and Selections. To illustrate its use, we'll create a simple Mesh,</p>
<pre><code>import meshtools
var m = AreaMesh(fn (u,v) [u, v, 0], -1..1:0.2, -1..1:0.2)
m.addgrade(1)
</code></pre>
<p>and an associated scalar Field,</p>
<pre><code>var f = Field(m, fn (x,y) x*y)
</code></pre>
<h4 id="meshes"><a class="header" href="#meshes">Meshes</a></h4>
<p>To visualize the Mesh, use the <code>plotmesh</code> function</p>
<pre><code>var g = plotmesh(m)
</code></pre>
<p>which outputs a Graphics object, which we'll describe more fully in
Section
<a href="visualization/plot_module.html#sec:The-graphics-module">[sec:The-graphics-module]</a>{reference-type="ref"
reference="sec:The-graphics-module"} below. By default, <code>plotmesh</code> shows
only the highest grade element presenthere grade 2 or facetsas shown in
Fig. <a href="visualization/plot_module.html#fig:PlotMesh">6.1</a>{reference-type="ref"
reference="fig:PlotMesh"}A. To show other grades, use the <code>grade</code>
option:</p>
<pre><code>var g = plotmesh(m, grade=[0,1])
</code></pre>
<p>which shows points and edges as shown in Fig.
<a href="visualization/plot_module.html#fig:PlotMesh">6.1</a>{reference-type="ref" reference="fig:PlotMesh"}B.</p>
<p>You can control the color of the Mesh with the <code>color</code> option as shown
in Fig. <a href="visualization/plot_module.html#fig:PlotMesh">6.1</a>{reference-type="ref"
reference="fig:PlotMesh"}C:</p>
<pre><code>var g = plotmesh(m, grade=0, color=Red)
</code></pre>
<p>To display particular selected elements of a mesh, you can use the
optional <code>selection</code> argument and supply a Selection object.</p>
<pre><code>var sel = Selection(m, fn (x,y,z) x^2+y^2&lt;1)
sel.addgrade(2)
var g = plotmesh(m, grade=[0,2], selection=sel)
</code></pre>
<h4 id="mesh-labels"><a class="header" href="#mesh-labels">Mesh labels</a></h4>
<figure id="fig:PlotMeshLabels">
<div class="centering">
<p><span class="sans-serif">A</span><img
src="../Figures/VisChapter/plotmeshlabels/meshlabels.png" style="width:2in"
alt="image" /><span class="sans-serif">B</span><img
src="../Figures/VisChapter/plotmeshlabels/meshlabels2.png"
style="width:2in" alt="image" /></p>
</div>
<figcaption><strong><span id="fig:PlotMeshLabels"
label="fig:PlotMeshLabels"></span>Using plotmeshlabels to display
element ids.</strong> <strong>A</strong> Element ids for vertices.
<strong>B</strong> Element ids for the grade 1 elements.</figcaption>
</figure>
<p>It's sometimes helpful to be able to identify the id of a particular
element in a Mesh, especially for debugging purposes. The
<code>plotmeshlabels</code> function is designed to facilitate this as shown in
Fig. <a href="visualization/plot_module.html#fig:PlotMeshLabels">6.2</a>{reference-type="ref"
reference="fig:PlotMeshLabels"}. You can select which grade to draw ids
for and specify their color, size and draw direction. It's also possible
to give an offset, which can be a list, matrix or even a function, that
adjusts the placement of the labels relative to the center of the
element. Here we offset them a little above and to the right:</p>
<pre><code>var glabel = plotmeshlabels(m, grade=0, color=Black, offset=[0.025,0.025,0])
</code></pre>
<p>The <code>plotmeshlabels</code> function only draws labels, not the mesh itself, so
we typically combine it with <code>plotmesh</code> and display both:</p>
<pre><code>var gmesh = plotmesh(m, grade=[0,1])
var g = gmesh+glabel
</code></pre>
<p>To show the grade 1 element ids, for example, we might use:</p>
<pre><code>var glabel = plotmeshlabels(m, grade=1, color=Red, offset=[-0.05,-0.05,-0.03])
</code></pre>
<h4 id="selections-1"><a class="header" href="#selections-1">Selections</a></h4>
<figure id="fig:PlotSelection">
<div class="centering">
<p><span class="sans-serif">A</span><img
src="../Figures/VisChapter/plotselection/selection.png" style="width:2in"
alt="image" /><span class="sans-serif">B</span><img
src="../Figures/VisChapter/plotselection/selectionbnd.png"
style="width:2in" alt="image" /></p>
</div>
<figcaption><strong><span id="fig:PlotSelection"
label="fig:PlotSelection"></span>Using plotselection.</strong>
<strong>A</strong> Selected elements. <strong>B</strong> Selected
boundary.</figcaption>
</figure>
<p>When setting up a problem in <em>morpho</em>, it's very common to use Selection
objects to apply Functionals to limited parts of a Mesh. It's essential
to check that the Selections are correct, and <code>plotselection</code> provides
an easy way to do this. To illustrate this, let's select the lower right
hand elements in the Mesh,</p>
<pre><code>var s = Selection(m, fn (x,y,z) x&lt;=0 &amp;&amp; y&lt;=0)
s.addgrade(1)
</code></pre>
<p>and visualize the Selection as shown in Fig.
<a href="visualization/plot_module.html#fig:PlotSelection">6.3</a>{reference-type="ref"
reference="fig:PlotSelection"}A:</p>
<pre><code>var g = plotselection(m, s, grade=[0,1])
</code></pre>
<p>Similarly, we can select the boundary,</p>
<pre><code>var bnd = Selection(m, boundary=true)
</code></pre>
<p>and visualize the selection as shown in Fig.
<a href="visualization/plot_module.html#fig:PlotSelection">6.3</a>{reference-type="ref"
reference="fig:PlotSelection"}B:</p>
<pre><code>var gbnd = plotselection(m, bnd, grade=[0,1])
</code></pre>
<h4 id="fields-1"><a class="header" href="#fields-1">Fields</a></h4>
<p>Another important use of the <code>plot</code> module is to visualize scalar Field
objects. To illustrate this, we'll create an AreaMesh that has more
points,</p>
<pre><code>var m = AreaMesh(fn (u,v) [u, v, 0], -1..1:0.1, -1..1:0.1)
</code></pre>
<p>and a corresponding Field object[^6]:</p>
<pre><code>var f = Field(m, fn (x,y,z) sin(Pi*x)*sin(Pi*y))
</code></pre>
<p>By default, <code>plotfield</code> draws points at which the Field is defined, and
colors them by the value as in Fig.
<a href="visualization/plot_module.html#fig:PlotField">6.4</a>{reference-type="ref" reference="fig:PlotField"}A:</p>
<pre><code>var g = plotfield(f)
</code></pre>
<p>Alternatively, <code>plotfield</code> can draw higher order elements and
interpolate the coloring if you select the style option appropriately as
shown in Fig. <a href="visualization/plot_module.html#fig:PlotField">6.4</a>{reference-type="ref"
reference="fig:PlotField"}B:</p>
<pre><code>var g = plotfield(f, style="interpolate")
</code></pre>
<p>To aid interpretation of these plots, it's common to display a ScaleBar
object alongside the plot. These have quite a few options, including the
position and size, as well as the number of ticks and text layout.</p>
<pre><code>var sb = ScaleBar(posn=[1.2,0,0], length=1, textcolor=Black)
</code></pre>
<p>The scalebar is the then supplied as an optional argument to
<code>plotfield</code>. Here, we also use a different colormap object:</p>
<pre><code>var g = plotfield(f, style="interpolate", scalebar=sb, colormap=PlasmaMap())
</code></pre>
<p>The <code>color</code> module supplies a number of colormaps that you can try:
ViridisMap is used by default, but PlasmaMap, MagmaMap and InfernoMap
are also recommended and have been specially formulated to be accessible
to users with limited color perception[^7]. GrayMap and HueMap are also
available.</p>
<figure id="fig:PlotField">
<div class="centering">
<p><span class="sans-serif">A</span><img
src="../Figures/VisChapter/plotfield/fieldpts.png" style="width:2in"
alt="image" /><span class="sans-serif">B</span><img
src="../Figures/VisChapter/plotfield/interpolate.png" style="width:2in"
alt="image" /><span class="sans-serif">C</span><img
src="../Figures/VisChapter/plotfield/scalebar.png" style="width:2in"
alt="image" /></p>
</div>
<figcaption><strong><span id="fig:PlotField"
label="fig:PlotField"></span>Visualizing Fields with plotfield.</strong>
<strong>A</strong> By default, the field is displayed by coloring the
respective points. <strong>B</strong> Interpolated view.
<strong>C</strong> The same field with a scalebar added and a different
choice of colormap (here PlasmaMap) used.</figcaption>
</figure>
<div style="break-before: page; page-break-before: always;"></div><h2 id="sec:The-graphics-module" label="&quot;sec:The-graphics-module&quot;">The graphics module</h2>
<p>Support for low level graphics is provided by the <code>graphics</code> module,
which you can use this to create custom visualizations and generate
other kinds of graphical output. These can be easily combined with
output from the <code>plot</code> module, which utilizes <code>graphics</code> internally.</p>
<p>We begin by creating a Graphics object, which represents a <em>scene</em> or a
collection of things to be displayed.</p>
<pre><code>var g = Graphics()
</code></pre>
<p>Once the Graphics object is created, we can add <em>display elements</em>[^8],
objects specifying what is to be drawn, to the scene in turn. The
graphics module supports the following kinds of element:</p>
<ul>
<li>
<p><strong>Cylinder</strong> specified by two points at each end of the cylinder on
its axis. You can also specify the aspect ratio, i.e. the ratio of
the radius of the cylinder to its length, and the number of points
to draw.</p>
<pre><code>Cylinder([-1/2,-1/2,-1/2], [1/2,1/2,1/2], aspectratio=0.2, n=10)
</code></pre>
</li>
<li>
<p><strong>Arrow</strong> specified in the same way as a Cylinder, e.g.</p>
<pre><code>Arrow([-1/2,-1/2,-1/2], [1/2,1/2,1/2], aspectratio=0.2, n=10)
</code></pre>
</li>
<li>
<p><strong>Sphere</strong> specified by the center and the radius, e.g.</p>
<pre><code>Sphere([0,0,0], 0.8)
</code></pre>
</li>
<li>
<p><strong>Text</strong> specified by the text to display and the location to
display at. Many options can be provided, including the drawing
direction and the vertical direction, the size in points (1 graphics
unit=72 points), and the Font.</p>
<pre><code>Text("Hello World!", [-0.75,0,0], size=24, color=Black)
</code></pre>
</li>
<li>
<p><strong>Tube</strong> specified by a sequence of points and a radius. You can
also specify if the tube is closed or not.</p>
<pre><code>var pts = []
for (phi in -Pi..Pi:Pi/32) {
    pts.append([0.5*(1+0.3*sin(4*phi))*cos(phi), 0.5*(1+0.3*sin(4*phi))*sin(phi), 0]) 
}
g.display(Tube(pts, 0.05, color=Blue, closed=true))
</code></pre>
</li>
<li>
<p><strong>TriangleComplex</strong> describes a collection of triangles, which can
be used to display polyhedra and other complex objects. These
elements are low-level, and further information is available in the
reference section.</p>
</li>
</ul>
<p>Most of these elements accept certain optional arguments:</p>
<ul>
<li>
<p><strong>color</strong> to specify the color.</p>
</li>
<li>
<p><strong>transmit</strong> specifies the transparency of the element, which by
default is 0.</p>
</li>
<li>
<p><strong>filter</strong> alternative way of specifying transparency for use with
the povray module.</p>
</li>
</ul>
<p>Once appropriate elements have been created, we can display the Graphics
object with <code>morphoview</code> using Show.</p>
<pre><code>Show(g)
</code></pre>
<figure id="fig:GraphicsElements">
<div class="centering">
<p><span class="sans-serif">A</span><img
src="../Figures/VisChapter/primitives/cylinder.png" style="width:2in"
alt="image" /><span class="sans-serif">B</span><img
src="../Figures/VisChapter/primitives/arrow.png" style="width:2in"
alt="image" /><span class="sans-serif">C</span><img
src="../Figures/VisChapter/primitives/sphere.png" style="width:2in"
alt="image" /></p>
</div>
<div class="centering">
<p><span class="sans-serif">D</span><img
src="../Figures/VisChapter/primitives/text.png" style="width:2in"
alt="image" /><span class="sans-serif">E</span><img
src="../Figures/VisChapter/primitives/tube.png" style="width:2in"
alt="image" /><span class="sans-serif">F</span><img
src="../Figures/VisChapter/primitives/trianglecomplex.png"
style="width:2in" alt="image" /></p>
</div>
<figcaption><strong><span id="fig:GraphicsElements"
label="fig:GraphicsElements"></span>Graphics elements.</strong>
<strong>A</strong> Cylinder <strong>B</strong> Arrow <strong>C</strong>
Sphere <strong>D</strong> Text <strong>E</strong> Tube and
<strong>F</strong> TriangleComplex.</figcaption>
</figure>
<h4 id="example-visualizing-an-electric-field" class="unnumbered"><a class="header" href="#example-visualizing-an-electric-field">Example: Visualizing an electric field</a></h4>
<figure id="fig:ElectricField">
<div class="centering">
<img src="visualization/../Figures/VisChapter/electricexample/electric.png"
style="width:5in" />
</div>
<figcaption><strong><span id="fig:ElectricField"
label="fig:ElectricField"></span>Electric field due to a
dipole.</strong> Custom visualization created using the graphics
module.</figcaption>
</figure>
<p>As an illustration of what's possible using the <code>graphics</code> module
directly, we'll create a visualization of the electric field due to two
point charges (Fig. <a href="visualization/graphics_module.html#fig:ElectricField">6.6</a>{reference-type="ref"
reference="fig:ElectricField"}). Begin by setting some constants and
creating the Graphics object:</p>
<pre><code>var L = 2 // Size of domain to draw
var R = 1 // Separation of the charges
var dx = 0.125 // Spacing of points to draw
var eps = 1e-10 // Check for zero separation

var g = Graphics() 
</code></pre>
<p>We'll now define the charges by creating two List objects: one contains
the strength of each charge and the second stores their positions:</p>
<pre><code>// Electric field due to a system of point charges
var qq = [1,-1] 
var xq = [ Matrix([-R/2, 0, 0]), Matrix([R/2, 0, 0])]
</code></pre>
<p>We'll also define a cutoff distance around each charge below which we
won't draw the electric field (remember it grows \(\to\infty\) as we get
closer!):</p>
<pre><code>var cutoff = 0.2
</code></pre>
<p>Next, we need a function that calculates the electric field at an
arbitary point. We do this by summing up the electric fields due to each
charge using Coulomb's law:</p>
<pre><code>fn efield(x) {
   var e = 0
   for (q, k in qq) {
    var r=x-xq[k]
    if (r.norm()&lt;cutoff) return nil
    e+=q*r/(r.norm()^3) // = 1/r^2 * \hat{r}
  }
  return e
 }
</code></pre>
<p>To draw the electric field, we create a rectangular grid of points,
calculate the electric field at each point and draw an Arrow along the
orientation.</p>
<pre><code>var lambda = dx/10
for (x in -L..L:dx) for (y in -L..L:dx) {
  var x0 = Matrix([x,y,0])
  var E = efield(x0)
  if (isnil(E)) continue
  if (E.norm()&gt;eps) g.display(Arrow(x0-lambda*E,x0+lambda*E))
}
</code></pre>
<p>We now draw the charges, coloring them by their sign:</p>
<pre><code>for (q,k in qq) {
  var col = Red
  if (q&lt;0) col = Blue
  g.display(Sphere(xq[k],dx/4,color=col))
}
</code></pre>
<p>Finally, we display the scene:</p>
<pre><code>Show(g)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="the-povray-module"><a class="header" href="#the-povray-module">The povray module</a></h2>
<p>All figures in this manual have been exported directly from the <em>morpho</em>
programs that created them using the persistence of vision raytracer or
<code>povray</code>. A raytracer is a program that takes a scene description and
renders graphical output by tracing the path of individual rays of
light. Because the model of light propagation and image formation is
physically motivated, the output is of very high quality. By contrast,
<code>morphoview</code> and most graphics programs use simplified approximate
rendering techniques that enable real time interactive output. At the
time of writing, raytracing is gaining popularity as a technique, and
some high performance graphics cards now have real time raytracing
capability. <code>povray</code> is a very well established program that is widely
available and cross platform.</p>
<p>To use the <code>povray</code> module, you need to create a POVRaytracer object and
initialize it with the graphics object</p>
<pre><code>import povray

var pov = POVRaytracer(g)
</code></pre>
<p>You can choose features of the graphics out by setting properties of
this object, for example:</p>
<pre><code>pov.viewpoint = Matrix([5,5,6]) // Sets where the camera is located
pov.viewangle = 18 // Controls the angular size of the view
pov.background = White // Sets the background for rendering
pov.light=[Matrix([10,10,10]), Matrix([0,0,10]), Matrix([-10,-10,10])] // Places light point sources at several positions
</code></pre>
<p>Because the list of properties can get quite cumbersome, it's possible
to specify them through a separate Camera object and initialize the
raytracer to use the Camera:</p>
<pre><code>var pov = POVRaytracer(g, camera=cam)
</code></pre>
<p>See the Reference section for further details.</p>
<p>To produce output, call the render method to create a .pov file and run
povray:</p>
<pre><code>pov.render("graphic.pov")
</code></pre>
<p>By default, the resulting .png file is opened. You can stop this by
calling render with <code>display</code> set to <code>false</code>:</p>
<pre><code>pov.render("graphic.pov", display=false)
</code></pre>
<p>If you wish to simply create .pov file without running povray, use the
write method:</p>
<pre><code>pov.write("graphic.pov")
</code></pre>
<figure id="fig:Transparency">
<div class="centering">
<img src="visualization/../Figures/VisChapter/povray/transparency.png"
style="width:4in" />
</div>
<figcaption><strong><span id="fig:Transparency"
label="fig:Transparency"></span>Randomly generated spheres</strong>
rendered with random transparency.</figcaption>
</figure>
<p>A major advantage of raytracing is natural support for transparency
effects. Here we generate 50 spheres of random placement, size and
transparency by setting the <code>transmit</code> option. The rendered output is
shown in Fig. <a href="visualization/povray_module.html#fig:Transparency">6.7</a>.</p>
<pre><code>fn randompt(R) {
    return R*Matrix([random()-1/2, random()-1/2, random()-1/2])
}

for (i in 1..50) {
    g.display(Sphere(randompt(1.5), random()/5, transmit=random()))
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chap:Examples" label="&quot;chap:Examples&quot;">Examples</h1>
<p>This chapter discusses the example programs provided to illustrate
various <em>morpho</em> features. These can be found in the <code>examples</code> folder
of the morpho git repository and are listed here in alphabetical order.
Some closely relate to material presented in other chapters for which
cross-references are provided.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="catenoid"><a class="header" href="#catenoid">Catenoid</a></h2>
<figure id="fig:Catenoid">
<div class="centering">
<p><img src="examples/../Figures/ExamplesChapter/catenoid/catenoid-before.png"
style="width:3in" alt="image" /><img
src="../Figures/ExamplesChapter/catenoid/catenoid-after.png"
style="width:3in" alt="image" /></p>
</div>
<figcaption><strong><span id="fig:Catenoid"
label="fig:Catenoid"></span>Catenoid.</strong> (left) initial mesh
before optimization and (right) after optimization. Only grade 1
elements are shown. Boundary elements are displayed in red.</figcaption>
</figure>
<p>A soap film held between two parallel concentric circular rings adopts
the shape of a minimal surface called a <em>catenoid.</em> This is a relatively
simple optimization problem, and hence is a good example for beginners
to <em>morpho</em>.</p>
<p>The initial mesh is created using AreaMesh in the <code>meshtools</code> module:</p>
<pre><code>var r = 1.0 // radius
var ratio = 0.4 // Separation to diameter ratio
var L = 2*r*ratio // Separation

// Generate a tube / cylindrical mesh
var mesh = AreaMesh(fn (u, v) [r*cos(u), v, r*sin(u)],
                    -Pi...Pi:Pi/10,
                    -L/2..L/2:L/5,
                    closed=[true,false] )
mesh.addgrade(1)
</code></pre>
<p>The boundary of the mesh must be fixed in place. We can do this by
creating a Selection, and visualizing it as shown in Fig.
<a href="examples/catenoid.html#fig:Catenoid">7.1</a>{reference-type="ref" reference="fig:Catenoid"},
left panel:</p>
<pre><code>// Select the boundary
var bnd = Selection(mesh, boundary=true)
var g = plotselection(mesh, bnd, grade=1) 
</code></pre>
<p>The optimization problem simply requires us to specify the area as the
quantity to minimize:</p>
<pre><code> // Define the optimizataion problem
var problem = OptimizationProblem(mesh) 
// Add the area energy using the built-in Area functional
var area = Area()
problem.addenergy(area) 
</code></pre>
<p>We then create a ShapeOptimizer to perform the optimization,</p>
<pre><code>var opt = ShapeOptimizer(problem, mesh) 
</code></pre>
<p>fix the boundary elements using the selection object we created,</p>
<pre><code>opt.fix(bnd)
</code></pre>
<p>and perform the optimization. Conjugate gradient works well for this
problem and converges in a few iterations. The final optimized shape is
shown in Fig. <a href="examples/catenoid.html#fig:Catenoid">7.1</a>{reference-type="ref"
reference="fig:Catenoid"}, right panel.</p>
<pre><code>opt.conjugategradient(1000)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cholesteric"><a class="header" href="#cholesteric">Cholesteric</a></h2>
<p>A cholesteric liquid crystal, in contrast to a nematic liquid crystal as
was considered in the tutorial in Chapter X, favors a twisted state. The
liquid crystal elastic energy is modified to include a preferred chiral
wavevector \(q_{0}\),
$$F=\frac{1}{2}\int_{C}K_{11}\left(\nabla\cdot\mathbf{n}\right)^{2}+K_{22}(\mathbf{n}\cdot\nabla\times\mathbf{n}-q_{0})^{2}+K_{33}\left|\mathbf{n}\times\nabla\times\mathbf{n}\right|^{2}dA.\label{eq:CholestericFreeEnergy}$$
The cholesteric example minimizes Eq.
(<a href="examples/cholesteric.html#eq:CholestericFreeEnergy">[eq:CholestericFreeEnergy]</a>{reference-type="ref"
reference="eq:CholestericFreeEnergy"}) in a square domain
\((x,y)\in[-L,L]\), with \(L=1/2\), together with an anchoring energy,
$$W\int(\mathbf{n}\cdot\mathbf{\hat{y}})^{2}dl,$$ imposed on the top and
bottom boundaries to promote <em>planar degenerate</em> alignment, i.e.
\(\mathbf{n}\) prefers to lie any direction in the \(x-z\) plane. The
optimized structure with \(q_{0}=\pi/2\) is displayed in Fig.
(<a href="examples/cholesteric.html#fig:Cholesteric">7.2</a>{reference-type="ref"
reference="fig:Cholesteric"}).</p>
<figure id="fig:Cholesteric">
<div class="centering">
<img src="examples/../Figures/ExamplesChapter/cholesteric/cholesteric.png"
style="width:3in" />
</div>
<figcaption><span id="fig:Cholesteric"
label="fig:Cholesteric"></span><strong>Cholesteric liquid crystal on a
square domain.</strong></figcaption>
</figure>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cube"><a class="header" href="#cube">Cube</a></h2>
<figure id="fig:Cube">
<div class="centering">
<p><img src="examples/../Figures/ExamplesChapter/cube/cube-init.png"
style="width:3in" alt="image" /><img
src="../Figures/ExamplesChapter/cube/cube.png" style="width:3in"
alt="image" /></p>
</div>
<figcaption><strong><span id="fig:Cube" label="fig:Cube"></span>Minimal
surface at constant enclosed volume.</strong> (left) Initial cube
(right) Final optimized structure after 4 levels of
refinement.</figcaption>
</figure>
<p>This example finds a minimal surface with fixed enclosed volume, i.e. a
sphere. It closely parallels a similar example from <em>Surface Evolver</em>,
and hence may aid those familiar with that program in learning to use
<em>morpho</em>. Starting from an initial cube, shown in Fig.
(<a href="examples/cube.html#fig:Cube">7.3</a>{reference-type="ref" reference="fig:Cube"}), and
created as follows:</p>
<pre><code> // Create an initial cube
var m = PolyhedronMesh([ [-0.5, -0.5, -0.5],
                         [ 0.5, -0.5, -0.5],
                         [-0.5,  0.5, -0.5],
                         [ 0.5,  0.5, -0.5],
                         [-0.5, -0.5,  0.5],
                         [ 0.5, -0.5,  0.5],
                         [-0.5,  0.5,  0.5],
                         [ 0.5,  0.5,  0.5]],
                       [ [0,1,3,2], [4,5,7,6],
                         [0,1,5,4], [3,2,6,7],
                         [0,2,6,4], [1,3,7,5] ])
</code></pre>
<p>The problem and optimizer are set up:</p>
<pre><code>var problem = OptimizationProblem(m)
var la = Area()
problem.addenergy(la)

var lv = VolumeEnclosed()
problem.addconstraint(lv)

var opt = ShapeOptimizer(problem, m)
</code></pre>
<p>The mesh is optimized, then refined, then reoptimized:</p>
<pre><code>var Nlevels = 4 // Levels of refinement
var Nsteps = 1000 // Maximum number of steps per refinement level

for (i in 1..Nlevels) {
  opt.conjugategradient(Nsteps)
  if (i==Nlevels) break
  // Refine
  var mr=MeshRefiner([m])
  var refmap = mr.refine()
  for (el in [problem, opt]) el.update(refmap)
  m = refmap[m]
}
</code></pre>
<p>And finally the resulting area is compared with the true area of a
sphere at the same volume:</p>
<pre><code>var V0=lv.total(m)
var Af=la.total(m)
var R=(V0/(4/3*Pi))^(1/3)
var area = 4*Pi*R^2
print "Final area: \\({Af} True area: \\){area} diff: \\({abs(Af-area)}"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="delaunay"><a class="header" href="#delaunay">Delaunay</a></h2>
<figure id="fig:Delaunay">
<div class="centering">
<p><img src="examples/../Figures/ExamplesChapter/delaunay/delaunay-2d.png"
style="width:3in" alt="image" /><img
src="../Figures/ExamplesChapter/delaunay/delaunay-3d.png" style="width:3in"
alt="image" /></p>
</div>
<figcaption><strong><span id="fig:Delaunay"
label="fig:Delaunay"></span>Delaunay triangulation.</strong> (left)
Triangulation of random 2D point cloud (right) Tetrahedralization of
random 3D point cloud.</figcaption>
</figure>
<p>This example demonstrates use of the <code>delaunay</code> module to create a
Delaunay triangulation from a point cloud. The triangulation generated
is explicitly checked for the property that no point other than the
vertices lies within the circumsphere of each triangle.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="dla"><a class="header" href="#dla">DLA</a></h2>
<figure id="fig:DLA">
<div class="centering">
<img src="examples/../Figures/ExamplesChapter/dla/dla.png" style="width:6in" />
</div>
<figcaption><span id="fig:DLA" label="fig:DLA"></span><strong>Aggregate
produced by diffusion limited aggregation.</strong></figcaption>
</figure>
<p>Diffusion Limited Aggregation is a process describing the formation of
aggregates of sticky particles. An initial seed particle of radius \)r\(
is placed at \)\mathbf{x}<em>{0}=(0,0,0)\(. Subsequent particles are added
one by one from initial random points
\)\mathbf{x}</em>{i}^{0}=R\mathbf{\xi}/|\mathbf{\xi}|\( where \)\xi\( is a
random point normally distributed in each axis; the construction
\)\mathbf{\xi}/|\mathbf{\xi}|$ generates a random point on the unit
sphere. In <em>morpho</em>, this looks like</p>
<pre><code>fn randompt() {
  var x = Matrix([randomnormal(), randomnormal(), randomnormal()])
  return R*x/x.norm() 
}
</code></pre>
<p>The mobile particle moves diffusively, according to
$$\mathbf{x}<em>{i}^{n+1}=\mathbf{x}</em>{i}^{n}+\delta\xi$$ where \(\delta\) is
a small number. As the particle moves, we check to see if it has
collided with any other particles,
$$\left|x_{i}-x_{j}\right|&lt;2r,\forall i\neq j,\label{eq:collisioncheck}$$
or if it has wandered out of bounds, $$\left|x_{i}\right|&gt;2R.$$ If a
particle has collided with another particle, it becomes fixed in place
and joins the aggregate. As particles are added, the aggregate develops
a characteristic fractalline morphology as shown in Fig.
<a href="examples/dla.html#fig:DLA">7.5</a>{reference-type="ref" reference="fig:DLA"}. The body of
the program is a double loop:</p>
<pre><code>for (n in 1..Np) { // Add particles one-by-one  
  var x = randompt()
  while (true) {
    // Move current particle
    x+=Matrix([delta*randomnormal(), delta*randomnormal(), delta*randomnormal()])

    // Check for collisions
    /* ... */

    // Catch if it wandered out of the boundary
    if (x.norm()&gt;2*R) x = randompt() 
  }
}
</code></pre>
<p>To perform the collision check, the example uses a data structure called
a \(k\)-dimensional tree, provided in the <code>kdtree</code> module. A
\(k\)-dimensional tree provides a nearest neighbor search with \(O(\log N)\)
complexity rather than \(O(N)\) complexity as would be required by
searching all the points directly. The collision check code looks like
this:</p>
<pre><code>if ((tree.nearest(x).location-x).norm()&lt;2*r) {
  tree.insert(x)
  pts.append(x)
  if (x.norm()&gt;R/2) R = 2*x.norm()
  break // Move to next particle
}
</code></pre>
<p>Notice that we gradually expand \(R\) as the aggregate grows. Ideally,
each point should start very far away, really at infinity, but this
would be very expensive in terms of the number of diffusion steps. A
value of \(R\) double the greatest extent of the aggregate is a good
compromise between speed and a reasonable approximation of diffusion
limited aggregation.</p>
<p>This example also demonstrates how to create a simple custom
visualization directly using the <code>graphics </code>module. The particles are
drawn as spheres and displayed with the following code. An example run
is displayed in Fig. <a href="examples/dla.html#fig:DLA">7.5</a>{reference-type="ref"
reference="fig:DLA"}.</p>
<pre><code>var col = Gray(0.5)
var g = Graphics()
g.background = White
for (x in pts) g.display(Sphere(x, r, color=col))
Show(g)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="electrostatics"><a class="header" href="#electrostatics">Electrostatics</a></h2>
<p>This example shows how to solve a simple electrostatics problem with
adaptive refinement, and provides a useful example of how to cast a
problem that is normally thought of as solving a PDE as an optimization
problem.</p>
<p>Suppose we want to solve Laplace's equation, $$\nabla^{2}\phi=0$$ on a
square domain \(C\) defined by \(-L/2\leq x\leq L/2\) and
\(-L/2\leq y\leq L/2\). An equivalent formulation suitable for <em>morpho</em> is
to minimize, $$\int_{C}\left|\nabla\phi\right|^{2}dA\label{eq:el1}$$
with respect to \(\phi\).</p>
<p>We can show the two are equivalent by applying calculus of
variations[^9] to the expression Eq.
(<a href="examples/electrostatics.html#eq:el1">[eq:el1]</a>{reference-type="ref" reference="eq:el1"}),
$$\begin{aligned}
\delta\int_{C}\left|\nabla\phi\right|^{2}dA &amp; =\int_{C}\delta\left|\nabla\phi\right|^{2}dA\
&amp; =\int_{C}\frac{\partial}{\partial\nabla\phi}\left|\nabla\phi\right|^{2}\cdot\delta\nabla\phi dA,
\end{aligned}$$ and integrating by parts, $$\begin{aligned}
\int_{C}\frac{\partial}{\partial\nabla\phi}\left|\nabla\phi\right|^{2}\cdot\delta\nabla\phi dA &amp; =\int_{\partial C}\nabla\phi\cdot\hat{\mathbf{s}}\delta\phi dl-\int_{C}\nabla\cdot\frac{\partial}{\partial\nabla\phi}\left|\nabla\phi\right|^{2}\delta\phi dA\nonumber \
&amp; =\int_{\partial C}\nabla\phi\cdot\hat{\mathbf{s}}\delta\phi dl-\int_{C}\nabla^{2}\phi\delta\phi dA,\label{eq:bulkvariations}
\end{aligned}$$ where \(\hat{\mathbf{s}}\) is the outward normal. Hence,
allowing for arbitrary variations \(\delta\phi\), in order for the bulk
integrand to vanish Laplace's equation \(\nabla^{2}\phi=0\) must be
satisfied. Similarly requiring the boundary integrand to vanish yields
the "natural" boundary condition \(\nabla\phi\cdot\hat{\mathbf{s}}=0\),
known as the Neumann boundary condition. In the absence of boundary
energies, solving \(\nabla^{2}\phi=0\) in \(C\) subject to
\(\nabla\phi\cdot\hat{\mathbf{s}}=0\) on \(\partial C\) yields the family of
uniform constant solutions \(\phi=\text{const}.\)</p>
<p>To impose boundary data, we will supplement Eq.
(<a href="examples/electrostatics.html#eq:el1">[eq:el1]</a>{reference-type="ref" reference="eq:el1"}) with
the additional functional,
$$\lambda\int_{\partial C}\left[\phi-\phi_{0}(\mathbf{x})\right]^{2}dl\label{eq:anchoring}$$
where the function \(\phi_{0}\) represents some imposed boundary
potential. Taking variations of this functional, $$\begin{aligned}
\delta\lambda\int_{\partial C}\left[\phi-\phi_{0}(\mathbf{x})\right]^{2}dl &amp; =\lambda\int_{\partial C}\frac{\partial}{\partial\phi}\left[\phi-\phi_{0}(\mathbf{x})\right]^{2}\delta\phi dl\nonumber \
&amp; =\lambda\int_{\partial C}2\left[\phi-\phi_{0}(\mathbf{x})\right]\delta\phi dl\label{eq:boundary}
\end{aligned}$$</p>
<p>Collecting the boundary terms from Eq.
(<a href="examples/electrostatics.html#eq:bulkvariations">[eq:bulkvariations]</a>{reference-type="ref"
reference="eq:bulkvariations"}) and Eq.
(<a href="examples/electrostatics.html#eq:boundary">[eq:boundary]</a>{reference-type="ref"
reference="eq:boundary"}), we obtain the equivalent boundary condition
on \(\phi\),
$$\nabla\phi\cdot\hat{\mathbf{s}}+2\lambda(\phi-\phi_{0})=0,$$ which is
known as a Robin boundary condition. As \(\lambda\to\infty\),
\(\phi\to\phi_{0}\) on the boundary, recovering a fixed boundary or
Dirichlet condition, while as \(\lambda\to0\), we recover the Neumann
conditions discussed earlier.</p>
<p>In the example, we will set \(\phi_{0}=0\) on the left and lower boundary
and \(\phi_{0}=1\) on the right and upper boundary, and use \(\lambda=100\).</p>
<p>The code illustrates a few <em>morpho</em> tricks. First, the following code is
used to select the left/bottom and upper/right sides of the mesh:</p>
<pre><code>var bnd = Selection(mesh, boundary=true)
var bnd1 = Selection(mesh, fn (x,y,z) abs(x+L/2)&lt;0.01 || abs(y+L/2)&lt;0.01)
var bnd2 = Selection(mesh, fn (x,y,z) abs(x-L/2)&lt;0.01 || abs(y-L/2)&lt;0.01)
for (b in [bnd1, bnd2]) b.addgrade(1)
bnd1=bnd.intersection(bnd1)
bnd2=bnd.intersection(bnd2)
</code></pre>
<p>What's happening here is that we select the whole boundary in the first
line and then select relevant vertices in the next two lines. The edges
are then added to the selection with <code>addgrade</code>, but this also selects
some interior edges. To ensure we only have boundary edges in our
selections, we find the intersection of <code>bnd1</code> and <code>bnd</code>, and similarly
for <code>bnd2</code>.</p>
<p>The problem setup involves adding the electrostatic energy Eq.
(<a href="examples/electrostatics.html#eq:el1">[eq:el1]</a>{reference-type="ref" reference="eq:el1"}) using
<code>GradSq</code> and the boundary terms Eq.
(<a href="examples/electrostatics.html#eq:anchoring">[eq:anchoring]</a>{reference-type="ref"
reference="eq:anchoring"}) as <code>LineIntegral</code>s.</p>
<pre><code>var problem = OptimizationProblem(mesh)
var le = GradSq(phi)
problem.addenergy(le)
var v1 = 0, v2 = 1
var lt1 = LineIntegral(fn (x, v) (v-v1)^2, phi)
problem.addenergy(lt1, selection=bnd1, prefactor=100)
var lt2 = LineIntegral(fn (x, v) (v-v2)^2, phi)
problem.addenergy(lt2, selection=bnd2, prefactor=100) 
</code></pre>
<p>Optimization is done with a <code>FieldOptimizer</code>:</p>
<pre><code>var opt = FieldOptimizer(problem, phi)
opt.conjugategradient(100)
</code></pre>
<p>The problem as posed requires \(\phi\) to very sharply change in the upper
left and lower right cornes as the imposed potential changes, but far
away from these \(\phi\) changes much more slowly. We would like therefore
to perform <em>adaptive refinement</em>, refining the mesh only in places where
\(\phi\) is rapidly changing and using coarse elements elsewhere.</p>
<p>To identify elements to refine, we compute the electrostatic energy in
each elementwe'll use this as a heuristic measure of how rapidly \(\phi\)
is changingand find the mean energy per element. We then create a
Selection and manually select elements that have an electrostatic energy
more than \(1.5\times\) the mean.</p>
<pre><code>// Select elements that have an above average contribution to the energy 
var en = le.integrand(phi) // energy in each element
var mean = en.sum()/en.count() // mean energy per element
var srefine = Selection(mesh)
for (id in 0...en.count()) if (en[0,id]&gt;1.5*mean) srefine[2,id]=true 
// identify large contributions
</code></pre>
<p>Refinement is then performed with a MeshRefiner object from the
<code>meshtools</code> module, which we create with a list of both the mesh to
refine <em>and</em> all quantities that refer to the mesh:</p>
<pre><code>var ref = MeshRefiner([mesh, phi, bnd, bnd1, bnd2])
</code></pre>
<p>The refinement is performed using the selection <code>srefine</code> just created</p>
<pre><code>var refmap = ref.refine(selection=srefine)
</code></pre>
<p>which returns a Dictionary mapping the old quantities to the new refined
ones. We use this dictionary to update the OptimizationProblem and
FieldOptimizer,</p>
<pre><code>for (el in [problem, opt]) el.update(refmap)
</code></pre>
<p>and finally update our variables</p>
<pre><code>mesh = refmap[mesh]
phi = refmap[phi]
bnd = refmap[bnd]
bnd1 = refmap[bnd1]
bnd2 = refmap[bnd2]
</code></pre>
<p>Finally, we equiangulate the mesh to help avoid narrow elements,</p>
<pre><code>equiangulate(mesh)
</code></pre>
<p>Once refinement is complete, further optimization can occur on the newly
refined mesh</p>
<pre><code>opt.conjugategradient(1000)
</code></pre>
<p>The process of refinement and optimization just described takes place in
a loop. The resulting mesh after 10 iterations is shown in Fig.
<a href="examples/electrostatics.html#fig:Electrostatics">7.6</a>{reference-type="ref"
reference="fig:Electrostatics"}, together with the solution \(\phi\). The
code runs in a few seconds, providing a considerable speedup over
optimizing on a fine grid to get comparable accuracy.</p>
<figure id="fig:Electrostatics">
<div class="centering">
<p><img
src="../Figures/ExamplesChapter/electrostatics/electrostatics-mesh.png"
style="width:3in" alt="image" /><img
src="../Figures/ExamplesChapter/electrostatics/electrostatics-result.png"
style="width:3in" alt="image" /></p>
</div>
<figcaption><span id="fig:Electrostatics"
label="fig:Electrostatics"></span><strong>Electrostatics problem on a
square domain</strong> (left) mesh after 10 iterations of adaptive
refinement and optimization and (right) the resulting solution. Grade 1
elements are shown to emphasize the mesh structure.</figcaption>
</figure>
<div style="break-before: page; page-break-before: always;"></div><h2 id="implicitmesh"><a class="header" href="#implicitmesh">Implicitmesh</a></h2>
<p>These examples illustrate how to use the <code>implicitmesh</code> module to
generate surfaces described as the zero set of a scalar function. The
<code>sphere.morpho</code> and <code>torus.morpho</code> examples are described more fully in
Chapter X, Section Y. The remaining <code>threesurface.morpho</code> creates a
triangulation of a surface with three handles,
$$r_{z}^{4}z^{2}-\left(1-\left(\frac{x}{r_{x}}\right)^{2}-\left(\frac{y}{r_{y}}\right)^{2}\right)\left((x-x_{1})^{2}+y^{2}-r_{1}^{2}\right)\left((x+x_{1})^{2}+y^{2}-r_{1}^{2}\right)\left(x^{2}+y^{2}-r_{1}^{2}\right)=0,$$
where \(r_{x}\), \(r_{y}\), \(r_{z}\), \(r_{1}\) and \(x_{1}\) are parameters. The
resulting surface is shown in Fig.
<a href="examples/implicitmesh.html#fig:Threesurface">7.7</a>{reference-type="ref"
reference="fig:Threesurface"}.</p>
<figure id="fig:Threesurface">
<div class="centering">
<img src="examples/../Figures/ExamplesChapter/implicitmesh/threesurface.png"
style="width:4in" />
</div>
<figcaption><span id="fig:Threesurface"
label="fig:Threesurface"></span><strong>Surface with three
handles</strong> generated with the <code>implicitmesh</code>
module.</figcaption>
</figure>
<div style="break-before: page; page-break-before: always;"></div><h2 id="meshgen"><a class="header" href="#meshgen">Meshgen</a></h2>
<p>Examples in this folder illustrate various techniques to create Meshes
with the <code>meshgen</code> module. Examples in two dimensions are shown in Fig.
<a href="examples/meshgen.html#fig:Meshgen-2D">7.8</a>{reference-type="ref" reference="fig:Meshgen-2D"};
those in 3D are shown in Fig. XXX. See also Chapter X, Section Y for
additional discussion of the <code>meshgen</code> module.</p>
<figure id="fig:Meshgen-2D">
<div class="centering">
<p><span class="sans-serif">A<img
src="../Figures/ExamplesChapter/meshgen/disk.png" style="width:3in"
alt="image" />B<img src="examples/../Figures/ExamplesChapter/meshgen/ellipse.png"
style="width:3in" alt="image" /></span></p>
</div>
<div class="centering">
<p><span class="sans-serif">C<img
src="../Figures/ExamplesChapter/meshgen/halfdisk.png" style="width:3in"
alt="image" />D<img
src="../Figures/ExamplesChapter/meshgen/overlappingdisks.png"
style="width:3in" alt="image" /></span></p>
</div>
<div class="centering">
<p><span class="sans-serif">E<img
src="../Figures/ExamplesChapter/meshgen/superellipse.png" style="width:3in"
alt="image" />F<img src="examples/../Figures/ExamplesChapter/meshgen/weighted.png"
style="width:3in" alt="image" /></span></p>
</div>
<figcaption><span id="fig:Meshgen-2D"
label="fig:Meshgen-2D"></span><strong>2D meshes created with
the</strong> <strong><code>meshgen</code></strong>
<strong>module.</strong> <strong>A</strong> <code>disk.morpho</code>,
<strong>B</strong> <code>ellipse.morpho</code>, <strong>C</strong>
<code>halfdisk.morpho</code>, <strong>D</strong>
<code>overlappingdisks.morpho</code>, <strong>E</strong>
<code>superellipse.morpho</code>, <strong>F</strong>
<code>weighted.morpho</code></figcaption>
</figure>
<figure id="fig:Meshgen-3D">
<div class="centering">
<p><span class="sans-serif">A<img
src="../Figures/ExamplesChapter/meshgen/sphere.png" style="width:3in"
alt="image" />B<img
src="../Figures/ExamplesChapter/meshgen/ellipsoidsection.png"
style="width:3in" alt="image" /></span></p>
</div>
<div class="centering">
<p><span class="sans-serif">C<img
src="../Figures/ExamplesChapter/meshgen/superellipsoid.png"
style="width:3in" alt="image" /></span></p>
</div>
<figcaption><span id="fig:Meshgen-3D"
label="fig:Meshgen-3D"></span><strong>3D meshes created with
the</strong> <strong><code>meshgen</code></strong>
<strong>module.</strong> <strong>A</strong> <code>sphere.morpho</code>,
<strong>B</strong><code> ellipsoidsection.morpho</code>,
<strong>C</strong> <code>superellipsoid.morpho.</code></figcaption>
</figure>
<div style="break-before: page; page-break-before: always;"></div><h2 id="meshslice"><a class="header" href="#meshslice">Meshslice</a></h2>
<figure id="fig:Meshslice">
<div class="centering">
<img src="examples/../Figures/ExamplesChapter/meshslice/meshslice2.png"
style="width:4in" />
</div>
<figcaption><strong><span id="fig:Meshslice"
label="fig:Meshslice"></span>Mesh sliced along three planes</strong>
showing a scalar field interpolated onto each slice.</figcaption>
</figure>
<p>This example shows how to use the <code>meshslice</code> module to create a slice
through a mesh for visualization purposes. The program uses a spherical
mesh,</p>
<pre><code>var m = Mesh("sphere.mesh")
m.addgrade(1)
m.addgrade(2)
</code></pre>
<p>and creates a couple of example Fields, one scalar,</p>
<pre><code>var phi = Field(m, fn (x,y,z) x+y+z)
</code></pre>
<p>and one vector,</p>
<pre><code>var nn = Field(m, fn (x,y,z) Matrix([x,y,z])/sqrt(x^2+y^2+z^2))
</code></pre>
<p>A MeshSlicer is created to do the slicing,</p>
<pre><code>var slice = MeshSlicer(m)
var slc = slice.slice([0,0,0], [1,0,0])
</code></pre>
<p>and then interpolated Fields along this slice are created too,</p>
<pre><code>var sphi = slice.slicefield(phi)
var snn = slice.slicefield(nn)
</code></pre>
<p>Grade 1 elements (edges) from the original mesh, together with the field
phi interpolated onto three different slices, are shown in Fig.
<a href="examples/meshslice.html#fig:Meshslice">7.10</a>{reference-type="ref" reference="fig:Meshslice"}.
The example program illustrates a few other different possibilities.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="plot"><a class="header" href="#plot">Plot</a></h2>
<p>This example illustrates drawing of meshes, plotting of fields, etc. See
Chapter X on visualization for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="povray"><a class="header" href="#povray">Povray</a></h2>
<p>Examples in this folder illustrates use of the <code>povray</code> module used to
produce publication quality renderings from within <em>morpho</em> programs.
All figures in this book were generated using this module.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="qtensor"><a class="header" href="#qtensor">Qtensor</a></h2>
<figure id="fig:Qtensor">
<div class="centering">
<img src="examples/../Figures/ExamplesChapter/qtensor/Qtensor_K_0.01.png"
style="width:4in" />
</div>
<figcaption><strong><span id="fig:Qtensor"
label="fig:Qtensor"></span></strong>Equilibrium configuration of nematic
LC in a disk described by the Q tensor formulation. The scalar order
parameter is shown as a density field; the local orientation extracted
from <span class="math inline">\(Q\)</span> is displayed as
cylinders.</figcaption>
</figure>
<p>This example demonstrates use of the alternative Q-tensor formulation of
nematic liquid crystal theory. We briefly present the necessary theory
in two subsections below, then describe the implementation in <em>morpho</em>.</p>
<h4 id="the-q-tensor"><a class="header" href="#the-q-tensor">The Q tensor</a></h4>
<p>In 2D, for a uniaxial nematic, we can define a Q-tensor:
$$Q_{ij}=S(n_{i}n_{j}-1/2\delta_{ij})$$ Here, the \(-1/2\delta_{ij}\) is
added for convenience, to make the matrix traceless:
$$\text{Tr}(\mathbf{Q})=Q_{ii}=S(n_{i}n_{i}-1/2\delta_{ii})=S(1-1/2(2))=0$$
Now, the Q-tensor is also symmetric by definition: $$Q_{ij}=Q_{ji}$$ Due
to these two reasons we can write the Q-tensor as a function of only
\(Q_{xx}\) and \(Q_{xy}\): $$\mathbf{Q}=\begin{bmatrix}Q_{xx} &amp; Q_{xy}\
Q_{xy} &amp; -Q_{xx}
\end{bmatrix}.$$</p>
<h4 id="elastic-energy-and-anchoring"><a class="header" href="#elastic-energy-and-anchoring">Elastic Energy and Anchoring</a></h4>
<p>The Landau-de Gennes equilibrium free energy for a nematic liquid
crystal can be written in terms of the Q-tensor: $$\begin{aligned}
F_{LDG}= &amp; \int_{\Omega}d^{2}{\bf x}\ \left(\frac{a_{2}}{2}\text{Tr}(\mathbf{Q}^{2})+\frac{a_{4}}{4}(\text{Tr}\mathbf{Q}^{2})^{2}+\frac{K}{2}(\nabla\mathbf{Q})^{2}\right)\
&amp; +\oint_{\partial\Omega}d{\bf x}\frac{1}{2}E_{A}\text{Tr}[(\mathbf{Q}-\mathbf{W})^{2}]
\end{aligned}$$ where \(a_{2}=(\rho-1)\) and \(a_{4}=(\rho+1)/\rho^{2}\) set
the isotropic to nematic transition with \(\rho\) being the
non-dimensional density. The system is in the isotropic state for
\(\rho&lt;1\) and in the nematic phase when \(\rho&gt;1\). In the nematic phase,
\(\ell_{n}=\sqrt{K/a_{2}}\) sets the nematic coherence length. Now,
$$\mathbf{Q}^{2}=\begin{bmatrix}Q_{xx} &amp; Q_{xy}\
Q_{xy} &amp; -Q_{xx}
\end{bmatrix}\begin{bmatrix}Q_{xx} &amp; Q_{xy}\
Q_{xy} &amp; -Q_{xx}
\end{bmatrix}=(Q_{xx}^{2}+Q_{xy}^{2})\begin{bmatrix}1 &amp; 0\
0 &amp; 1
\end{bmatrix}$$ Hence,
$$\text{Tr}(\mathbf{Q}^{2})=2(Q_{xx}^{2}+Q_{xy}^{2})$$ Similarly,
$$(\nabla\mathbf{Q})^{2}=\partial_{i}Q_{kj}\partial_{i}Q_{kj}=2{(\partial_{x}Q_{xx})^{2}+(\partial_{x}Q_{xy})^{2}+(\partial_{y}Q_{xx})^{2}+(\partial_{y}Q_{xy})^{2}}$$
Now, the second term is a boundary integral, with \(E_{A}\) being the
anchoring strength. \(\mathbf{W}\) is the tensor corresponding to the
boundary condition. For instance, for parallel anchoring,
$$W_{ij}=(t_{i}t_{j}-1/2\delta_{ij})$$ where \(t_{i}\) is a component of
the tangent vector at the boundary. \(\mathbf{W}\) is also a symmetric
traceless tensor with two independent components \(W_{xx}\) and \(W_{xy}\).
The boundary term becomes:
$$\text{Tr}[(\mathbf{Q}-\mathbf{W})^{2}]=2{Q_{xx}^{2}+Q_{xy}^{2}-2(Q_{xx}W_{xx}+Q_{xy}W_{xy})+W_{xx}^{2}+W_{xy}^{2}}$$</p>
<h4 id="optimization-problem"><a class="header" href="#optimization-problem">Optimization problem</a></h4>
<p>We can formulate all the preceding expressions in terms of vector
quantities: $$\vec{q}\equiv{Q_{xx},Q_{xy}}$$
$$\vec{w}\equiv{w_{xx},w_{xy}}$$ Thus,
$$\text{Tr}(\mathbf{Q}^{2})=2||\vec{q}||^{2}$$</p>
<p>$$(\nabla\mathbf{Q})^{2}=2||\nabla\vec{q}||^{2}$$</p>
<p>$$\text{Tr}[(\mathbf{Q}-\mathbf{W})^{2}]=2||\vec{q}-\vec{w}||^{2}$$ With
these, we want to minimize the area-integral of
$$F=\int_{\Omega}d^{2}{\bf x}\ \left(a_{2}||\vec{q}||^{2}+a_{4}||\vec{q}||^{4}+K||\nabla\vec{q}||^{2}\right)$$
together with the line-integral energy
$$\oint_{\partial\Omega}d{\bf x}\ E_{A}||\vec{q}-\vec{w}||^{2}$$</p>
<h4 id="implementation"><a class="header" href="#implementation">Implementation</a></h4>
<p>This free energy is readily set up in <em>morpho</em>. For this example, we
consider a 2D disk geometry with unit radius. We use \(\rho=1.3\), so that
we are deep in the nematic regime. We fix \(E_{\text{A}}=3\), which sets
strong anchoring at the boundary. With this strong tangential anchoring,
we get a topological charge of \(+1\) at the boundary, and this acts as a
constraint. When the nematic coherence length is comparable to the disk
diameter (\(\ell_{n}\sim R\)), the \(+1\) charge penetrates throughout the
disk, whereas if (\(\ell_{n}\ll R\)), then a formation with 2 \(+1/2\)
defects is more stable. To test this, we use two different values of
\(K\):, 0.01 and 1.0.</p>
<p>We first define all our parameters and import \(\texttt{disk.mesh}\) from
the tactoid example:</p>
<pre><code>var rho = 1.3 // Deep in the nematic phase
var EA = 3 // Anchoring strength
var K = 0.01 // Bending modulus

var a2 = (1-rho)
var a4 = (1+rho)/rho^2

var m = Mesh("disk.mesh")
var m = refinemesh(m) // Refining for a better result
var bnd = Selection(m, boundary=true)
bnd.addgrade(0) // add point elements
</code></pre>
<p>We define the Q-tensor in its vector form as discussed above,
initializing it to small random values:</p>
<pre><code>var q_tensor = Field(m, fn(x,y,z)
Matrix([0.01*random(1), 0.01*random(1)]))
</code></pre>
<p>Note that this incidentally makes the director parallel to a 45 degree
line. We now define the bulk energy, the anchoring energy and the
distortion free energy as follows:</p>
<pre><code>// Define bulk free energy
fn landau(x, q) {
  var qt = q.norm()
  var qt2=qt*qt
  return a2*qt2 + a4*qt2*qt2
}
// Define anchoring energy at the boundary
fn anchoring(x, q) {
  var t = tangent()
  var wxx = t[0]*t[0]-0.5
  var wxy = t[0]*t[1]
  return (q[0]-wxx)^2+(q[1]-wxy)^2
}

var bulk = AreaIntegral(landau, q_tensor)
var anchor = LineIntegral(anchoring, q_tensor)
var elastic = GradSq(q_tensor)
</code></pre>
<p>Equipped with the energies, we define the <code>OptimizationProblem</code>:</p>
<pre><code>var problem = OptimizationProblem(m)
problem.addenergy(bulk)
problem.addenergy(elastic, prefactor = K)
problem.addenergy(anchor, selection=bnd, prefactor=EA)
</code></pre>
<p>To minimize the energy with respect to the field, we define the
<code>FieldOptimizer</code> and perform a <code>linesearch</code>:</p>
<pre><code>var opt = FieldOptimizer(problem, q_tensor)
opt.linesearch(500)
</code></pre>
<h4 id="visualization"><a class="header" href="#visualization">Visualization</a></h4>
<p>For visualizing the final configuration, we use the same piece of code
we used for the tactoid example, and define some additional helper
functions to extract the director and the order from the Q-tensor:</p>
<pre><code>fn qtodirector(q) {
  var S = 2*q.norm()
  var Q = q/S
  var nx = sqrt(Q[0]+0.5)
  var ny = abs(Q[1]/nx)
  nx*=sign(Q[1])
  return Matrix([nx,ny,0])
}

fn qtoorder(q) {
  var S = 2*q.norm()
  return S
}
</code></pre>
<p>We use these to create Fields from <code>q_tensor</code>.</p>
<pre><code>// Convert the q-tensor to the director and order
var nn = Field(m, Matrix([1,0,0]))
for (i in 0...m.count()) nn[i]=qtodirector(q_tensor[i])
var S = Field(m, 0)
for (i in 0...m.count()) S[i]=qtoorder(q_tensor[i])
</code></pre>
<p>and display these, reusing the <code>visualize</code> function from the tactoid
tutorial example.</p>
<pre><code>var splot = plotfield(S, style="interpolate")
var gnn=visualize(m, nn, 0.05)
var gdisp = splot+gnn
Show(gdisp)
</code></pre>
<p>This creates beautiful plots of the nematic, displayed in Fig.
<a href="examples/qtensor.html#fig:Qtensor">7.11</a>{reference-type="ref" reference="fig:Qtensor"}. Like
the tactoid example, we can do adaptive mesh refinement based on the
elastic energy density as well.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="thomson"><a class="header" href="#thomson">Thomson</a></h2>
<figure id="fig:Thomson">
<div class="centering">
<img src="examples/../Figures/ExamplesChapter/thomson/thomson.png"
style="width:4in" />
</div>
<figcaption><strong><span id="fig:Thomson"
label="fig:Thomson"></span>Solution of the Thomson problem</strong> for
<span class="math inline">\(N=100\)</span> charges.</figcaption>
</figure>
<p>Consider \(N\) charges \(q\) with positions \(\mathbf{x}<em>{i}\) that are each
confined to lie on the unit sphere so that
\(\left|\mathbf{x}</em>{i}\right|=1\) that repel each other electrostatically
and hence whose configuration minimizes the energy,
$$\frac{k}{2}\sum_{i\neq j}\frac{q^{2}}{\left|\mathbf{x}<em>{i}-\mathbf{x}</em>{j}\right|}$$
The problem was posed by the physicist J. J. Thomson in 1904, in the
context of an early model for the structure of an atom.</p>
<p>To set this up in <em>morpho</em>, we begin by creating a mesh from a sequence
of random points using a MeshBuilder object from the <code>meshtools</code> module.
Notice that this is quite an unusual mesh; it consists of \(N\)
unconnected points with no connectivity information.</p>
<pre><code>var build = MeshBuilder()
for (i in 1..Np) {
  var x = Matrix([2*random()-1, 2*random()-1, 2*random()-1])
  x/=x.norm() // Project onto unit sphere
  build.addvertex(x)
}
var mesh = build.build()
</code></pre>
<p>The optimization problem is then specified. We use the PairwisePotential
functional from the <code>functionals</code> module and supply the Coulomb
potential \(1/r\), together with its derivative \(-1/r^{2}\) as anonymous
functions:</p>
<pre><code>var problem = OptimizationProblem(mesh)
var lv = PairwisePotential(fn (r) 1/r, fn (r) -1/r^2)
problem.addenergy(lv)
</code></pre>
<p>Constraining the particles to a sphere is implemented as a level set
constraint: We use the ScalarPotential functional as a local constraint
to ensure that each particle lies on the zero contour of the scalar
function \(x^{2}+y^{2}+z^{2}-1\), which defines the unit sphere.</p>
<pre><code>var lsph = ScalarPotential(fn (x,y,z) x^2+y^2+z^2-1) problem.addlocalconstraint(lsph) 
</code></pre>
<p>Optimization is then performed:</p>
<pre><code>var opt = ShapeOptimizer(problem, mesh)
opt.stepsize=0.01/sqrt(Np)
opt.relax(5)
opt.conjugategradient(1000)
</code></pre>
<p>Notice that we estimate the initial stepsize from the number of
particles. Since each particle will adopt a fraction \(1/N\) of the area,
the stepsize is \(\propto1/\sqrt{N}\). In practice, we find that taking a
few steps of gradient descent with relax helps condition the problem by
pushing any particles from the initially random distribution that
happened to be placed very close to one another apart. After this
<code>conjugategradient</code>works well and typically converges in around \(100\)
iterations.</p>
<p>A final interesting feature of this example is the use of a custom
visualization. We draw a sphere with a center of mass at the location at
each particle:</p>
<pre><code>var g = Graphics()
for (i in 0...mesh.count()) {
  g.display(Sphere(mesh.vertexposition(i),1/sqrt(Np)))
} 
g.display(Sphere([0,0,0],1))
Show(g)
</code></pre>
<p>A typical configuration resulting from this is shown in Fig.
<a href="examples/thomson.html#fig:Thomson">7.12</a>{reference-type="ref" reference="fig:Thomson"}. Note
that we made the large sphere transparent to render with the povray
module; this was achieved by adding the optional argument <code>transmit=0.3</code>
to the call to <code>Sphere</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="wrap"><a class="header" href="#wrap">Wrap</a></h2>
<figure id="fig:Wrap">
<div class="centering">
<img src="examples/../Figures/ExamplesChapter/wrap/wrap.png" style="width:4in" />
</div>
<figcaption><strong><span id="fig:Wrap" label="fig:Wrap"></span>Minimal
surface constrained to lie outside two ellipsoidal one-sided level set
constraints.</strong></figcaption>
</figure>
<p>The wrap example finds a minimal surface constrainted to lie outside two
ellipsoids. The solution, shown in Fig.
<a href="examples/wrap.html#fig:Wrap">7.13</a>{reference-type="ref" reference="fig:Wrap"}) could
represent, for example, a possible configuration for a fluid bridge
connecting two ellipsoidal particles.</p>
<p>The basic idea of this code is to "shrink wrap" the ellipsoids, starting
with an initial mesh is a cube that completely encloses them. This is
created with PolyhedronMesh from the <code>meshtools</code> module:</p>
<pre><code>// Create a initial cube
var L = 2
var cube = [[-L, -L, -L], [-L, -L, L], [-L, L, -L],
            [-L, L, L], [L, -L, -L], [L, -L, L],
            [L, L, -L], [L, L, L]]

var faces = [[7, 3, 1, 5], [7, 5, 4, 6], [7, 6, 2, 3], [3, 2, 0, 1], [0, 2, 6,   4], [1, 0, 4, 5]]

var m=PolyhedronMesh(cube, faces)
m=refinemesh(m)
</code></pre>
<p>The particles are implemented as level set constraints. A convenient
Ellipsoid class is defined to help create appropriate constraints,</p>
<pre><code>class Ellipsoid { // Construct with Ellipsoid(origin, principalradii)
  init(x, r) { 
    self.origin = x
    self.principalradii = r
  }
  // Returns a level set function for this Ellipsoid
  levelset() {
    fn phi (x,y,z) {
      var x0 = self.origin, rr = self.principalradii
      return ((x-x0[0])/rr[0])^2 + ((y-x0[1])/rr[1])^2 + ((z-x0[2])/rr[2])^2 - 1     
    }
    return phi
  }
  /* Analogous code for gradient() ... */
}
</code></pre>
<p>The <code>levelset</code> method manufactures a scalar function representing the
ellipsoid and suitable for use with the ScalarPotential functional. A
second method, <code>gradient</code>, returns the gradient of that function.</p>
<p>The two ellipsoids of interest are then created like so:</p>
<pre><code>var ell1 = Ellipsoid([0,1/2,0],[1/2,1/2,1])
var ell2 = Ellipsoid([0,-1/2,0],[1,1/2,1/2])
</code></pre>
<p>The optimization problem is set up to include the surface area subject
to satisfaction of the level set constraints; these are noted as
one-sided, i.e. satisfied if the mesh lies at any point outside the
constraint region.</p>
<pre><code>// We want to minimize the area
var la = Area() // Subject to level set constraints
var ls1 = ScalarPotential( ell1.levelset(), ell1.gradient() )
var ls2 = ScalarPotential( ell2.levelset(), ell2.gradient() )
var leq = EquiElement()

var problem = OptimizationProblem(m)
problem.addenergy(la)
problem.addlocalconstraint(ls1, onesided=true)
problem.addlocalconstraint(ls2, onesided=true) 
</code></pre>
<p>To promote mesh quality, a second regularization problem is set up:</p>
<pre><code>var reg = OptimizationProblem(m)
reg.addenergy(leq)
reg.addlocalconstraint(ls1, onesided=true)
reg.addlocalconstraint(ls2, onesided=true)
</code></pre>
<p>Optimization and refinement are performed iteratively:</p>
<pre><code>sopt.stepsize=0.025
sopt.steplimit=0.1
ropt.stepsize=0.01
ropt.steplimit=0.2
for (refine in 1..3) {
  for (i in 1..100) {
    sopt.relax(5)
    ropt.conjugategradient(1)
    equiangulate(m)
  }
  var mr=MeshRefiner([m])
  var refmap = mr.refine()
  for (el in [problem, reg, sopt, ropt]) el.update(refmap)
  m = refmap[m]
}
</code></pre>
<p>Note that we set <code>stepsize</code> and <code>steplimit</code> on each optimizer; these
values were found by trial and error. The initial shape is quite
extreme, and so we use <code>relax</code> for the main optimization problem which
is very robust. Calling <code>equiangulate</code> helps maintain mesh quality.</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="syntax"><a class="header" href="#syntax">Syntax</a></h1>
<p>Morpho provides a flexible object oriented language similar to other languages in the C family (like C++, Java and Javascript) with a simplified syntax.</p>
<p>Morpho programs are stored as plain text with the .morpho file extension. A program can be run from the command line by typing</p>
<pre><code>morpho5 program.morpho
</code></pre>
<h2 id="comments"><a class="header" href="#comments">Comments</a></h2>
<p>Two types of comment are available. The first type is called a 'line comment' whereby text after <code>//</code> on the same line is ignored by the interpreter.</p>
<pre><code>a.dosomething() // A comment
</code></pre>
<p>Longer 'block' comments can be created by placing text between <code>/*</code> and <code>*/</code>. Newlines are ignored</p>
<pre><code>/* This
   is
   a longer comment */
</code></pre>
<p>In contrast to C, these comments can be nested</p>
<pre><code>/* A nested /* comment */ */
</code></pre>
<p>enabling the programmer to quickly comment out a section of code.</p>
<h2 id="symbols"><a class="header" href="#symbols">Symbols</a></h2>
<p>Symbols are used to refer to named entities, including variables, classes, functions etc. Symbols must begin with a letter or underscore _ as the first character and may include letters or numbers as the remainder. Symbols are case sensitive.</p>
<pre><code>asymbol
_alsoasymbol
another_symbol
EvenThis123
YET_ANOTHER_SYMBOL
</code></pre>
<p>Classes are typically given names with an initial capital letter. Variable names are usually all lower case.</p>
<h2 id="newlines"><a class="header" href="#newlines">Newlines</a></h2>
<p>Strictly, morpho ends statements with semicolons like C, but in practice these are usually optional and you can just start a new line instead. For example, instead of</p>
<pre><code>var a = 1; // The ; is optional
</code></pre>
<p>you can simply use</p>
<pre><code>var a = 1
</code></pre>
<p>If you want to put several statements on the same line, you can separate them with semicolons:</p>
<pre><code>var a = 1; print a
</code></pre>
<p>There are a few edge cases to be aware of: The morpho parser works by accepting a newline anywhere it expects to find a semicolon. To split a statement over multiple lines, signal to morpho that you plan to continue by leaving the statement unfinished. Hence, do this:</p>
<pre><code>print a +
      1
</code></pre>
<p>rather than this:</p>
<pre><code>print a   // &lt; Morpho thinks this is a complete statement
      + 1 // &lt; and so this line will cause a syntax error
</code></pre>
<h2 id="booleans"><a class="header" href="#booleans">Booleans</a></h2>
<p>Comparison operations like <code>==</code>, <code>&lt;</code> and <code>&gt;=</code> return <code>true</code> or <code>false</code> depending on the result of the comparison. For example,</p>
<pre><code>print 1==2
</code></pre>
<p>prints <code>false</code>. The constants <code>true</code> or <code>false</code> are provided for you to use in your own code:</p>
<pre><code>return true
</code></pre>
<h2 id="nil"><a class="header" href="#nil">Nil</a></h2>
<p>The keyword <code>nil</code> is used to represent the absence of an object or value.</p>
<p>Note that in <code>if</code> statements, a value of <code>nil</code> is treated like <code>false</code>.</p>
<pre><code>if (nil) {
    // Never executed.
}
</code></pre>
<h2 id="blocks"><a class="header" href="#blocks">Blocks</a></h2>
<p>Code is divided into <em>blocks</em>, which are delimited by curly brackets like this:</p>
<pre><code>{
  var a = "Hello"
  print a
}
</code></pre>
<p>This syntax is used in function declarations, loops and conditional statements.</p>
<p>Any variables declared within a block become <em>local</em> to that block, and cannot be seen outside of it. For example,</p>
<pre><code>var a = "Foo"
{
  var a = "Bar"
  print a
}
print a
</code></pre>
<p>would print "Bar" then "Foo"; the version of <code>a</code> inside the code block is said to <em>shadow</em> the outer version.</p>
<h2 id="precedence"><a class="header" href="#precedence">Precedence</a></h2>
<p>Precedence refers to the order in which morpho evaluates operations. For example,</p>
<pre><code>print 1+2*3
</code></pre>
<p>prints <code>7</code> because <code>2*3</code> is evaluated before the addition; the operator <code>*</code> is said to have higher precedence than <code>+</code>.</p>
<p>You can always modify the order of evaluation by using parentheses:</p>
<pre><code>print (1+2)*3 // prints 9
</code></pre>
<h2 id="print"><a class="header" href="#print">Print</a></h2>
<p>The <code>print</code> keyword is used to print information to the console. It can be followed by any value, e.g.</p>
<pre><code>print 1
print true
print a
print "Hello"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="values"><a class="header" href="#values">Values</a></h1>
<p>Values are the basic unit of information in morpho: All functions in morpho accept values as arguments and return values.</p>
<h2 id="int"><a class="header" href="#int">Int</a></h2>
<p>Morpho provides integers, which work as you would expect in other languages, although you rarely need to worry about the distinction between floats and integers.</p>
<p>Convert a floating point number to an Integer:</p>
<pre><code>print Int(1.3) // expect: 1
</code></pre>
<p>Convert a string to an integer:</p>
<pre><code>print Int("10")+1 // expect: 11
</code></pre>
<h2 id="float"><a class="header" href="#float">Float</a></h2>
<p>Morpho provides double precision floating point numbers.</p>
<p>Convert a string to a floating point number:</p>
<pre><code>print Float("1.2e2")+1 // expect: 121
</code></pre>
<h2 id="ceil"><a class="header" href="#ceil">Ceil</a></h2>
<p>Returns the smallest integer larger than or equal to its argument:</p>
<pre><code>print ceil(1.3) // expect: 2
</code></pre>
<h2 id="floor"><a class="header" href="#floor">Floor</a></h2>
<p>Returns the largest integer smaller than or equal to its argument:</p>
<pre><code>print floor(1.3) // expect: 1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<p>Variables are defined using the <code>var</code> keyword followed by the variable name:</p>
<pre><code>var a
</code></pre>
<p>Optionally, an initial assignment may be given:</p>
<pre><code>var a = 1
</code></pre>
<p>Variables defined in a block of code are visible only within that block, so</p>
<pre><code>var greeting = "Hello"
{
    var greeting = "Goodbye"
    print greeting
}
print greeting
</code></pre>
<p>will print</p>
<p><em>Goodbye</em>
<em>Hello</em></p>
<p>Multiple variables can be defined at once by separating them with commas</p>
<pre><code>var a, b=2, c[2]=[1,2]
</code></pre>
<p>where each can have its own initializer (or not).</p>
<h2 id="indexing"><a class="header" href="#indexing">Indexing</a></h2>
<p>Morpho provides a number of collection objects, such as <code>List</code>, <code>Range</code>, <code>Array</code>, <code>Dictionary</code>, <code>Matrix</code> and <code>Sparse</code>, that can contain more than one value. Index notation (sometimes called subscript notation) is used to access elements of these objects.</p>
<p>To retrieve an item from a collection, you use the <code>[</code> and <code>]</code> brackets like this:</p>
<pre><code>var a = List("Apple", "Bag", "Cat")
print a[0]
</code></pre>
<p>which prints <em>Apple</em>. Note that the first element is accessed with <code>0</code> not <code>1</code>.</p>
<p>Similarly, to set an entry in a collection, use:</p>
<pre><code>a[0]="Adder"
</code></pre>
<p>which would replaces the first element in <code>a</code> with <code>"Adder"</code>.</p>
<p>Some collection objects need more than one index,</p>
<pre><code>var a = Matrix([[1,0],[0,1]])
print a[0,0]
</code></pre>
<p>and others such as <code>Dictionary</code> use non-numerical indices,</p>
<pre><code>var b = Dictionary()
b["Massachusetts"]="Boston"
b["California"]="Sacramento"
</code></pre>
<p>as in this dictionary of state capitals.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h1>
<p>Control flow statements are used to determine whether and how many times a selected piece of code is executed. These include:</p>
<ul>
<li><code>if</code> - Selectively execute a piece of code if a condition is met.</li>
<li><code>else</code> - Execute a different block of code if the test in an <code>if</code> statement fails.</li>
<li><code>for</code> - Repeatedly execute a section of code with a counter</li>
<li><code>while</code> - Repeatedly execute a section of code while a condition is true.</li>
</ul>
<h2 id="if"><a class="header" href="#if">If</a></h2>
<p><code>If</code> allows you to selectively execute a section of code depending on whether a condition is met. The simplest version looks like this:</p>
<pre><code>if (x&lt;1) print x
</code></pre>
<p>where the body of the loop, <code>print x</code>, is only executed if x is less than 1. The body can be a code block to accommodate longer sections of code:</p>
<pre><code>if (x&lt;1) {
    ... // do something
}
</code></pre>
<p>If you want to choose between two alternatives, use <code>else</code>:</p>
<pre><code>if (a==b) {
    // do something
} else {
    // this code is executed only if the condition is false
}
</code></pre>
<p>You can even chain multiple tests together like this:</p>
<pre><code>if (a==b) {
    // option 1
} else if (a==c) {
    // option 2
} else {
    // something else
}
</code></pre>
<h2 id="while"><a class="header" href="#while">While</a></h2>
<p>While loops repeat a section of code while a condition is true. For example,</p>
<pre><code>var k=1
while (k &lt;= 4) { print k; k+=1 }
       ^cond   ^body
</code></pre>
<p>prints the numbers 1 to 4. The loop has two sections: <code>cond</code> is the condition to be executed and <code>body</code> is the section of code to be repeated.</p>
<p>Simple loops like the above example, especially those that involve counting out a sequence of numbers, are more conveniently written using a <code>for</code> loop,</p>
<pre><code>for (k in 1..4) print k
</code></pre>
<p>Where <code>while</code> loops can be very useful is where the state of an object is being changed in the loop, e.g.</p>
<pre><code>var a = List(1,2,3,4)
while (a.count()&gt;0) print a.pop()
</code></pre>
<p>which prints 4,3,2,1.</p>
<h2 id="do"><a class="header" href="#do">Do</a></h2>
<p>A <code>do</code>...<code>while</code> loop repeats code while a condition is true---similar to a <code>while</code> loop---but the test happens at the end:</p>
<pre><code>var k=1
do {
  print k;
  k+=1
} while (k&lt;5)
</code></pre>
<p>which prints 1,2,3,4</p>
<p>Hence this type of loop executes at least one interation</p>
<h2 id="for"><a class="header" href="#for">For</a></h2>
<p>For loops allow you to repeatedly execute a section of code. They come in two versions: the simpler version looks like this,</p>
<pre><code>for (var i in 1..5) print i
</code></pre>
<p>which prints the numbers 1 to 5 in turn. The variable <code>i</code> is the <em>loop variable</em>, which takes on a different value each iteration. <code>1..5</code> is a range, which denotes a sequence of numbers. The <em>body</em> of the loop,  <code>print i</code>, is the code to be repeatedly executed.</p>
<p>Morpho will implicitly insert a <code>var</code> before the loop variable if it's missing, so this works too:</p>
<pre><code>for (i in 1..5) print i
</code></pre>
<p>If you want your loop variable to count in increments other than 1, you can specify a stepsize in the range:</p>
<pre><code>for (i in 1..5:2) print i
               ^step
</code></pre>
<p>Ranges need not be integer:</p>
<pre><code>for (i in 0.1..0.5:0.1) print i
</code></pre>
<p>You can also replace the range with other kinds of collection object to loop over their contents:</p>
<pre><code>var a = Matrix([1,2,3,4])
for (x in a) print x
</code></pre>
<p>Morpho iterates over the collection object using an integer <em>counter variable</em> that's normally hidden. If you want to know the current value of the counter (e.g. to get the index of an element as well as its value), you can use the following:</p>
<pre><code>var a = [1, 2, 3]
for (x, i in a) print "${i}: ${x}"
</code></pre>
<p>Morpho also provides a second form of <code>for</code> loop similar to that in C:</p>
<pre><code>for (var i=0; i&lt;5; i+=1) { print i }
     ^start   ^test ^inc.  ^body
</code></pre>
<p>which is executed as follows:
start: the variable <code>i</code> is declared and initially set to zero.
test: before each iteration, the test is evaluated. If the test is <code>false</code>, the loop terminates.
body: the body of the loop is executed.
inc: the variable <code>i</code> is increased by 1.</p>
<p>You can include any code that you like in each of the sections.</p>
<h2 id="break"><a class="header" href="#break">Break</a></h2>
<p><code>Break</code> is used inside loops to finish the loop early. For example</p>
<pre><code>for (i in 1..5) {
    if (i&gt;3) break // --.
    print i        //   | (Once i&gt;3)
}                  //   |
...                // &lt;-'
</code></pre>
<p>would only print 1, 2 and 3. Once the condition <code>i&gt;3</code> is true, the <code>break</code> statement causes execution to continue after the loop body.</p>
<p>Both <code>for</code> and <code>while</code> loops support break.</p>
<h2 id="continue"><a class="header" href="#continue">Continue</a></h2>
<p><code>Continue</code> is used inside loops to skip over the rest of an iteration. For example</p>
<pre><code>for (i in 1..5) {     // &lt;-.
    print "Hello"          |
    if (i&gt;3) continue // --'
    print i
}                     
</code></pre>
<p>prints "Hello" five times but only prints 1, 2 and 3. Once the condition <code>i&gt;3</code> is true, the <code>continue</code> statement causes execution to transfer to the start of the loop body.</p>
<p>Traditional <code>for</code> loops also support <code>continue</code>:</p>
<pre><code>                // v increment
for (var i=0; i&lt;5; i+=1) {
    if (i==2) continue
    print i
}
</code></pre>
<p>Since <code>continue</code> causes control to be transferred <em>to the increment section</em> in this kind of loop, here the program prints 0..4 but the number 2 is skipped.</p>
<p>Use of <code>continue</code> with <code>while</code> loops is possible but isn't recommended as it can easily produce an infinite loop!</p>
<pre><code>var i=0
while (i&lt;5) {
    if (i==2) continue
    print i
    i+=1
}
</code></pre>
<p>In this example, when the condition <code>i==2</code> is <code>true</code>, execution skips back to the start, but <code>i</code> <em>isn't</em> incremented. The loop gets stuck in the iteration <code>i==2</code>.</p>
<h2 id="try"><a class="header" href="#try">Try</a></h2>
<p>A <code>try</code> and <code>catch</code> statement allow you handle errors. For example</p>
<pre><code>try {
  // Do something
} catch {
  "Tag" : // Handle the error
}
</code></pre>
<p>Code within the block after the <code>try</code> keyword is executed. If an error is generated then Morpho looks to see if the tag associated with the error matches any of the labels in the <code>catch</code> block. If it does, the code after the matching label is executed. If no error occurs, the catch block is skipped entirely.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>A function in morpho is defined with the <code>fn</code> keyword, followed by the function's name, a list of parameters enclosed in parentheses, and the body of the function in curly braces. This example computes the square of a number:</p>
<pre><code>fn sqr(x) {
  return x*x
}
</code></pre>
<p>Once a function has been defined you can evaluate it like any other morpho function.</p>
<pre><code>print sqr(2)
</code></pre>
<h2 id="variadic"><a class="header" href="#variadic">Variadic</a></h2>
<p>As well as regular parameters, functions can also be defined with <em>variadic</em> parameters:</p>
<pre><code>fn func(x, ...v) {
    for (a in v) print a
}
</code></pre>
<p>This function can then be called with 1 or more arguments:</p>
<pre><code>func(1)
func(1, 2)
func(1, 2, 3) // All valid! 
</code></pre>
<p>The variadic parameter <code>v</code> captures all the extra arguments supplied. Functions cannot be defined with more than one variadic parameter.</p>
<p>You can mix regular, variadic and optional parameters. Variadic parameters come before optional parameters:</p>
<pre><code>fn func(x, ...v, optional=true) {
    // 
}
</code></pre>
<h2 id="optional"><a class="header" href="#optional">Optional</a></h2>
<p>Functions can also be defined with <em>optional</em> parameters:</p>
<pre><code>fn func(a=1) {
    print a 
}
</code></pre>
<p>Each optional parameter must be defined with a default value (here <code>1</code>). The function can then be called either with or without the optional parameter:</p>
<pre><code>func()    // a == 1 due to default value
func(a=2) // a == 2 supplied by the user
</code></pre>
<h2 id="return"><a class="header" href="#return">Return</a></h2>
<p>The <code>return</code> keyword is used to exit from a function, optionally passing a given value back to the caller. <code>return</code> can be used anywhere within a function. The below example calculates the <code>n</code> th Fibonacci number,</p>
<pre><code>fn fib(n) {
  if (n&lt;2) return n
  return fib(n-1) + fib(n-2)
}
</code></pre>
<p>by returning early if <code>n&lt;2</code>, otherwise returning the result by recursively calling itself.</p>
<h1 id="closures"><a class="header" href="#closures">Closures</a></h1>
<p>Functions in morpho can form <em>closures</em>, i.e. they can enclose information from their local context. In this example,</p>
<pre><code>fn foo(a) {
    fn g() { return a } 
    return g
}
</code></pre>
<p>the function <code>foo</code> returns a function that captures the value of <code>a</code>. If we now try calling <code>foo</code> and then calling the returned functions,</p>
<pre><code>var p=foo(1), q=foo(2) 
print p() // expect: 1 
print q() // expect: 2
</code></pre>
<p>we can see that <code>p</code> and <code>q</code> seem to contain different copies of <code>g</code> that encapsulate the value that <code>foo</code> was called with.</p>
<p>Morpho hints that a returned function is actually a closure by displaying it with double brackets:</p>
<pre><code>print foo(1) // expect: &lt;&lt;fn g&gt;&gt; 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="classes"><a class="header" href="#classes">Classes</a></h1>
<p>Classes are defined using the <code>class</code> keyword followed by the name of the class.
The definition includes methods  that the class responds to. The special <code>init</code> method
is called whenever an object is created.</p>
<pre><code>class Cake {
    init(type) {
        self.type = type
    }

    eat() {
        print "A delicious "+self.type+" cake"
    }
}
</code></pre>
<p>Objects are created by calling the class as if it was a function:</p>
<pre><code>var c = Cake("carrot")
</code></pre>
<p>Methods are called using the . operator:</p>
<pre><code>c.eat()
</code></pre>
<h2 id="is"><a class="header" href="#is">Is</a></h2>
<p>The <code>is</code> keyword is used to specify a class's superclass:</p>
<pre><code>class A is B {

}
</code></pre>
<p>All methods defined by the superclass <code>B</code> are copied into the new class <code>A</code>, <em>before</em> any methods specified in the class definition. Hence, you can replace methods from the superclass simply by defining a method with the same name.</p>
<h2 id="with"><a class="header" href="#with">With</a></h2>
<p>The <code>with</code> keyword is used together with <code>is</code> to insert additional methods into a class definition <em>without</em> making them the superclass. These are often called <code>mixins</code>. These methods are inserted after the superclass's methods. Multiple classes can be specified after <code>with</code>; they are added in the order specified.</p>
<pre><code>class A is B with C, D {

}
</code></pre>
<p>Here <code>B</code> is the superclass of <code>A</code>, but methods defined by <code>C</code> and <code>D</code> are also available to <code>A</code>. If <code>B</code>, <code>C</code> and <code>D</code> define methods with the same name, those in <code>C</code> take precedence over any in <code>B</code> and those in <code>D</code> take precedence over <code>B</code> and <code>C</code>.</p>
<h2 id="self"><a class="header" href="#self">Self</a></h2>
<p>The <code>self</code> keyword is used to access an object's properties and methods from within its definition.</p>
<pre><code>class Vehicle {
  init (type) { self.type = type }

  drive () { print "Driving my ${self.type}." }
}
</code></pre>
<h2 id="super"><a class="header" href="#super">Super</a></h2>
<p>The keyword <code>super</code> allows you to access methods provided by an object's superclass rather than its own. This is particularly useful when the programmer wants a class to extend the functionality of a parent class, but needs to make sure the old behavior is still maintained.</p>
<p>For example, consider the following pair of classes:</p>
<pre><code>class Lunch {
    init(type) { self.type=type }
}

class Soup is Lunch {
    init(type) {
        print "Delicious soup!"
        super.init(type)
    }
}
</code></pre>
<p>The subclass Soup uses <code>super</code> to call the original initializer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<p>Morpho is extensible and provides a convenient module system that works like standard libraries in other languages. Modules may define useful variables, functions and classes, and can be made available using the <code>import</code> keyword. For example,</p>
<pre><code>import color
</code></pre>
<p>loads the <code>color</code> module that provides functionality related to color.</p>
<p>You can create your own modules; they're just regular morpho files that are stored in a standard place. On UNIX platforms, this is <code>/usr/local/share/morpho/modules</code>.</p>
<h2 id="import"><a class="header" href="#import">Import</a></h2>
<p>Import provides access to the module system and including code from multiple source files.</p>
<p>To import code from another file, use import with the filename:</p>
<pre><code>import "file.morpho"
</code></pre>
<p>which immediately includes all the contents of <code>"file.morpho"</code>. Any classes, functions or variables defined in that file can now be used, which allows you to divide your program into multiple source files.</p>
<p>Morpho provides a number of built in modules--and you can write your own--which can be loaded like this:</p>
<pre><code>import color
</code></pre>
<p>which imports the <code>color</code> module.</p>
<p>You can selectively import symbols from a modules by using the <code>for</code> keyword:</p>
<pre><code>import color for HueMap, Red
</code></pre>
<p>which imports only the <code>HueMap</code> class and the <code>Red</code> variable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="help"><a class="header" href="#help">Help</a></h1>
<p>Morpho provides an online help system. To get help about a topic called <code>topicname</code>, type</p>
<pre><code>help topicname
</code></pre>
<p>A list of available topics is provided below and includes language keywords like <code>class</code>, <code>fn</code> and <code>for</code>, built in classes like <code>Matrix</code> and <code>File</code> or information about functions like <code>exp</code> and <code>random</code>.</p>
<p>Some topics have additional subtopics: to access these type</p>
<pre><code>help topic subtopic
</code></pre>
<p>For example, to get help on a method for a particular class, you could type</p>
<pre><code>help Classname.methodname
</code></pre>
<p>Note that <code>help</code> ignores all punctuation.</p>
<p>You can also use <code>?</code> as a shorthand synonym for <code>help</code></p>
<pre><code>? topic
</code></pre>
<p>A useful feature is that, if an error occurs, simply type <code>help</code> to get more information about the error.</p>
<h1 id="quit"><a class="header" href="#quit">Quit</a></h1>
<p>The <code>quit</code> CLI command quits <code>morpho</code> run in interactive mode and returns to the shell.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="builtin-functions"><a class="header" href="#builtin-functions">Builtin functions</a></h1>
<p>Morpho provides a number of built-in functions.</p>
<h2 id="random"><a class="header" href="#random">Random</a></h2>
<p>The <code>random</code> function generates a random number from a uniform distribution on the interval [0,1].</p>
<pre><code>print random() 
</code></pre>
<p>See also <code>randomnormal</code> and <code>randomint</code>.</p>
<h2 id="randomnormal"><a class="header" href="#randomnormal">Randomnormal</a></h2>
<p>The <code>randomnormal</code> function generates a random number from a normal (gaussian) distribution with unit variance and zero offset.</p>
<pre><code>print randomnormal() 
</code></pre>
<p>See also <code>random</code> and <code>randomint</code>.</p>
<h2 id="randomint"><a class="header" href="#randomint">Randomint</a></h2>
<p>The <code>randomint</code> function generates a random integer with a specified maximum value.</p>
<pre><code>print randomint(10) // Generates a random integer [0,10)
</code></pre>
<h2 id="isnil"><a class="header" href="#isnil">isnil</a></h2>
<p>Returns <code>true</code> if a value is <code>nil</code> or <code>false</code> otherwise.</p>
<h2 id="isint"><a class="header" href="#isint">isint</a></h2>
<p>Returns <code>true</code> if a value is an integer or <code>false</code> otherwise.</p>
<h2 id="isfloat"><a class="header" href="#isfloat">isfloat</a></h2>
<p>Returns <code>true</code> if a value is a floating point number or <code>false</code> otherwise.</p>
<h2 id="isbool"><a class="header" href="#isbool">isbool</a></h2>
<p>Returns <code>true</code> if a value is a boolean or <code>false</code> otherwise.</p>
<h2 id="isobject"><a class="header" href="#isobject">isobject</a></h2>
<p>Returns <code>true</code> if a value is an object or <code>false</code> otherwise.</p>
<h2 id="isstring"><a class="header" href="#isstring">isstring</a></h2>
<p>Returns <code>true</code> if a value is a string or <code>false</code> otherwise.</p>
<h2 id="isclass"><a class="header" href="#isclass">isclass</a></h2>
<p>Returns <code>true</code> if a value is a class or <code>false</code> otherwise.</p>
<h2 id="isrange"><a class="header" href="#isrange">isrange</a></h2>
<p>Returns <code>true</code> if a value is a range or <code>false</code> otherwise.</p>
<h2 id="isdictionary"><a class="header" href="#isdictionary">isdictionary</a></h2>
<p>Returns <code>true</code> if a value is a dictionary or <code>false</code> otherwise.</p>
<h2 id="islist"><a class="header" href="#islist">islist</a></h2>
<p>Returns <code>true</code> if a value is a list or <code>false</code> otherwise.</p>
<h2 id="isarray"><a class="header" href="#isarray">isarray</a></h2>
<p>Returns <code>true</code> if a value is an array or <code>false</code> otherwise.</p>
<h2 id="ismatrix"><a class="header" href="#ismatrix">ismatrix</a></h2>
<p>Returns <code>true</code> if a value is a matrix or <code>false</code> otherwise.</p>
<h2 id="issparse"><a class="header" href="#issparse">issparse</a></h2>
<p>Returns <code>true</code> if a value is a sparse matrix or <code>false</code> otherwise.</p>
<h2 id="isinf"><a class="header" href="#isinf">isinf</a></h2>
<p>Returns <code>true</code> if a value is infinite or <code>false</code> otherwise.</p>
<h2 id="isnan"><a class="header" href="#isnan">isnan</a></h2>
<p>Returns <code>true</code> if a value is a Not a Number or <code>false</code> otherwise.</p>
<h2 id="iscallable"><a class="header" href="#iscallable">iscallable</a></h2>
<p>Returns <code>true</code> if a value is callable or <code>false</code> otherwise.</p>
<h2 id="isfinite"><a class="header" href="#isfinite">isfinite</a></h2>
<p>Returns <code>true</code> if a value is finite or <code>false</code> otherwise.</p>
<pre><code>print isfinite(1) // expect: true 
print isfinite(1/0) // expect: false 
</code></pre>
<h2 id="isnumber"><a class="header" href="#isnumber">isnumber</a></h2>
<p>Returns <code>true</code> if a value is a real number, or <code>false</code> otherwise.</p>
<pre><code>print isnumber(1) // expect: true 
print isnumber(Object()) // expect: false
</code></pre>
<h2 id="ismesh"><a class="header" href="#ismesh">ismesh</a></h2>
<p>Returns <code>true</code> if a value is a <code>Mesh</code>, or <code>false</code> otherwise.</p>
<h2 id="isselection"><a class="header" href="#isselection">isselection</a></h2>
<p>Returns <code>true</code> if a value is a <code>Selection</code>, or <code>false</code> otherwise.</p>
<h2 id="isfield"><a class="header" href="#isfield">isfield</a></h2>
<p>Returns <code>true</code> if a value is a <code>Field</code>, or <code>false</code> otherwise.</p>
<h2 id="apply"><a class="header" href="#apply">Apply</a></h2>
<p>Apply calls a function with the arguments provided as a list:</p>
<pre><code>apply(f, [0.5, 0.5]) // calls f(0.5, 0.5) 
</code></pre>
<p>It's often useful where a function or method and/or the number of parameters isn't known ahead of time. The first parameter to apply can be any callable object, including a method invocation or a closure.</p>
<p>You may also instead omit the list and use apply with multiple arguments:</p>
<pre><code>apply(f, 0.5, 0.5) // calls f(0.5, 0.5)
</code></pre>
<p>There is one edge case that occurs when you want to call a function that accepts a single list as a parameter. In this case, enclose the list in another list:</p>
<pre><code>apply(f, [[1,2]]) // equivalent to f([1,2])
</code></pre>
<h2 id="abs"><a class="header" href="#abs">Abs</a></h2>
<p>Returns the absolute value of a number:</p>
<pre><code>print abs(-10) // prints 10 
</code></pre>
<h2 id="arctan"><a class="header" href="#arctan">Arctan</a></h2>
<p>Returns the arctangent of an input value that lies from <code>-Inf</code> to <code>Inf</code>. You can use one argument:</p>
<pre><code>print arctan(0) // expect: 0
</code></pre>
<p>or use two arguments to return the angle in the correct quadrant:</p>
<pre><code>print arctan(x, y)
</code></pre>
<p>Note the order <code>x</code>, <code>y</code> differs from some other languages.</p>
<h2 id="exp"><a class="header" href="#exp">Exp</a></h2>
<p>Exponential function <code>e^x</code>. Inverse of <code>log</code>.</p>
<pre><code>print exp(0) // expect: 1 
print exp(Pi*im) // expect: -1 + 0im
</code></pre>
<h2 id="log"><a class="header" href="#log">Log</a></h2>
<p>Natural logarithm function. Inverse of <code>exp</code>.</p>
<pre><code>print log(1) // expect: 0 
</code></pre>
<h2 id="log10"><a class="header" href="#log10">Log10</a></h2>
<p>Base 10 logarithm function.</p>
<pre><code>print log10(10) // expect: 1
</code></pre>
<h2 id="sin"><a class="header" href="#sin">Sin</a></h2>
<p>Sine trigonometric function.</p>
<pre><code>print sin(0) // expect: 0 
</code></pre>
<h2 id="sinh"><a class="header" href="#sinh">Sinh</a></h2>
<p>Hyperbolic sine trigonometric function.</p>
<pre><code>print sinh(0) // expect: 0 
</code></pre>
<h2 id="cos"><a class="header" href="#cos">Cos</a></h2>
<p>Cosine trigonometric function.</p>
<pre><code>print cos(0) // expect: 1
</code></pre>
<h2 id="cosh"><a class="header" href="#cosh">Cosh</a></h2>
<p>Hyperbolic cosine trigonometric function.</p>
<pre><code>print cosh(0) // expect: 1
</code></pre>
<h2 id="tan"><a class="header" href="#tan">Tan</a></h2>
<p>Tangent trigonometric function.</p>
<pre><code>print tan(0) // expect: 0 
</code></pre>
<h2 id="tanh"><a class="header" href="#tanh">Tanh</a></h2>
<p>Hyperbolic tangent trigonometric function.</p>
<pre><code>print tanh(0) // expect: 0 
</code></pre>
<h2 id="asin"><a class="header" href="#asin">Asin</a></h2>
<p>Inverse sine trigonometric function. Returns a value on the interval    <code>[-Pi/2,Pi/2]</code>.</p>
<pre><code>print asin(0) // expect: 0 
</code></pre>
<h2 id="acos"><a class="header" href="#acos">Acos</a></h2>
<p>Inverse cosine trigonometric function. Returns a value on the interval  <code>[-Pi/2,Pi/2]</code>.</p>
<pre><code>print acos(1) // expect: 0 
</code></pre>
<h2 id="sqrt"><a class="header" href="#sqrt">Sqrt</a></h2>
<p>Square root function.</p>
<pre><code>print sqrt(4) // expect: 2
</code></pre>
<h2 id="min"><a class="header" href="#min">Min</a></h2>
<p>Finds the minimum value of its arguments. If any of the arguments are Objects and are enumerable, (e.g. a <code>List</code>), <code>min</code> will search inside them for a minimum value. Accepts any number of arguments.</p>
<pre><code>print min(3,2,1) // expect: 1 
print min([3,2,1]) // expect: 1 
print min([3,2,1],[0,-1,2]) // expect: -2 
</code></pre>
<h2 id="max"><a class="header" href="#max">Max</a></h2>
<p>Finds the maximum value of its arguments. If any of the arguments are Objects and are enumerable, (e.g. a <code>List</code>), <code>max</code> will search inside them for a maximum value. Accepts any number of arguments.</p>
<pre><code>print min(3,2,1) // expect: 3 
print min([3,2,1]) // expect: 3
print min([3,2,1],[0,-1,2]) // expect: 3 
</code></pre>
<h2 id="bounds"><a class="header" href="#bounds">Bounds</a></h2>
<p>Returns both the results of <code>min</code> and <code>max</code> as a list, Providing a set of bounds for its arguments and any enumerable objects within them.</p>
<pre><code>print bounds(1,2,3) // expect: [1,3]
print bounds([3,2,1],[0,-1,2]) // expect: [-1,3]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="array"><a class="header" href="#array">Array</a></h1>
<p>Arrays are collection objects that can have any number of indices. Their size is set when they are created:</p>
<pre><code>var a[5]
var b[2,2]
var c[nv,nv,nv]
</code></pre>
<p>Values can be retrieved with appropriate indices:</p>
<pre><code>print a[0,0]
</code></pre>
<p>Array can be indexed with slices:</p>
<pre><code>print a[[0,2,4],2]
print a[1,0..2]
</code></pre>
<p>Any morpho value can be stored in an array element</p>
<pre><code>a[0,0] = [1,2,3]
</code></pre>
<h2 id="dimensions"><a class="header" href="#dimensions">Dimensions</a></h2>
<p>Get the dimensions of an Array object:</p>
<pre><code>var a[2,2]
print a.dimensions() // expect: [ 2, 2 ]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="complex"><a class="header" href="#complex">Complex</a></h1>
<p>Morpho provides complex numbers. The keyword <code>im</code> is used to denote the imaginary part of a complex number:</p>
<pre><code>var a=1+5im 
print a*a
</code></pre>
<p>Print values on the unit circle in the complex plane:</p>
<pre><code>import constants 
for (phi in 0..Pi:Pi/5) print exp(im*phi)
</code></pre>
<p>Get the real and imaginary parts of a complex number:</p>
<pre><code>print real(a) 
print imag(a) 
</code></pre>
<p>or alternatively:</p>
<pre><code>print a.real()
print a.imag() 
</code></pre>
<p>[showsuptopics]: # subtopics</p>
<h2 id="angle"><a class="header" href="#angle">Angle</a></h2>
<p>Returns the angle <code>phi</code> associated with the polar representation of a complex number <code>r*exp(im*phi)</code>:</p>
<pre><code>print z.angle() 
</code></pre>
<h2 id="conj"><a class="header" href="#conj">Conj</a></h2>
<p>Returns the complex conjugate of a number:</p>
<pre><code>print z.conj() 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="list"><a class="header" href="#list">List</a></h1>
<p>Lists are collection objects that contain a sequence of values each associated with an integer index.</p>
<p>Create a list like this:</p>
<pre><code>var list = [1, 2, 3]
</code></pre>
<p>Look up values using index notation:</p>
<pre><code>list[0]
</code></pre>
<p>Indexing can also be done with slices:
list[0..2]
list[[0,1,3]]</p>
<p>You can change list entries like this:</p>
<pre><code>list[0] = "Hello"
</code></pre>
<p>Create an empty list:</p>
<pre><code>var list = []
</code></pre>
<p>Loop over elements of a list:</p>
<pre><code>for (i in list) print i
</code></pre>
<h2 id="append"><a class="header" href="#append">Append</a></h2>
<p>Adds an element to the end of a list:</p>
<pre><code>var list = []
list.append("Foo")
</code></pre>
<h2 id="insert"><a class="header" href="#insert">Insert</a></h2>
<p>Inserts an element into a list at a specified index:</p>
<pre><code>var list = [1,2,3]
list.insert(1, "Foo")
print list // prints [ 1, Foo, 2, 3 ]
</code></pre>
<h2 id="pop"><a class="header" href="#pop">Pop</a></h2>
<p>Remove the last element from a list, returning the element removed:</p>
<pre><code>print list.pop()
</code></pre>
<p>If an integer argument is supplied, returns and removes that element:</p>
<pre><code>var a = [1,2,3]
print a.pop(1) // prints '2'
print a        // prints [ 1, 3 ]
</code></pre>
<h2 id="sort"><a class="header" href="#sort">Sort</a></h2>
<p>Sorts the contents of a list into ascending order:</p>
<pre><code>list.sort()
</code></pre>
<p>Note that this sorts the list "in place" (i.e. it modifies the order of the list on which it is invoked) and hence returns <code>nil</code>.</p>
<p>You can provide your own function to use to compare values in the list</p>
<pre><code>list.sort(fn (a, b) a-b)
</code></pre>
<p>This function should return a negative value if <code>a&lt;b</code>, a positive value if <code>a&gt;b</code> and <code>0</code> if <code>a</code> and <code>b</code> are equal.</p>
<h2 id="order"><a class="header" href="#order">Order</a></h2>
<p>Returns a list of indices that would, if used in order, would sort a list. For example</p>
<pre><code>var list = [2,3,1]
print list.order() // expect: [2,0,1]
</code></pre>
<p>would produce <code>[2,0,1]</code></p>
<h2 id="remove"><a class="header" href="#remove">Remove</a></h2>
<p>Remove any occurrences of a value from a list:</p>
<pre><code>var list = [1,2,3]
list.remove(1)
</code></pre>
<h2 id="ismember"><a class="header" href="#ismember">ismember</a></h2>
<p>Tests if a value is a member of a list:</p>
<pre><code>var list = [1,2,3]
print list.ismember(1) // expect: true
</code></pre>
<h2 id="add"><a class="header" href="#add">Add</a></h2>
<p>Join two lists together:</p>
<pre><code>var l1 = [1,2,3], l2 = [4, 5, 6]
print l1+l2 // expect: [1,2,3,4,5,6]
</code></pre>
<h2 id="tuples"><a class="header" href="#tuples">Tuples</a></h2>
<p>Generate all possible 2-tuples from a list:</p>
<pre><code>var t = [ 1, 2, 3].tuples(2)
</code></pre>
<p>produces <code>[ [ 1, 1 ], [ 1, 2 ], [ 1, 3 ] ... ]</code>.</p>
<h2 id="sets"><a class="header" href="#sets">Sets</a></h2>
<p>Generate all possible sets of order 2 from a list.</p>
<pre><code>var t = [ 1, 2, 3 ].sets(2)
</code></pre>
<p>produces <code>[ [ 1, 2 ], [ 1, 3 ], [ 2, 3 ] ]</code>.</p>
<p>Note that sets include only distinct elements from the list (no element is repeated) and ordering is unimportant, hence only one of  <code>[ 1, 2 ]</code> and <code>[ 2, 1 ]</code> is returned.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="matrix"><a class="header" href="#matrix">Matrix</a></h1>
<p>The Matrix class provides support for matrices. A matrix can be initialized with a given size,</p>
<pre><code>var a = Matrix(nrows,ncols)
</code></pre>
<p>where all elements are initially set to zero. Alternatively, a matrix can be created from an array,</p>
<pre><code>var a = Matrix([[1,2], [3,4]])
</code></pre>
<p>or a Sparse matrix,</p>
<pre><code>var a = Sparse([[0,0,1],[1,1,1],[2,2,1]])
var b = Matrix(a)
</code></pre>
<p>You can create a column vector like this,</p>
<pre><code>var v = Matrix([1,2])
</code></pre>
<p>Finally, you can create a Matrix by assembling other matrices like this,</p>
<pre><code>var a = Matrix([[0,1],[1,0]])
var b = Matrix([[a,0],[0,a]]) // produces a 4x4 matrix 
</code></pre>
<p>Once a matrix is created, you can use all the regular arithmetic operators with matrix operands, e.g.</p>
<pre><code>a+b
a*b
</code></pre>
<p>The division operator is used to solve a linear system, e.g.</p>
<pre><code>var a = Matrix([[1,2],[3,4]])
var b = Matrix([1,2])

print b/a
</code></pre>
<p>yields the solution to the system a*x = b.</p>
<h2 id="assign"><a class="header" href="#assign">Assign</a></h2>
<p>Copies the contents of matrix B into matrix A:</p>
<pre><code>A.assign(B)
</code></pre>
<p>The two matrices must have the same dimensions.</p>
<h2 id="dimensions-1"><a class="header" href="#dimensions-1">Dimensions</a></h2>
<p>Returns the dimensions of a matrix:</p>
<pre><code>var A = Matrix([1,2,3]) // Create a column matrix 
print A.dimensions()    // Expect: [ 3, 1 ]
</code></pre>
<h2 id="eigenvalues"><a class="header" href="#eigenvalues">Eigenvalues</a></h2>
<p>Returns a list of eigenvalues of a Matrix:</p>
<pre><code>var A = Matrix([[0,1],[1,0]])
print A.eigenvalues() // Expect: [1,-1]
</code></pre>
<h2 id="eigensystem"><a class="header" href="#eigensystem">Eigensystem</a></h2>
<p>Returns the eigenvalues and eigenvectors of a Matrix:</p>
<pre><code>var A = Matrix([[0,1],[1,0]])
print A.eigensystem() 
</code></pre>
<p>Eigensystem returns a two element list: The first element is a List of eigenvalues. The second element is a Matrix containing the corresponding eigenvectors as its columns:</p>
<pre><code>print A.eigensystem()[0]
// [ 1, -1 ]
print A.eigensystem()[1]
// [ 0.707107 -0.707107 ]
// [ 0.707107 0.707107 ]
</code></pre>
<h2 id="inner"><a class="header" href="#inner">Inner</a></h2>
<p>Computes the Frobenius inner product between two matrices:</p>
<pre><code>var prod = A.inner(B)
</code></pre>
<h2 id="outer"><a class="header" href="#outer">Outer</a></h2>
<p>Computes the outer produce between two vectors:</p>
<pre><code>var prod = A.outer(B)
</code></pre>
<p>Note that <code>outer</code> always treats both vectors as column vectors.</p>
<h2 id="inverse"><a class="header" href="#inverse">Inverse</a></h2>
<p>Returns the inverse of a matrix if it is invertible. Raises a
<code>MtrxSnglr</code> error if the matrix is singular. E.g.</p>
<pre><code>var m = Matrix([[1,2],[3,4]])
var mi = m.inverse()
</code></pre>
<p>yields the inverse of the matrix <code>m</code>, such that mi*m is the identity
matrix.</p>
<h2 id="norm"><a class="header" href="#norm">Norm</a></h2>
<p>Returns a matrix norm. By default the L2 norm is returned:</p>
<pre><code>var a = Matrix([1,2,3,4])
print a.norm() // Expect: sqrt(30) = 5.47723...
</code></pre>
<p>You can select a different norm by supplying an argument:</p>
<pre><code>import constants
print a.norm(1) // Expect: 10 (L1 norm is sum of absolute values) 
print a.norm(3) // Expect: 4.64159 (An unusual choice of norm)
print a.norm(Inf) // Expect: 4 (Inf-norm corresponds to maximum absolute value)
</code></pre>
<h2 id="reshape"><a class="header" href="#reshape">Reshape</a></h2>
<p>Changes the dimensions of a matrix such that the total number of elements remains constant:</p>
<pre><code>var A = Matrix([[1,3],[2,4]])
A.reshape(1,4) // 1 row, 4 columns
print A // Expect: [ 1, 2, 3, 4 ]
</code></pre>
<p>Note that elements are stored in column major-order.</p>
<h2 id="sum"><a class="header" href="#sum">Sum</a></h2>
<p>Returns the sum of all entries in a matrix:</p>
<pre><code>var sum = A.sum() 
</code></pre>
<h2 id="transpose"><a class="header" href="#transpose">Transpose</a></h2>
<p>Returns the transpose of a matrix:</p>
<pre><code>var At = A.transpose()
</code></pre>
<h2 id="trace"><a class="header" href="#trace">Trace</a></h2>
<p>Computes the trace (the sum of the diagonal elements) of a square matrix:</p>
<pre><code>var tr = A.trace()
</code></pre>
<h2 id="roll"><a class="header" href="#roll">Roll</a></h2>
<p>Rotates values in a Matrix about a given axis by a given shift:</p>
<pre><code>var r = A.roll(shift, axis)
</code></pre>
<p>Elements that roll beyond the last position are re-introduced at the first.</p>
<h2 id="identitymatrix"><a class="header" href="#identitymatrix">IdentityMatrix</a></h2>
<p>Constructs an identity matrix of a specified size:</p>
<pre><code>var a = IdentityMatrix(size)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="range"><a class="header" href="#range">Range</a></h1>
<p>Ranges represent a sequence of numerical values. There are two ways to create them depending on whether the upper value is included or not:</p>
<pre><code>var a = 1..5  // inclusive version, i.e. [1,2,3,4,5]
var b = 1...5 // exclusive version, i.e. [1,2,3,4]
</code></pre>
<p>By default, the increment between values is 1, but you can use a different value like this:</p>
<pre><code>var a = 1..5:0.5 // 1 - 5 with an increment of 0.5.
</code></pre>
<p>You can also create Range objects using the appropriate constructor function:</p>
<pre><code>var a = Range(1,5,0.5)
</code></pre>
<p>Ranges are particularly useful in writing loops:</p>
<pre><code>for (i in 1..5) print i
</code></pre>
<p>They can easily be converted to a list of values:</p>
<pre><code>var c = List(1..5)
</code></pre>
<p>To find the number of elements in a Range, use the <code>count</code> method</p>
<pre><code>print (1..5).count()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sparse"><a class="header" href="#sparse">Sparse</a></h1>
<p>The Sparse class provides support for sparse matrices. An empty sparse matrix can be initialized with a given size,</p>
<pre><code>var a = Sparse(nrows,ncols)
</code></pre>
<p>Alternatively, a matrix can be created from an array of triplets,</p>
<pre><code>var a = Sparse([[row, col, value] ...])
</code></pre>
<p>For example,</p>
<pre><code>var a = Sparse([[0,0,2], [1,1,-2]])
</code></pre>
<p>creates the matrix</p>
<pre><code>[ 2 0 ]
[ 0 -2 ]
</code></pre>
<p>Once a sparse matrix is created, you can use all the regular arithmetic operators with matrix operands, e.g.</p>
<pre><code>a+b
a*b
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string"><a class="header" href="#string">String</a></h1>
<p>Strings represent textual information. They are written in Morpho like this:</p>
<pre><code>var a = "hello world"
</code></pre>
<p>Unicode characters including emoji are supported.</p>
<p>You can also create strings using the constructor function <code>String</code>, which takes any number of parameters:</p>
<pre><code>var a = String("Hello", "World")
</code></pre>
<p>A very useful feature, called <em>string interpolation</em>, enables the results of any morpho expression can be interpolated into a string. Here, the values of <code>i</code> and <code>func(i)</code> will be inserted into the string as it is created:</p>
<pre><code>print "${i}: ${func(i)}"
</code></pre>
<p>To get an individual character, use index notatation</p>
<pre><code>print "morpho"[0]
</code></pre>
<p>You can loop over each character like this:</p>
<pre><code>for (c in "morpho") print c
</code></pre>
<p>Note that strings are immutable, and hence</p>
<pre><code>var a = "morpho"
a[0] = 4
</code></pre>
<p>raises an error.</p>
<h2 id="split"><a class="header" href="#split">split</a></h2>
<p>The split method splits a String into a list of substrings. It takes one argument, which is a string of characters to use to split the string:</p>
<pre><code>print "1,2,3".split(",")
</code></pre>
<p>gives</p>
<pre><code>[ 1, 2, 3 ]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="field"><a class="header" href="#field">Field</a></h1>
<p>Fields are used to store information, including numbers or matrices, associated with the elements of a <code>Mesh</code> object.</p>
<p>You can create a <code>Field</code> by applying a function to each of the vertices,</p>
<pre><code>var f = Field(mesh, fn (x, y, z) x+y+z)
</code></pre>
<p>or by supplying a single constant value,</p>
<pre><code>var f = Field(mesh, Matrix([1,0,0]))
</code></pre>
<p>Fields can then be added and subtracted using the <code>+</code> and <code>-</code> operators.</p>
<p>To access elements of a <code>Field</code>, use index notation:</p>
<pre><code>print f[grade, element, index]
</code></pre>
<p>where</p>
<ul>
<li><code>grade</code> is the grade to select</li>
<li><code>element</code> is the element id</li>
<li><code>index</code> is the element index</li>
</ul>
<p>As a shorthand, it's possible to omit the grade and index; these are then both assumed to be <code>0</code>:</p>
<pre><code>print f[2]
</code></pre>
<h2 id="mesh"><a class="header" href="#mesh">Mesh</a></h2>
<p>Returns the Mesh associated with a Field object:</p>
<pre><code>var f.mesh() 
</code></pre>
<h2 id="grade"><a class="header" href="#grade">Grade</a></h2>
<p>To create fields that include grades other than just vertices, use the <code>grade</code> option to <code>Field</code>. This can be just a grade index,</p>
<pre><code>var f = Field(mesh, 0, grade=2)
</code></pre>
<p>which creates an empty field with <code>0</code> for each of the facets of the mesh <code>mesh</code>.</p>
<p>You can store more than one item per element by supplying a list to the <code>grade</code> option indicating how many items you want to store on each grade. For example,</p>
<pre><code>var f = Field(mesh, 1.0, grade=[0,2,1])
</code></pre>
<p>stores two numbers on the line (grade 1) elements and one number on the facets (grade 2) elements. Each number in the field is initialized to the value <code>1.0</code>.</p>
<h2 id="shape"><a class="header" href="#shape">Shape</a></h2>
<p>The <code>shape</code> method returns a list indicating the number of items stored on each element of a particular grade. This has the same format as the list you supply to the <code>grade</code> option of the <code>Field</code> constructor. For example,</p>
<pre><code>[1,0,2]
</code></pre>
<p>would indicate one item stored on each vertex and two items stored on each facet.</p>
<h2 id="op"><a class="header" href="#op">Op</a></h2>
<p>The <code>op</code> method applies a function to every item stored in a <code>Field</code>, returning the result as elements of a new <code>Field</code> object. For example,</p>
<pre><code>f.op(fn (x) x.norm())
</code></pre>
<p>calls the <code>norm</code> method on each element stored in <code>f</code>.</p>
<p>Additional <code>Field</code> objects may be supplied as extra arguments to <code>op</code>. These must have the same shape (the same number of items stored on each grade). The function supplied to <code>op</code> will now be called with the corresponding element from each field as arguments. For example,</p>
<pre><code>f.op(fn (x,y) x.inner(y), g)
</code></pre>
<p>calculates an elementwise inner product between the elements of Fields <code>f</code> and <code>g</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functionals"><a class="header" href="#functionals">Functionals</a></h1>
<p>A number of <code>functionals</code> are available in Morpho. Each of these represents an integral over some <code>Mesh</code> and <code>Field</code> objects (on a particular <code>Selection</code>) and are used to define energies and constraints in an <code>OptimizationProblem</code> provided by the <code>optimize</code> module.</p>
<p>Many functionals are built in. Additional functionals are available by importing the <code>functionals</code> module:</p>
<pre><code>import functionals
</code></pre>
<p>Functionals provide a number of standard methods:</p>
<ul>
<li><code>total</code>(mesh) - returns the value of the integral with a provided mesh, selection and fields</li>
<li><code>integrand</code>(mesh) - returns the contribution to the integral from each element</li>
<li><code>gradient</code>(mesh) - returns the gradient of the functional with respect to vertex motions.</li>
<li><code>fieldgradient</code>(mesh, field) - returns the gradient of the functional with respect to components of the field</li>
</ul>
<p>Each of these may be called with a mesh, a field and a selection.</p>
<h2 id="length"><a class="header" href="#length">Length</a></h2>
<p>A <code>Length</code> functional calculates the length of a line element in a mesh.</p>
<p>Evaluate the length of a circular loop:</p>
<pre><code>import constants
import meshtools
var m = LineMesh(fn (t) [cos(t), sin(t), 0], 0...2*Pi:Pi/20, closed=true)
var le = Length()
print le.total(m)
</code></pre>
<h2 id="areaenclosed"><a class="header" href="#areaenclosed">AreaEnclosed</a></h2>
<p>An <code>AreaEnclosed</code> functional calculates the area enclosed by a loop of line elements.</p>
<pre><code>var la = AreaEnclosed()
</code></pre>
<h2 id="area"><a class="header" href="#area">Area</a></h2>
<p>An <code>Area</code> functional calculates the area of the area elements in a mesh:</p>
<pre><code>var la = Area()
print la.total(mesh)
</code></pre>
<h2 id="volumeenclosed"><a class="header" href="#volumeenclosed">VolumeEnclosed</a></h2>
<p>A <code>VolumeEnclosed</code> functional is used to calculate the volume enclosed by a surface. Note that this estimate may become inaccurate for highly deformed surfaces.</p>
<pre><code>var lv = VolumeEnclosed()
</code></pre>
<h2 id="volume"><a class="header" href="#volume">Volume</a></h2>
<p>A <code>Volume</code> functional calculates the volume of volume elements.</p>
<pre><code>var lv = Volume()
</code></pre>
<h2 id="scalarpotential"><a class="header" href="#scalarpotential">ScalarPotential</a></h2>
<p>The <code>ScalarPotential</code> functional is applied to point elements.</p>
<pre><code>var ls = ScalarPotential(potential)
</code></pre>
<p>You must supply a function (which may be anonymous) that returns the potential. You may optionally provide a function that returns the gradient as well at initialization:</p>
<pre><code>var ls = ScalarPotential(potential, gradient)
</code></pre>
<p>This functional is often used to constrain the mesh to the level set of a function. For example, to confine a set of points to a sphere:</p>
<pre><code>import optimize
fn sphere(x,y,z) { return x^2+y^2+z^2-1 }
fn grad(x,y,z) { return Matrix([2*x, 2*y, 2*z]) }
var lsph = ScalarPotential(sphere, grad)
problem.addlocalconstraint(lsph)
</code></pre>
<p>See the thomson example for use of this technique.</p>
<h2 id="linearelasticity"><a class="header" href="#linearelasticity">LinearElasticity</a></h2>
<p>The <code>LinearElasticity</code> functional measures the linear elastic energy away from a reference state.</p>
<p>You must initialize with a reference mesh:</p>
<pre><code>var le = LinearElasticity(mref)
</code></pre>
<p>Manually set the poisson's ratio and grade to operate on:</p>
<pre><code>le.poissonratio = 0.2
le.grade = 2
</code></pre>
<h2 id="equielement"><a class="header" href="#equielement">EquiElement</a></h2>
<p>The <code>EquiElement</code> functional measures the discrepency between the size of elements adjacent to each vertex. It can be used to equalize elements for regularization purposes.</p>
<h2 id="linecurvaturesq"><a class="header" href="#linecurvaturesq">LineCurvatureSq</a></h2>
<p>The <code>LineCurvatureSq</code> functional measures the integrated curvature squared of a sequence of line elements.</p>
<h2 id="linetorsionsq"><a class="header" href="#linetorsionsq">LineTorsionSq</a></h2>
<p>The <code>LineTorsionSq</code> functional measures the integrated torsion squared of a sequence of line elements.</p>
<h2 id="meancurvaturesq"><a class="header" href="#meancurvaturesq">MeanCurvatureSq</a></h2>
<p>The <code>MeanCurvatureSq</code> functional computes the integrated mean curvature over a surface.</p>
<h2 id="gausscurvature"><a class="header" href="#gausscurvature">GaussCurvature</a></h2>
<p>The <code>GaussCurvature</code> computes the integrated gaussian curvature over a surface.</p>
<p>Note that for surfaces with a boundary, the integrand is correct only for the interior points. To compute the geodesic curvature of the boundary in that case, you can set the optional flag <code>geodesic</code> to <code>true</code> and compute the total on the boundary selection.
Here is an example for a 2D disk mesh.</p>
<pre><code>var mesh = Mesh("disk.mesh")
mesh.addgrade(1)

var whole = Selection(mesh, fn(x,y,z) true)
var bnd = Selection(mesh, boundary=true)
var interior = whole.difference(bnd)

var gauss = GaussCurvature()
print gauss.total(mesh, selection=interior) // expect: 0
gauss.geodesic = true
print gauss.total(mesh, selection=bnd) // expect: 2*Pi
</code></pre>
<h2 id="gradsq"><a class="header" href="#gradsq">GradSq</a></h2>
<p>The <code>GradSq</code> functional measures the integral of the gradient squared of a field. The field can be a scalar, vector or matrix function.</p>
<p>Initialize with the required field:</p>
<pre><code>var le=GradSq(phi)
</code></pre>
<h2 id="nematic"><a class="header" href="#nematic">Nematic</a></h2>
<p>The <code>Nematic</code> functional measures the elastic energy of a nematic liquid crystal.</p>
<pre><code>var lf=Nematic(nn)
</code></pre>
<p>There are a number of optional parameters that can be used to set the splay, twist and bend constants:</p>
<pre><code>var lf=Nematic(nn, ksplay=1, ktwist=0.5, kbend=1.5, pitch=0.1)
</code></pre>
<p>These are stored as properties of the object and can be retrieved as follows:</p>
<pre><code>print lf.ksplay
</code></pre>
<h2 id="nematicelectric"><a class="header" href="#nematicelectric">NematicElectric</a></h2>
<p>The <code>NematicElectric</code> functional measures the integral of a nematic and electric coupling term integral((n.E)^2) where the electric field E may be computed from a scalar potential or supplied as a vector.</p>
<p>Initialize with a director field <code>nn</code> and a scalar potential <code>phi</code>:
var lne = NematicElectric(nn, phi)</p>
<h2 id="normsq"><a class="header" href="#normsq">NormSq</a></h2>
<p>The <code>NormSq</code> functional measures the elementwise L2 norm squared of a field.</p>
<h2 id="lineintegral"><a class="header" href="#lineintegral">LineIntegral</a></h2>
<p>The <code>LineIntegral</code> functional computes the line integral of a function. You supply an integrand function that takes a position matrix as an argument.</p>
<p>To compute <code>integral(x^2+y^2)</code> over a line element:</p>
<pre><code>var la=LineIntegral(fn (x) x[0]^2+x[1]^2)
</code></pre>
<p>The function <code>tangent()</code> returns a unit vector tangent to the current element:</p>
<pre><code>var la=LineIntegral(fn (x) x.inner(tangent()))
</code></pre>
<p>You can also integrate functions that involve fields:</p>
<pre><code>var la=LineIntegral(fn (x, n) n.inner(tangent()), n)
</code></pre>
<p>where <code>n</code> is a vector field. The local interpolated value of this field is passed to your integrand function. More than one field can be used; they are passed as arguments to the integrand function in the order you supply them to <code>LineIntegral</code>.</p>
<h2 id="areaintegral"><a class="header" href="#areaintegral">AreaIntegral</a></h2>
<p>The <code>AreaIntegral</code> functional computes the area integral of a function. You supply an integrand function that takes a position matrix as an argument.</p>
<p>To compute integral(x*y) over an area element:</p>
<pre><code>var la=AreaIntegral(fn (x) x[0]*x[1])
</code></pre>
<p>You can also integrate functions that involve fields:</p>
<pre><code>var la=AreaIntegral(fn (x, phi) phi^2, phi)
</code></pre>
<p>More than one field can be used; they are passed as arguments to the integrand function in the order you supply them to <code>AreaIntegral</code>.</p>
<h2 id="volumeintegral"><a class="header" href="#volumeintegral">VolumeIntegral</a></h2>
<p>The <code>VolumeIntegral</code> functional computes the volume integral of a function. You supply an integrand function that takes a position matrix as an argument.</p>
<p>To compute integral(x<em>y</em>z) over an volume element:</p>
<pre><code>var la=VolumeIntegral(fn (x) x[0]*x[1]*x[2])
</code></pre>
<p>You can also integrate functions that involve fields:</p>
<pre><code>var la=VolumeIntegral(fn (x, phi) phi^2, phi)
</code></pre>
<p>More than one field can be used; they are passed as arguments to the integrand function in the order you supply them to <code>VolumeIntegral</code>.</p>
<h2 id="hydrogel"><a class="header" href="#hydrogel">Hydrogel</a></h2>
<p>The <code>Hydrogel</code> functional computes the Flory-Rehner energy over an element:</p>
<pre><code>(a*phi*log(phi) + b*(1-phi)+log(1-phi) + c*phi*(1-phi))*V + 
d*(log(phiref/phi)/3 - (phiref/phi)^(2/3) + 1)*V0
</code></pre>
<p>The first three terms come from the Flory-Huggins mixing energy, whereas
the fourth term proportional to d comes from the Flory-Rehner elastic
energy.</p>
<p>The value of phi is calculated from a reference mesh
that you provide on initializing the Functional:</p>
<pre><code>var lfh = Hydrogel(mref)
</code></pre>
<p>Here, a, b, c, d and phiref are parameters you can supply (they are <code>nil</code>
by default), V is the current volume and V0 is the reference volume of a
given element. You also need to supply the initial value of phi, labeled
as phi0, which is assumed to be the same for all the elements.
Manually set the coefficients and grade to operate on:</p>
<pre><code>lfh.a = 1; lfh.b = 1; lfh.c = 1; lfh.d = 1;
lfh.grade = 2, lfh.phi0 = 0.5, lfh.phiref = 0.1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mesh-1"><a class="header" href="#mesh-1">Mesh</a></h1>
<p>The <code>Mesh</code> class provides support for meshes. Meshes may consist of different kinds of element, including vertices, line elements, facets or area elements, tetrahedra or volume elements.</p>
<p>To create a mesh, you can import it from a file:</p>
<pre><code>var m = Mesh("sphere.mesh")
</code></pre>
<p>or use one of the functions available in <code>meshtools</code> or <code>implicitmesh</code> packages.</p>
<p>Each type of element is referred to as belonging to a different <code>grade</code>. Point-like elements (vertices) are <em>grade 0</em>; line-like elements (edges) are <em>grade 1</em>; area-like elements (facets; triangles) are <em>grade 2</em> etc.</p>
<p>The <code>plot</code> package includes functions to visualize meshes.</p>
<h2 id="save"><a class="header" href="#save">Save</a></h2>
<p>Saves a mesh as a .mesh file.</p>
<pre><code>m.save("new.mesh")
</code></pre>
<h2 id="vertexposition"><a class="header" href="#vertexposition">Vertexposition</a></h2>
<p>Retrieves the position of a vertex given an id:</p>
<pre><code>print m.vertexposition(id)
</code></pre>
<h2 id="setvertexposition"><a class="header" href="#setvertexposition">Setvertexposition</a></h2>
<p>Sets the position of a vertex given an id and a position vector:</p>
<pre><code>print m.setvertexposition(1, Matrix([0,0,0]))
</code></pre>
<h2 id="addgrade"><a class="header" href="#addgrade">Addgrade</a></h2>
<p>Adds a new grade to a mesh. This is commonly used when, for example, a mesh file includes facets but not edges. To add the missing edges:</p>
<pre><code>m.addgrade(1)
</code></pre>
<h2 id="addsymmetry"><a class="header" href="#addsymmetry">Addsymmetry</a></h2>
<p>Adds a symmetry to a mesh. Experimental in version 0.5.</p>
<h2 id="maxgrade"><a class="header" href="#maxgrade">Maxgrade</a></h2>
<p>Returns the highest grade element present:</p>
<pre><code>print m.maxgrade()
</code></pre>
<h2 id="count"><a class="header" href="#count">Count</a></h2>
<p>Counts the number of elements. If no argument is provided, returns the number of vertices. Otherwise, returns the number of elements present of a given grade:</p>
<pre><code>print m.count(2) // Returns the number of area-like elements. 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="selection"><a class="header" href="#selection">Selection</a></h1>
<p>The Selection class enables you to select components of a mesh for later use. You can supply a function that is applied to the coordinates of every vertex in the mesh, or select components like boundaries.</p>
<p>Create an empty selection:</p>
<pre><code>var s = Selection(mesh)
</code></pre>
<p>Select vertices above the z=0 plane using an anonymous function:</p>
<pre><code>var s = Selection(mesh, fn (x,y,z) z&gt;0)
</code></pre>
<p>Select the boundary of a mesh:</p>
<pre><code>var s = Selection(mesh, boundary=true)
</code></pre>
<p>Selection objects can be composed using set operations:</p>
<pre><code>var s = s1.union(s2)
</code></pre>
<p>or
var s = s1.intersection(s2)</p>
<p>To add additional grades, use the addgrade method. For example, to add areas:
s.addgrade(2)</p>
<p>[showsubtopics]: # subtopics</p>
<h2 id="addgrade-1"><a class="header" href="#addgrade-1">addgrade</a></h2>
<p>Adds elements of the specified grade to a Selection. For example, to add edges to an existing selection, use</p>
<pre><code>s.addgrade(1)
</code></pre>
<p>By default, this only adds an element if <em>all</em> vertices in the element are currently selected. Sometimes, it's useful to be able to add elements for which only some vertices are selected. The optional argument <code>partials</code> allows you to do this:</p>
<pre><code>s.addgrade(1, partials=true)
</code></pre>
<p>Note that this method modifies the existing selection, and does not generate a new Selection object.</p>
<h2 id="removegrade"><a class="header" href="#removegrade">removegrade</a></h2>
<p>Removes elements of the specified grade from a Selection. For example, to remove edges from an existing selection, use</p>
<pre><code>s.removegrade(1)
</code></pre>
<p>Note that this method modifies the existing selection, and does not generate a new Selection object.</p>
<h2 id="idlistforgrade"><a class="header" href="#idlistforgrade">idlistforgrade</a></h2>
<p>Returns a list of element ids included in the selection.</p>
<p>To find out which edges are selected:</p>
<pre><code>var edges = s.idlistforgrade(1)
</code></pre>
<h2 id="isselected"><a class="header" href="#isselected">isselected</a></h2>
<p>Checks if an element id is selected, returning <code>true</code> or <code>false</code> accordingly.</p>
<p>To check if edge number 5 is selected:</p>
<pre><code>var f = s.isselected(1, 5))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="file"><a class="header" href="#file">File</a></h1>
<p>The <code>File</code> class provides the capability to read from and write to files, or to obtain the contents of a file in convenient formats.</p>
<p>To open a file, create a File object with the filename as the argument</p>
<pre><code>var f = File("myfile.txt")
</code></pre>
<p>which opens <code>"myfile.txt"</code> for <em>reading</em>. To open a file for writing or appending, you need to provide a mode selector</p>
<pre><code>var g = File("myfile.txt", "write")
</code></pre>
<p>or</p>
<pre><code>var g = File("myfile.txt", "append")
</code></pre>
<p>Once the file is open, you can then read or write by calling appropriate methods:</p>
<pre><code>f.lines()            // reads the contents of the file into an array of lines.
f.readline()         // reads a single line
f.readchar()         // reads a single character.
f.write(string)      // writes the arguments to the file.
</code></pre>
<p>After you're done with the file, close it with</p>
<pre><code>f.close()
</code></pre>
<h2 id="lines"><a class="header" href="#lines">lines</a></h2>
<p>Returns the contents of a file as an array of strings; each element corresponds to a single line.</p>
<p>Read in the contents of a file and print line by line:</p>
<pre><code>var f = File("input.txt")
var s = f.lines()
for (i in s) print i
f.close()
</code></pre>
<h2 id="readline"><a class="header" href="#readline">readline</a></h2>
<p>Reads a single line from a file; returns the result as a string.</p>
<p>Read in the contents of a file and print each line:</p>
<pre><code>var f = File("input.txt")
while (!f.eof()) {
  print f.readline()
}
f.close()
</code></pre>
<h2 id="readchar"><a class="header" href="#readchar">readchar</a></h2>
<p>Reads a single character from a file; returns the result as a string.</p>
<h2 id="write"><a class="header" href="#write">write</a></h2>
<p>Writes to a file.</p>
<p>Write the contents of a list to a file:</p>
<pre><code>var f = File("output.txt", "w")
for (k, i in list) f.write("${i}: ${k}")
f.close()
</code></pre>
<h2 id="close"><a class="header" href="#close">close</a></h2>
<p>Closes an open file.</p>
<h2 id="eof"><a class="header" href="#eof">eof</a></h2>
<p>Returns true if at the end of the file; false otherwise</p>
<h1 id="folder"><a class="header" href="#folder">Folder</a></h1>
<p>The <code>Folder</code> class enables you to find whether a filepath refers to a folder, and find the contents of that folder.</p>
<p>Find whether a path refers to a folder:</p>
<pre><code>print Folder.isfolder("path/folder")
</code></pre>
<p>Get a list of a folder's contents:</p>
<pre><code>print Folder.contents("path/folder")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="color"><a class="header" href="#color">Color</a></h1>
<p>The <code>color</code> module provides support for working with color. Colors are represented in morpho by <code>Color</code> objects. The module predefines some colors including <code>Red</code>, <code>Green</code>, <code>Blue</code>, <code>Black</code>, <code>White</code>.</p>
<p>To use the module, use import as usual:</p>
<pre><code>import color
</code></pre>
<p>Create a Color object from an RGB pair:</p>
<pre><code>var col = Color(0.5,0.5,0.5) // A 50% gray
</code></pre>
<p>The <code>color</code> module also provides <code>ColorMap</code>s, which are give a sequence of colors as a function of a parameter; these are useful for plotting the values of a <code>Field</code> for example.</p>
<h2 id="rgb"><a class="header" href="#rgb">RGB</a></h2>
<p>Gets the rgb components of a <code>Color</code> or <code>ColorMap</code> object as a list. Takes a single argument in the range 0 to 1, although the result will only depend on this argument if the object is a <code>ColorMap</code>.</p>
<pre><code>var col = Color(0.1,0.5,0.7)
print col.rgb(0)
</code></pre>
<h2 id="red"><a class="header" href="#red">Red</a></h2>
<p>Built in <code>Color</code> object for use with the <code>graphics</code> and <code>plot</code> modules.</p>
<h2 id="green"><a class="header" href="#green">Green</a></h2>
<p>Built in <code>Color</code> object for use with the <code>graphics</code> and <code>plot</code> modules.</p>
<h2 id="blue"><a class="header" href="#blue">Blue</a></h2>
<p>Built in <code>Color</code> object for use with the <code>graphics</code> and <code>plot</code> modules.</p>
<h2 id="white"><a class="header" href="#white">White</a></h2>
<p>Built in <code>Color</code> object for use with the <code>graphics</code> and <code>plot</code> modules.</p>
<h2 id="black"><a class="header" href="#black">Black</a></h2>
<p>Built in <code>Color</code> object for use with the <code>graphics</code> and <code>plot</code> modules.</p>
<h2 id="cyan"><a class="header" href="#cyan">Cyan</a></h2>
<p>Built in <code>Color</code> object for use with the <code>graphics</code> and <code>plot</code> modules.</p>
<h2 id="magenta"><a class="header" href="#magenta">Magenta</a></h2>
<p>Built in <code>Color</code> object for use with the <code>graphics</code> and <code>plot</code> modules.</p>
<h2 id="yellow"><a class="header" href="#yellow">Yellow</a></h2>
<p>Built in <code>Color</code> object for use with the <code>graphics</code> and <code>plot</code> modules.</p>
<h2 id="brown"><a class="header" href="#brown">Brown</a></h2>
<p>Built in <code>Color</code> object for use with the <code>graphics</code> and <code>plot</code> modules.</p>
<h2 id="orange"><a class="header" href="#orange">Orange</a></h2>
<p>Built in <code>Color</code> object for use with the <code>graphics</code> and <code>plot</code> modules.</p>
<h2 id="pink"><a class="header" href="#pink">Pink</a></h2>
<p>Built in <code>Color</code> object for use with the <code>graphics</code> and <code>plot</code> modules.</p>
<h2 id="purple"><a class="header" href="#purple">Purple</a></h2>
<p>Built in <code>Color</code> object for use with the <code>graphics</code> and <code>plot</code> modules.</p>
<h2 id="colormap"><a class="header" href="#colormap">Colormap</a></h2>
<p>The <code>color</code> module provides <code>ColorMap</code>s which are subclasses of <code>Color</code> that map a single parameter in the range 0 to 1 onto a continuum of colors. <code>Color</code>s and <code>Colormap</code>s have the same interface.</p>
<p>Get the red, green or blue components of a color or colormap:</p>
<pre><code>var col = HueMap()
print col.red(0.5) // argument can be in range 0 to 1
</code></pre>
<p>Get all three components as a list:</p>
<pre><code>col.rgb(0)
</code></pre>
<p>Create a grayscale:</p>
<pre><code>var c = Gray(0.2) // 20% gray
</code></pre>
<p>Available ColorMaps: <code>GradientMap</code>,  <code>GrayMap</code>, <code>HueMap</code>, <code>ViridisMap</code>, <code>MagmaMap</code>, <code>InfernoMap</code> and <code>PlasmaMap</code>.</p>
<h2 id="gradientmap"><a class="header" href="#gradientmap">GradientMap</a></h2>
<p><code>GradientMap</code> is a <code>Colormap</code> that displays a white-green-purple sequence.</p>
<h2 id="graymap"><a class="header" href="#graymap">GrayMap</a></h2>
<p><code>GrayMap</code> is a <code>Colormap</code> that displays grayscales.</p>
<h2 id="huemap"><a class="header" href="#huemap">HueMap</a></h2>
<p><code>HueMap</code> is a <code>Colormap</code> that displays vivid colors. It is periodic on the interval 0 to 1.</p>
<h2 id="viridismap"><a class="header" href="#viridismap">ViridisMap</a></h2>
<p><code>ViridisMap</code> is a <code>Colormap</code> that displays a purple-green-yellow sequence.
It is perceptually uniform and intended to be improve the accessibility of visualizations for viewers with color vision deficiency.</p>
<h2 id="magmamap"><a class="header" href="#magmamap">MagmaMap</a></h2>
<p><code>MagmaMap</code> is a <code>Colormap</code> that displays a black-red-yellow sequence.
It is perceptually uniform and intended to be improve the accessibility of visualizations for viewers with color vision deficiency.</p>
<h2 id="infernomap"><a class="header" href="#infernomap">InfernoMap</a></h2>
<p><code>InfernoMap</code> is a <code>Colormap</code> that displays a black-red-yellow sequence.
It is perceptually uniform and intended to be improve the accessibility of visualizations for viewers with color vision deficiency.</p>
<h2 id="plasmamap"><a class="header" href="#plasmamap">PlasmaMap</a></h2>
<p><code>InfernoMap</code> is a <code>Colormap</code> that displays a blue-red-yellow sequence. It is perceptually uniform and intended to be improve the accessibility of visualizations for viewers with color vision deficiency.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="delaunay-1"><a class="header" href="#delaunay-1">Delaunay</a></h1>
<p>The <code>delaunay</code> module creates Delaunay triangulations from point clouds. It is dimensionally independent, so generates tetrahedra in 3D and higher order simplices beyond.</p>
<p>To use the module, first import it:</p>
<pre><code>import delaunay
</code></pre>
<p>To create a Delaunary triangulation from a list of points:</p>
<pre><code>var pts = []
for (i in 0...100) pts.append(Matrix([random(), random()]))
var del=Delaunay(pts)
print del.triangulate()
</code></pre>
<p>The module also provides <code>DelaunayMesh</code> to directly create meshes from Delaunay triangulations.</p>
<h2 id="triangulate"><a class="header" href="#triangulate">Triangulate</a></h2>
<p>The <code>triangulate</code> method performs the delaunay triangulation. To use it, first construct a <code>Delaunay</code> object with the point cloud of interest:</p>
<pre><code>var del=Delaunay(pts)
</code></pre>
<p>Then call <code>triangulate</code>:</p>
<pre><code>var tri = del.triangulate()
</code></pre>
<p>This returns a list of triangles <code>[ [i, j, k], ... ]</code>.</p>
<h2 id="circumsphere"><a class="header" href="#circumsphere">Circumsphere</a></h2>
<p>The <code>Circumsphere</code> class calculates the circumsphere of a set of points, i.e. a sphere such that all the points are on the surface of the sphere. It is used internally by the <code>delaunay</code> module.</p>
<p>Create a <code>Circumsphere</code> from a list of points and a triangle specified by indices into that list:</p>
<pre><code>var sph = Circumsphere(pts, [i,j,k]) 
</code></pre>
<p>Test if an arbitrary point is inside the <code>Circumsphere</code> or not:</p>
<pre><code>print sph.pointinsphere(pt)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graphics"><a class="header" href="#graphics">Graphics</a></h1>
<p>The <code>graphics</code> module provides a number of classes to provide simple visualization capabilities. To use it, you first need to import the module:</p>
<pre><code>import graphics
</code></pre>
<p>The <code>Graphics</code> class acts as an abstract container for graphical information; to actually launch the display see the <code>Show</code> class. You can create an empty scene like this,</p>
<pre><code>var g = Graphics()
</code></pre>
<p>Additional elements can be added using the <code>display</code> method.</p>
<pre><code>g.display(element)
</code></pre>
<p>Morpho provides the following fundamental Graphical element classes:</p>
<pre><code>TriangleComplex
</code></pre>
<p>You can also use functions like <code>Arrow</code>, <code>Tube</code> and <code>Cylinder</code> to create these elements conveniently.</p>
<p>To combine graphics objects, use the add operator:</p>
<pre><code>var g1 = Graphics(), g2 = Graphics()
// ...
Show(g1+g2)
</code></pre>
<h2 id="show"><a class="header" href="#show">Show</a></h2>
<p><code>Show</code> is used to launch an interactive graphical display using the external <code>morphoview</code> application. <code>Show</code> takes a <code>Graphics</code> object as an argument:</p>
<pre><code>var g = Graphics()
Show(g)
</code></pre>
<h2 id="trianglecomplex"><a class="header" href="#trianglecomplex">TriangleComplex</a></h2>
<p>A <code>TriangleComplex</code> is a graphical element that can be used as part of a graphical display. It consists of a list of vertices and a connectivity matrix that selects which vertices are used in each triangle.</p>
<p>To create one, call the constructor with the following arguments:</p>
<pre><code>TriangleComplex(position, normals, colors, connectivity)
</code></pre>
<ul>
<li><code>position</code> is a <code>Matrix</code> containing vertex positions as <em>columns</em>.</li>
<li><code>normals</code> is a <code>Matrix</code> with a normal for each vertex.</li>
<li><code>colors</code> is the color of the object.</li>
<li><code>connectivity</code> is a <code>Sparse</code> matrix where each column represents a triangle and rows correspond to vertices.</li>
</ul>
<p>You can also provide optional arguments:</p>
<ul>
<li><code>transmit</code> sets the transparency of the object. This parameter is only
used by the povray module as of now. Default is 0.</li>
<li><code>filter</code> sets the transparency of the object using a filter effect.
This parameter is only used by the povray module as of now. Default is 0. For the difference between <code>transmit</code> and <code>filter</code>, checkout the
<a href="http://xahlee.info/3d/povray-glassy.html">POVRay documentation</a>.</li>
</ul>
<p>Add to a <code>Graphics</code> object using the <code>display</code> method.</p>
<h2 id="arrow"><a class="header" href="#arrow">Arrow</a></h2>
<p>The <code>Arrow</code> function creates an arrow. It takes two arguments:</p>
<pre><code>arrow(start, end)
</code></pre>
<ul>
<li><code>start</code> and <code>end</code> are the two vertices. The arrow points <code>start</code> -&gt; <code>end</code>.</li>
</ul>
<p>You can also provide optional arguments:</p>
<ul>
<li><code>aspectratio</code> controls the width of the arrow relative to its length</li>
<li><code>n</code> is an integer that controls the quality of the display. Higher <code>n</code> leads to a rounder arrow.</li>
<li><code>color</code> is the color of the arrow. This can be a list of RGB values or a <code>Color</code> object</li>
<li><code>transmit</code> sets the transparency of the arrow. This parameter is only
used by the povray module as of now. Default is 0.</li>
<li><code>filter</code> sets the transparency of the arrow using a filter effect.
This parameter is only used by the povray module as of now. Default is 0. For the difference between <code>transmit</code> and <code>filter</code>, checkout the
<a href="http://xahlee.info/3d/povray-glassy.html">POVRay documentation</a>.</li>
</ul>
<p>Display an arrow:</p>
<pre><code>var g = Graphics([])
g.display(Arrow([-1/2,-1/2,-1/2], [1/2,1/2,1/2], aspectratio=0.05, n=10))
Show(g)
</code></pre>
<h2 id="cylinder"><a class="header" href="#cylinder">Cylinder</a></h2>
<p>The <code>Cylinder</code> function creates a cylinder. It takes two required arguments:</p>
<pre><code>cylinder(start, end)
</code></pre>
<ul>
<li><code>start</code> and <code>end</code> are the two vertices.</li>
</ul>
<p>You can also provide optional arguments:</p>
<ul>
<li><code>aspectratio</code> controls the width of the cylinder relative to its length.</li>
<li><code>n</code> is an integer that controls the quality of the display. Higher <code>n</code> leads to a rounder cylinder.</li>
<li><code>color</code> is the color of the cylinder. This can be a list of RGB values or a <code>Color</code> object.</li>
<li><code>transmit</code> sets the transparency of the cylinder. This parameter is only
used by the povray module as of now. Default is 0.</li>
<li><code>filter</code> sets the transparency of the cylinder using a filter effect.
This parameter is only used by the povray module as of now. Default is 0. For the difference between <code>transmit</code> and <code>filter</code>, checkout the
<a href="http://xahlee.info/3d/povray-glassy.html">POVRay documentation</a>.</li>
</ul>
<p>Display an cylinder:</p>
<pre><code>var g = Graphics()
g.display(Cylinder([-1/2,-1/2,-1/2], [1/2,1/2,1/2], aspectratio=0.1, n=10))
Show(g)
</code></pre>
<h2 id="tube"><a class="header" href="#tube">Tube</a></h2>
<p>The <code>Tube</code> function connects a sequence of points to form a tube.</p>
<pre><code>Tube(points, radius)
</code></pre>
<ul>
<li><code>points</code> is a list of points; this can be a list of lists or a <code>Matrix</code> with the positions as columns.</li>
<li><code>radius</code> is the radius of the tube.</li>
</ul>
<p>You can also provide optional arguments:</p>
<ul>
<li><code>n</code> is an integer that controls the quality of the display. Higher <code>n</code> leads to a rounder tube.</li>
<li><code>color</code> is the color of the tube. This can be a list of RGB values or a <code>Color</code> object.</li>
<li><code>closed</code> is a <code>bool</code> that indicates whether the tube should be closed to form a loop.</li>
<li><code>transmit</code> sets the transparency of the tube. This parameter is only
used by the povray module as of now. Default is 0.</li>
<li><code>filter</code> sets the transparency of the tube using a filter effect.
This parameter is only used by the povray module as of now. Default is 0. For the difference between <code>transmit</code> and <code>filter</code>, checkout the
<a href="http://xahlee.info/3d/povray-glassy.html">POVRay documentation</a>.</li>
</ul>
<p>Draw a square:</p>
<pre><code>var a = Tube([[-1/2,-1/2,0],[1/2,-1/2,0],[1/2,1/2,0],[-1/2,1/2,0]], 0.1, closed=true)
var g = Graphics()
g.display(a)
</code></pre>
<h2 id="sphere"><a class="header" href="#sphere">Sphere</a></h2>
<p>The <code>Sphere</code> function creates a sphere.</p>
<pre><code>Sphere(center, radius)
</code></pre>
<ul>
<li><code>center</code> is the position of the center of the sphere; this can be a list or column <code>Matrix</code>.</li>
<li><code>radius</code> is the radius of the sphere</li>
</ul>
<p>You can also provide optional arguments:</p>
<ul>
<li><code>color</code> is the color of the sphere. This can be a list of RGB values or a <code>Color</code> object.</li>
<li><code>transmit</code> sets the transparency of the sphere. This parameter is only
used by the povray module as of now. Default is 0.</li>
<li><code>filter</code> sets the transparency of the sphere using a filter effect.
This parameter is only used by the povray module as of now. Default is 0. For the difference between <code>transmit</code> and <code>filter</code>, checkout the
<a href="http://xahlee.info/3d/povray-glassy.html">POVRay documentation</a>.</li>
</ul>
<p>Draw some randomly sized spheres:</p>
<pre><code>var g = Graphics()
for (i in 0...10) {
  g.display(Sphere([random()-1/2, random()-1/2, random()-1/2], 0.1*(1+random()),       color=Gray(random())))
}
Show(g)
</code></pre>
<h2 id="text"><a class="header" href="#text">Text</a></h2>
<p>A <code>Text</code> object is used to display text.</p>
<pre><code>Text(text, position)
</code></pre>
<ul>
<li><code>text</code> is the text to display as a string.</li>
<li><code>position</code> is the position at which to display the text.</li>
</ul>
<p>You can also provide optional arguments:</p>
<ul>
<li><code>color</code> is the color of the text. This should be a <code>Color</code> object.</li>
<li><code>dirn</code> is the direction along which the text is drawn. This should be a <code>List</code> or a <code>Matrix</code>.</li>
<li><code>size</code> is the font size to use</li>
<li><code>vertical</code> is the vertical direction for the text</li>
<li><code>font</code> is the <code>Font</code> object to use.</li>
</ul>
<p>Draw several pieces of text around the y axis:</p>
<pre><code>var g = Graphics()
for (phi in 0..Pi:Pi/8) {
  g.display(Text("Hello World", [0,0,0], size=72, dirn=[0,1,0], vertical=[cos(phi),0,sin(phi)]))
}
Show(g)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implicitmesh-1"><a class="header" href="#implicitmesh-1">ImplicitMesh</a></h1>
<p>The <code>implicitmesh</code> module allows you to build meshes from implicit functions. For example, the unit sphere could be specified using the function <code>x^2+y^2+z^2-1 == 0</code>.</p>
<p>To use the module, first import it:</p>
<pre><code>import implicitmesh
</code></pre>
<p>To create a sphere, first create an ImplicitMeshBuilder object with the implict function you'd like to use:</p>
<pre><code>var impl = ImplicitMeshBuilder(fn (x,y,z) x^2+y^2+z^2-1)
</code></pre>
<p>You can use an existing function (or method) as well as an anonymous function as above.</p>
<p>Then build the mesh,</p>
<pre><code>var mesh = impl.build(stepsize=0.25)
</code></pre>
<p>The <code>build</code> method takes a number of optional arguments:</p>
<ul>
<li><code>start</code> - the starting point. If not provided, the value Matrix([1,1,1]) is used.</li>
<li><code>stepsize</code> - approximate lengthscale to use.</li>
<li><code>maxiterations</code> - maximum number of iterations to use. If this limit is exceeded, a partially built mesh will be returned.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kdtree"><a class="header" href="#kdtree">KDTree</a></h1>
<p>The <code>kdtree</code> module implements a k-dimensional tree, a space partitioning data structure that can be used to accelerate computational geometry calculations.</p>
<p>To use the module, first import it:</p>
<pre><code>import kdtree
</code></pre>
<p>To create a tree from a list of points:</p>
<pre><code>var pts = []
for (i in 0...100) pts.append(Matrix([random(), random(), random()]))
var tree=KDTree(pts)
</code></pre>
<p>Add further points:</p>
<pre><code>tree.insert(Matrix([0,0,0]))
</code></pre>
<p>Test whether a given point is present in the tree:</p>
<pre><code>tree.ismember(Matrix([1,0,0]))
</code></pre>
<p>Find all points within a given bounding box:</p>
<pre><code>var pts = tree.search([[-1,1], [-1,1], [-1,1]])
for (x in pts) print x.location
</code></pre>
<p>Find the nearest point to a given point:</p>
<pre><code>var pt = tree.nearest(Matrix([0.1, 0.1, 0.5]))
print pt.location
</code></pre>
<h2 id="insert-1"><a class="header" href="#insert-1">Insert</a></h2>
<p>Inserts a new point into a k-d tree. Returns a KDTreeNode object.</p>
<pre><code>var node = tree.insert(Matrix([0,0,0]))
</code></pre>
<p>Note that, for performance reasons, if the set of points is known ahead of time, it is generally better to build the tree using the constructor function KDTree rather than one-by-one with insert.</p>
<h2 id="ismember-1"><a class="header" href="#ismember-1">Ismember</a></h2>
<p>Checks if a point is a member of a k-d tree. Returns <code>true</code> or <code>false</code>.</p>
<pre><code>print tree.ismember(Matrix([0,0,0]))
</code></pre>
<h2 id="nearest"><a class="header" href="#nearest">Nearest</a></h2>
<p>Finds the point in a k-d tree nearest to a point of interest. Returns a KDTreeNode object.</p>
<pre><code>var pt = tree.nearest(Matrix([0.1, 0.1, 0.5]))
</code></pre>
<p>To get the location of this nearest point, access the location property:</p>
<pre><code>print pt.location
</code></pre>
<h2 id="search"><a class="header" href="#search">Search</a></h2>
<p>Finds all points in a k-d tree that lie within a cuboidal bounding box. Returns a list of KDTreeNode objects.</p>
<p>Find and display all points that lie in a cuboid 0&lt;=x&lt;=1, 0&lt;=y&lt;=2, 1&lt;=z&lt;=2:</p>
<pre><code>var result = tree.search([[0,1], [0,2], [1,2]])
for (x in result) print x.location
</code></pre>
<h2 id="kdtreenode"><a class="header" href="#kdtreenode">KDTreeNode</a></h2>
<p>An object corresponding to a single node in a k-d tree. To get the location of the node, access the <code>location</code> property:</p>
<pre><code>print node.location
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="meshgen-1"><a class="header" href="#meshgen-1">Meshgen</a></h1>
<p>The <code>meshgen</code> module is used to create <code>Mesh</code> objects corresponding to a specified domain. It provides the <code>MeshGen</code> class to perform the meshing, which are created with the following arguments:</p>
<pre><code>MeshGen(domain, boundingbox)
</code></pre>
<p>Domains are specified by a scalar function that is positive in the region to be meshed and locally smooth. For example, to mesh the unit disk:</p>
<pre><code>var dom = fn (x) -(x[0]^2+x[1]^2-1)
</code></pre>
<p>A <code>MeshGen</code> object is then created and then used to build the <code>Mesh</code> like this:</p>
<pre><code>var mg = MeshGen(dom, [-1..1:0.2, -1..1:0.2])
var m = mg.build()
</code></pre>
<p>A bounding box for the mesh must be specified as a <code>List</code> of <code>Range</code> objects, one for each dimension. The increment on each <code>Range</code> gives an approximate scale for the size of elements generated.</p>
<p>To facilitate convenient creation of domains, a <code>Domain</code> class is provided that provides set operations <code>union</code>, <code>intersection</code> and <code>difference</code>.</p>
<p><code>MeshGen</code> accepts a number of optional arguments:</p>
<ul>
<li><code>weight</code> A scalar weight function that controls mesh density.</li>
<li><code>quiet</code> Set to <code>true</code> to suppress  <code>MeshGen</code> output.</li>
<li><code>method</code> a list of options that controls the method used.</li>
</ul>
<p>Some method choices that are available include:</p>
<ul>
<li><code>"FixedStepSize"</code> Use a fixed step size in optimization.</li>
<li><code>"StartGrid"</code> Start from a regular grid of points (the default).</li>
<li><code>"StartRandom"</code> Start from a randomly generated collection of points.</li>
</ul>
<p>There are also a number of properties of a <code>MeshGen</code> object that can be set prior to calling <code>build</code> to control the operation of the mesh generation:</p>
<ul>
<li><code>stepsize</code>, <code>steplimit</code> Stepsize used internally by the <code>Optimizer</code></li>
<li><code>fscale</code> an internal "pressure"</li>
<li><code>ttol</code> how far the vertices are allowed to move before retriangulation</li>
<li><code>etol</code> energy tolerance for optimization problem</li>
<li><code>maxiterations</code> Maximum number of iterations of minimization +
retriangulation (default is 100)</li>
</ul>
<p><code>MeshGen</code> picks default values that cover a reasonable range of uses.</p>
<h2 id="domain"><a class="header" href="#domain">Domain</a></h2>
<p>The <code>Domain</code> class is used to conveniently build a domain by composing simpler elements.</p>
<p>Create a <code>Domain</code> from a scalar function that is positive in the region of interest:</p>
<pre><code>var dom = Domain(fn (x) -(x[0]^2+x[1]^2-1))
</code></pre>
<p>You can pass it to <code>MeshGen</code> to specify the region to mesh:</p>
<pre><code>var mg = MeshGen(dom, [-1..1:0.2, -1..1:0.2])
</code></pre>
<p>You can combine <code>Domain</code> objects using set operations <code>union</code>, <code>intersection</code> and <code>difference</code>:</p>
<pre><code>var a = CircularDomain(Matrix([-0.5,0]), 1)
var b = CircularDomain(Matrix([0.5,0]), 1)
var c = CircularDomain(Matrix([0,0]), 0.3)
var dom = a.union(b).difference(c)
</code></pre>
<h2 id="circulardomain"><a class="header" href="#circulardomain">CircularDomain</a></h2>
<p>Conveniently constructs a <code>Domain</code> object correspondiong to a disk. Requires the position of the center and a radius as arguments.</p>
<p>Create a domain corresponding to the unit disk:</p>
<pre><code>var c = CircularDomain([0,0], 1)
</code></pre>
<h2 id="rectangulardomain"><a class="header" href="#rectangulardomain">RectangularDomain</a></h2>
<p>Conveniently constructs a <code>Domain</code> object corresponding to a rectangle. Requires a list of ranges as arguments. Works in arbitrary dimensions</p>
<p>Create a square <code>Domain</code>:</p>
<pre><code>var c = RectangularDomain([-1..1, -1..1])
</code></pre>
<h2 id="halfspacedomain"><a class="header" href="#halfspacedomain">HalfSpaceDomain</a></h2>
<p>Conveniently constructs a <code>Domain</code> object correspondiong to a half space defined by a plane at <code>x0</code> and a normal <code>n</code>:</p>
<pre><code>var hs = HalfSpaceDomain(x0, n)
</code></pre>
<p>Note <code>n</code> is an "outward" normal, so points into the <em>excluded</em> region.</p>
<p>Half space corresponding to the allowed region <code>x&lt;0</code>:</p>
<pre><code>var hs = HalfSpaceDomain(Matrix([0,0,0]), Matrix([1,0,0]))
</code></pre>
<p>Note that <code>HalfSpaceDomain</code>s cannot be meshed directly as they correspond to an infinite region. They are useful, however, for combining with other domains.</p>
<p>Create half a disk by cutting a <code>HalfSpaceDomain</code> from a <code>CircularDomain</code>:</p>
<pre><code>var c = CircularDomain([0,0], 1)
var hs = HalfSpaceDomain(Matrix([0,0]), Matrix([-1,0]))
var dom = c.difference(hs) 
var mg = MeshGen(dom, [-1..1:0.2, -1..1:0.2], quiet=false)
var m = mg.build()
</code></pre>
<h2 id="mshgndim"><a class="header" href="#mshgndim">MshGnDim</a></h2>
<p>The <code>MeshGen</code> module currently supports 2 and 3 dimensional meshes. Higher dimensional meshing will be available in a future release; please contact the developer if you are interested in this functionality.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="meshslice-1"><a class="header" href="#meshslice-1">Meshslice</a></h1>
<p>The <code>meshslice</code> module is used to slice a <code>Mesh</code> object along a given plane, yielding a new <code>Mesh</code> object of lower dimensionality. You can also use <code>meshslice</code> to project <code>Field</code> objects onto the new mesh.</p>
<p>To use the module, begin by importing it:</p>
<pre><code>import meshslice 
</code></pre>
<p>Then construct a <code>MeshSlicer</code> object, passing the mesh you want to slice in the constructor:</p>
<pre><code>var slice = MeshSlicer(mesh)
</code></pre>
<p>You then perform a slice by calling the <code>slice</code> method, passing the plane you want to slice through. This method returns a new <code>Mesh</code> object comprising the slice. A plane is defined by a point that lies on the plane <code>pt</code> and a direction normal to the plan <code>dirn</code>:</p>
<pre><code>var slc = slice.slice(pt, dirn)
</code></pre>
<p>Having performed a slice, you can then project any associated <code>Field</code> objects onto the sliced mesh by calling the <code>slicefield</code> method:</p>
<pre><code>var phi = Field(mesh, fn (x,y,z) x+y+z)
var sphi = slice.slicefield(phi)
</code></pre>
<p>The new field returned by <code>slicefield</code> lives on the sliced mesh. You can slice any number of fields.</p>
<p>You can perform multiple slices with the same <code>MeshSlicer</code> simply by calling <code>slice</code> again with a different plane.</p>
<h2 id="slcempty"><a class="header" href="#slcempty">SlcEmpty</a></h2>
<p>This error occurs if you try to use <code>slicefield</code> on a <code>MeshSlicer</code> without having performed a slice. For example:</p>
<pre><code>var slice = MeshSlicer(mesh)
slice.slicefield(phi) // Throws SlcEmpty
slice.slice([0,0,0],[1,0,0]) 
</code></pre>
<p>To fix, call <code>slice</code> before <code>slicefield</code>:</p>
<pre><code>var slice = MeshSlicer(mesh)
slice.slice([0,0,0],[1,0,0]) 
slice.slicefield(phi) // Now slices correctly 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="meshtools"><a class="header" href="#meshtools">Meshtools</a></h1>
<p>The Meshtools package contains a number of functions and classes to assist with creating and manipulating meshes.</p>
<h2 id="areamesh-1"><a class="header" href="#areamesh-1">AreaMesh</a></h2>
<p>This function creates a mesh composed of triangles from a parametric function. To use it:</p>
<pre><code>var m = AreaMesh(function, range1, range2, closed=boolean)
</code></pre>
<p>where</p>
<ul>
<li><code>function</code> is a parametric function that has one parameter. It should return a list of coordinates or a column matrix corresponding to this parameter.</li>
<li><code>range1</code> is the Range to use for the first parameter of the parametric function.</li>
<li><code>range2</code> is the Range to use for the second parameter of the parametric function.</li>
<li><code>closed</code> is an optional parameter indicating whether to create a closed loop or not. You can supply a list where each element indicates whether the relevant parameter is closed or not.</li>
</ul>
<p>To use <code>AreaMesh</code>, import the <code>meshtools</code> module:</p>
<pre><code>import meshtools
</code></pre>
<p>Create a square:</p>
<pre><code>var m = AreaMesh(fn (u,v) [u, v, 0], 0..1:0.1, 0..1:0.1)
</code></pre>
<p>Create a tube:</p>
<pre><code>var m = AreaMesh(fn (u, v) [v, cos(u), sin(u)], -Pi...Pi:Pi/4,
                 -1..1:0.1, closed=[true, false])
</code></pre>
<p>Create a torus:</p>
<pre><code>var c=0.5, a=0.2
var m = AreaMesh(fn (u, v) [(c + a*cos(v))*cos(u),
                            (c + a*cos(v))*sin(u),
                            a*sin(v)], 0...2*Pi:Pi/16, 0...2*Pi:Pi/8, closed=true)
</code></pre>
<h2 id="linemesh-1"><a class="header" href="#linemesh-1">LineMesh</a></h2>
<p>This function creates a mesh composed of line elements from a parametric function. To use it:</p>
<pre><code>var m = LineMesh(function, range, closed=boolean)
</code></pre>
<p>where</p>
<ul>
<li><code>function</code> is a parametric function that has one parameter. It should return a list of coordinates or a column matrix corresponding to this parameter.</li>
<li><code>range</code> is the Range to use for the parametric function.</li>
<li><code>closed</code> is an optional parameter indicating whether to create a closed loop or not.</li>
</ul>
<p>To use <code>LineMesh</code>, import the <code>meshtools</code> module:</p>
<pre><code>import meshtools
</code></pre>
<p>Create a circle:</p>
<pre><code>import constants
var m = LineMesh(fn (t) [sin(t), cos(t), 0], 0...2*Pi:2*Pi/50, closed=true)
</code></pre>
<h2 id="polyhedronmesh-1"><a class="header" href="#polyhedronmesh-1">PolyhedronMesh</a></h2>
<p>This function creates a mesh corresponding to a polyhedron.</p>
<pre><code>var m = PolyhedronMesh(vertices, faces)
</code></pre>
<p>where <code>vertices</code> is a list of vertices and <code>faces</code> is a list of faces specified as a list of vertex indices.</p>
<p>To use <code>PolyhedronMesh</code>, import the <code>meshtools</code> module:</p>
<pre><code>import meshtools
</code></pre>
<p>Create a cube:</p>
<pre><code>var m = PolyhedronMesh([ [-0.5, -0.5, -0.5], [ 0.5, -0.5, -0.5],
                         [-0.5,  0.5, -0.5], [ 0.5,  0.5, -0.5],
                         [-0.5, -0.5,  0.5], [ 0.5, -0.5,  0.5],
                         [-0.5,  0.5,  0.5], [ 0.5,  0.5,  0.5]],
                       [ [0,1,3,2], [4,5,7,6], [0,1,5,4], 
                         [3,2,6,7], [0,2,6,4], [1,3,7,5] ])
</code></pre>
<p><em>Note</em> that the vertices in each face list must be specified strictly in cyclic order.</p>
<h2 id="delaunaymesh-1"><a class="header" href="#delaunaymesh-1">DelaunayMesh</a></h2>
<p>The <code>DelaunayMesh</code> constructor function creates a <code>Mesh</code> object directly from a point cloud using the Delaunay triangulator.</p>
<pre><code>var pts = []
for (i in 0...100) pts.append(Matrix([random(), random()]))
var m=DelaunayMesh(pts)
Show(plotmesh(m))
</code></pre>
<p>You can control the output dimension of the mesh (e.g. to create a 2D mesh embedded in 3D space) using the optional <code>outputdim</code> property.</p>
<pre><code>var m = DelaunayMesh(pts, outputdim=3)
</code></pre>
<h2 id="equiangulate"><a class="header" href="#equiangulate">Equiangulate</a></h2>
<p>Attempts to equiangulate a mesh, exchanging elements to improve their regularity.</p>
<pre><code>equiangulate(mesh)
</code></pre>
<p><em>Note</em> this function modifies the mesh in place; it does not create a new mesh.</p>
<h2 id="changemeshdimension"><a class="header" href="#changemeshdimension">ChangeMeshDimension</a></h2>
<p>Changes the dimension in which a mesh is embedded. For example, you may have created a mesh in 2D that you now wish to use in 3D.</p>
<p>To use:</p>
<pre><code>var new = ChangeMeshDimension(mesh, dim)
</code></pre>
<p>where <code>mesh</code> is the mesh you wish to change, and <code>dim</code> is the new embedding dimension.</p>
<h2 id="meshbuilder-1"><a class="header" href="#meshbuilder-1">MeshBuilder</a></h2>
<p>The <code>MeshBuilder</code> class simplifies user creation of meshes. To use this class, begin by creating a <code>MeshBuilder</code> object:</p>
<pre><code>var build = MeshBuilder()
</code></pre>
<p>You can then add vertices, edges, etc. one by one using <code>addvertex</code>, <code>addedge</code>, <code>addface</code> and <code>addelement</code>. Each of these returns an element id:</p>
<pre><code>var id1=build.addvertex(Matrix([0,0,0]))
var id2=build.addvertex(Matrix([1,1,1]))
build.addedge([id1, id2])
</code></pre>
<p>Once the mesh is ready, call the <code>build</code> method to construct the <code>Mesh</code>:</p>
<pre><code>var m = build.build()
</code></pre>
<p>You can specify the dimension of the <code>Mesh</code> explicitly when initializing the <code>MeshBuilder</code>:</p>
<pre><code>var mb = MeshBuilder(dimension=2)
</code></pre>
<p>or implicitly when adding the first vertex:</p>
<pre><code>var mb = MeshBuilder() 
mb.addvertex([0,1]) // A 2D mesh
</code></pre>
<h2 id="mshblddimincnstnt"><a class="header" href="#mshblddimincnstnt">MshBldDimIncnstnt</a></h2>
<p>This error is produced if you try to add a vertex that is inconsistent with the mesh dimension, e.g.</p>
<pre><code>var mb = MeshBuilder(dimension=2) 
mb.addvertex([1,0,0]) // Throws an error! 
</code></pre>
<p>To fix this ensure all vertices have the correct dimension.</p>
<h2 id="mshblddimunknwn"><a class="header" href="#mshblddimunknwn">MshBldDimUnknwn</a></h2>
<p>This error is produced if you try to add an element to a <code>MeshBuilder</code> object but haven't yet specified the dimension (at initialization) or by adding a vertex.</p>
<pre><code>var mb = MeshBuilder() 
mb.addedge([0,1]) // No vertices have been added 
</code></pre>
<p>To fix this add the vertices first.</p>
<h2 id="meshrefiner"><a class="header" href="#meshrefiner">MeshRefiner</a></h2>
<p>The <code>MeshRefiner</code> class is used to refine meshes, and to correct associated data structures that depend on the mesh.</p>
<p>To prepare for refining, first create a <code>MeshRefiner</code> object either with a <code>Mesh</code>,</p>
<pre><code>var mr = MeshRefiner(mesh)
</code></pre>
<p>or with a list of objects that can include a <code>Mesh</code> as well as <code>Field</code>s and <code>Selection</code>s.</p>
<pre><code>var mr = MeshRefiner([mesh, field, selection ... ])
</code></pre>
<p>To perform the refinement, call the <code>refine</code> method. You can refine all elements,</p>
<pre><code>var dict = mr.refine()
</code></pre>
<p>or refine selected elements using a <code>Selection</code>,</p>
<pre><code>var dict = mr.refine(selection=select)
</code></pre>
<p>The <code>refine</code> method returns a <code>Dictionary</code> that maps old objects to new, refined objects. Use this to update your data structures.</p>
<pre><code>var newmesh = dict[oldmesh]
</code></pre>
<h2 id="meshpruner"><a class="header" href="#meshpruner">MeshPruner</a></h2>
<p>The <code>MeshPruner</code> class is used to prune excessive detail from meshes (a process that's sometimes referred to as coarsening), and to correct associated data structures that depend on the mesh.</p>
<p>First create a <code>MeshPruner</code> object either with a <code>Mesh</code>,</p>
<pre><code>var mp = MeshPruner(mesh)
</code></pre>
<p>or with a list of objects that can include a <code>Mesh</code> as well as <code>Field</code>s and <code>Selection</code>s.</p>
<pre><code>var mp = MeshPruner([mesh, field, selection ... ])
</code></pre>
<p>To perform the coarsening, call the <code>prune</code> method with a <code>Selection</code>,</p>
<pre><code>var dict = mp.prune(select)
</code></pre>
<p>The <code>prune</code> method returns a <code>Dictionary</code> that maps old objects to new, refined objects. Use this to update your data structures.</p>
<pre><code>var newmesh = dict[oldmesh]
</code></pre>
<h2 id="meshmerge"><a class="header" href="#meshmerge">MeshMerge</a></h2>
<p>The <code>MeshMerge</code> class is used to combine meshes into a single mesh, removing any duplicate elements.</p>
<p>To use, create a <code>MeshMerge</code> object with a list of meshes to merge,</p>
<pre><code>var mrg = MeshMerge([m1, m2, m3, ... ])
</code></pre>
<p>and then call the <code>merge</code> method to return a combined mesh:</p>
<pre><code>var newmesh = mrg.merge()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="optimize"><a class="header" href="#optimize">Optimize</a></h1>
<p>The <code>optimize</code> package contains a number of functions and classes to perform shape optimization.</p>
<h2 id="optimizationproblem"><a class="header" href="#optimizationproblem">OptimizationProblem</a></h2>
<p>An <code>OptimizationProblem</code> object defines an optimization problem, which may include functionals to optimize as well as global and local constraints.</p>
<p>Create an <code>OptimizationProblem</code> with a mesh:</p>
<pre><code>var problem = OptimizationProblem(mesh)
</code></pre>
<p>Add an energy:</p>
<pre><code>var la = Area()
problem.addenergy(la)
</code></pre>
<p>Add an energy that operates on a selected region, and with an optional prefactor:</p>
<pre><code>problem.addenergy(la, selection=sel, prefactor=2)
</code></pre>
<p>Add a constraint:</p>
<pre><code>problem.addconstraint(la)
</code></pre>
<p>Add a local constraint (here a onesided level set constraint):</p>
<pre><code>var ls = ScalarPotential(fn (x,y,z) z, fn (x,y,z) Matrix([0,0,1]))
problem.addlocalconstraint(ls, onesided=true)
</code></pre>
<h2 id="optimizer"><a class="header" href="#optimizer">Optimizer</a></h2>
<p><code>Optimizer</code> objects are used to optimize <code>Mesh</code>es and <code>Field</code>s. You should use the appropriate subclass: <code>ShapeOptimizer</code> or <code>FieldOptimizer</code> respectively.</p>
<h2 id="shapeoptimizer"><a class="header" href="#shapeoptimizer">ShapeOptimizer</a></h2>
<p>A <code>ShapeOptimizer</code> object performs shape optimization: it moves the vertex positions to reduce an overall energy.</p>
<p>Create a <code>ShapeOptimizer</code> object with an <code>OptimizationProblem</code> and a <code>Mesh</code>:</p>
<pre><code>var sopt = ShapeOptimizer(problem, m)
</code></pre>
<p>Take a step down the gradient with fixed stepsize:</p>
<pre><code>sopt.relax(5) // Takes five steps
</code></pre>
<p>Linesearch down the gradient:</p>
<pre><code>sopt.linesearch(5) // Performs five linesearches
</code></pre>
<p>Perform conjugate gradient (usually gives faster convergence):</p>
<pre><code>sopt.conjugategradient(5) // Performs five conjugate gradient steps.
</code></pre>
<p>Control a number of properties of the optimizer:</p>
<pre><code>sopt.stepsize=0.1 // The stepsize to take
sopt.steplimit=0.5 // Maximum stepsize for optimizing methods
sopt.etol = 1e-8 // Energy convergence tolerance
sopt.ctol = 1e-9 // Tolerance to which constraints are satisfied
sopt.maxconstraintsteps = 20 // Maximum number of constraint steps to use
</code></pre>
<h2 id="fieldoptimizer"><a class="header" href="#fieldoptimizer">FieldOptimizer</a></h2>
<p>A <code>FieldOptimizer</code> object performs field optimization: it changes elements of a <code>Field</code> to reduce an overall energy.</p>
<p>Create a <code>FieldOptimizer</code> object with an <code>OptimizationProblem</code> and a <code>Field</code>:</p>
<pre><code>var sopt = FieldOptimizer(problem, fld)
</code></pre>
<p>Field optimizers provide the same options and methods as Shape optimizers: see the <code>ShapeOptimizer</code> documentation for details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plot-1"><a class="header" href="#plot-1">Plot</a></h1>
<p>The <code>plot</code> module provides visualization capabilities for Meshes, Selections and Fields. These functions produce Graphics objects that can be displayed with <code>Show</code>.</p>
<p>To use the module, first import it:</p>
<pre><code>import plot
</code></pre>
<h2 id="plotmesh"><a class="header" href="#plotmesh">Plotmesh</a></h2>
<p>Visualizes a <code>Mesh</code> object:</p>
<pre><code>var g = plotmesh(mesh)
</code></pre>
<p>Plotmesh accepts a number of optional arguments to control what is displayed:</p>
<ul>
<li><code>selection</code> - Only elements in a provided <code>Selection</code> are drawn.</li>
<li><code>grade</code> - Only draw the specified grade. This can also be a list of multiple grades to draw.</li>
<li><code>color</code> - Draw the mesh in a provided <code>Color</code>.</li>
<li><code>filter</code> and <code>transmit</code> - Used by the <code>povray</code> module to indicate transparency.</li>
</ul>
<h2 id="plotmeshlabels"><a class="header" href="#plotmeshlabels">Plotmeshlabels</a></h2>
<p>Draws the ids for elements in a <code>Mesh</code>:</p>
<pre><code>var g = plotmeshlabels(mesh) 
</code></pre>
<p>Plotmeshlabels accepts a number of optional arguments to control the output:</p>
<ul>
<li><code>grade</code> - Only draw the specified grade. This can also be a list of multiple grades to draw.</li>
<li><code>selection</code> - Only labels in a provided <code>Selection</code> are drawn.</li>
<li><code>offset</code> - Local offset vector for labels. Can be a <code>List</code>, a <code>Matrix</code> or a function.</li>
<li><code>dirn</code> - Text direction for labels. Can be a <code>List</code>, a <code>Matrix</code> or a function.</li>
<li><code>vertical</code> - Text vertical direction. Can be a <code>List</code>, a <code>Matrix</code> or a function.</li>
<li><code>color</code> - Label color. Can be a <code>Color</code> object or a <code>Dictionary</code> of colors for each grade.</li>
<li><code>fontsize</code> - Font size to use.</li>
</ul>
<h2 id="plotselection"><a class="header" href="#plotselection">Plotselection</a></h2>
<p>Visualizes a <code>Selection</code> object:</p>
<pre><code>var g = plotselection(mesh, sel)
</code></pre>
<p>Plotselection accepts a number of optional arguments to control what is displayed:</p>
<ul>
<li><code>grade</code> - Only draw the specified grade. This can also be a list of multiple grades to draw.</li>
<li><code>filter</code> and <code>transmit</code> - Used by the <code>povray</code> module to indicate transparency.</li>
</ul>
<h2 id="plotfield"><a class="header" href="#plotfield">Plotfield</a></h2>
<p>Visualizes a scalar <code>Field</code> object:</p>
<pre><code>var g = plotfield(field)
</code></pre>
<p>Plotfield accepts a number of optional arguments to control what is displayed:</p>
<ul>
<li><code>grade</code> - Draw the specified grade.</li>
<li><code>colormap</code> - A <code>Colormap</code> object to use. The field is automatically scaled.</li>
<li><code>scalebar</code> - A <code>Scalebar</code> object to use.</li>
<li><code>style</code> - Plot style. See below.</li>
<li><code>filter</code> and <code>transmit</code> - Used by the <code>povray</code> module to indicate transparency.</li>
<li><code>cmin</code> and <code>cmax</code> - Can be used to define the data range covered.
Values beyond these limits will be colored by the lower/upper bound of
the colormap accordingly.</li>
</ul>
<p>Supported plot styles:</p>
<ul>
<li><code>default</code> - Color <code>Mesh</code> elements by the corresponding value of the <code>Field</code>.</li>
<li><code>interpolate</code> - Interpolate <code>Field</code> quantities onto higher elements.</li>
</ul>
<h2 id="scalebar"><a class="header" href="#scalebar">ScaleBar</a></h2>
<p>Represents a scalebar for a plot:</p>
<pre><code>Show(plotfield(field, scalebar=ScaleBar(posn=[1.2,0,0])))
</code></pre>
<p><code>ScaleBar</code>s can be created with many adjustable parameters:</p>
<ul>
<li><code>nticks</code> - Maximum number of ticks to show.</li>
<li><code>posn</code> - Position to draw the <code>ScaleBar</code>.</li>
<li><code>length</code> - Length of <code>ScaleBar</code> to draw.</li>
<li><code>dirn</code> - Direction to draw the <code>ScaleBar</code> in.</li>
<li><code>tickdirn</code> - Direction to draw the ticks in.</li>
<li><code>colormap</code> - <code>ColorMap</code> to use.</li>
<li><code>textdirn</code> - Direction to draw labels in.</li>
<li><code>textvertical</code> - Label vertical direction.</li>
<li><code>fontsize</code> - Fontsize for labels</li>
<li><code>textcolor</code> - Color for labels</li>
</ul>
<p>You can draw the <code>ScaleBar</code> directly by calling the <code>draw</code> method:</p>
<pre><code>sb.draw(min, max)
</code></pre>
<p>where <code>min</code> and <code>max</code> are the minimum and maximum values to display on the scalebar.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="povray-1"><a class="header" href="#povray-1">POVRay</a></h1>
<p>The <code>povray</code> module provides integration with POVRay, a popular open source ray-tracing package for high quality graphical rendering. To use the module, first import it:</p>
<pre><code>import povray
</code></pre>
<p>To raytrace a graphic, begin by creating a <code>POVRaytracer</code> object:</p>
<pre><code>var pov = POVRaytracer(graphic)
</code></pre>
<p>Create a .pov file that can be run with POVRay:</p>
<pre><code>pov.write("out.pov")
</code></pre>
<p>Create, render and display a scene using POVRay:</p>
<pre><code>pov.render("out.pov")
</code></pre>
<p>This also creates the .png file for the scene.</p>
<p>The <code>POVRaytracer</code> constructor supports an optional <code>camera</code> argument:</p>
<ul>
<li><code>camera</code> - a <code>Camera</code> object (see below / help) containing the
settings for the povray camera.</li>
</ul>
<p>The <code>Camera</code> object can be initialized as follows:</p>
<pre><code>var camera = Camera()
</code></pre>
<p>This object contains the default settings of the camera, which can be
changed using the following optional arguments, or by just setting the
attributes after instantiation:</p>
<ul>
<li><code>antialias</code> - whether to antialias the output or not (<code>true</code> by default)</li>
<li><code>width</code> - image width (<code>2048</code> by default)</li>
<li><code>height</code> - image height (<code>1536</code> by default)</li>
<li><code>viewangle</code> - camera angle (higher means wider view) (<code>24</code> by default)</li>
<li><code>viewpoint</code> - position of camera (<code>Matrix([0,0,-5])</code> by default)</li>
<li><code>look_at</code> - coordinate to look at (<code>Matrix([0,0,0])</code> by defualt)</li>
<li><code>sky</code> - orientation pointing to the sky (<code>Matrix([0,1,0])</code> by default)</li>
</ul>
<p>The default settings generate a reasonable centered view of the x-y
plane.</p>
<p>These attributes can also be set directly for the <code>POVRaytracer</code> object:</p>
<pre><code>pov.look_at = Matrix([0,0,1])
</code></pre>
<p>The <code>render</code> method supports two optional boolean arguments:</p>
<ul>
<li><code>quiet</code> - whether to suppress the parser and render statistics from <code>povray</code> or not (<code>false</code> by default)</li>
<li><code>display</code> - whether to turn on the graphic display while rendering or not (<code>true</code> by default)</li>
</ul>
<h1 id="camera"><a class="header" href="#camera">Camera</a></h1>
<p>The <code>Camera</code> object can be initialized as follows:</p>
<pre><code>var camera = Camera()
</code></pre>
<p>This object contains the default settings of the camera, which can be
changed using the following optional arguments, or by just setting the
attributes after instantiation:</p>
<ul>
<li>
<p><code>antialias</code> - whether to antialias the output or not (<code>true</code> by default)</p>
</li>
<li>
<p><code>width</code> - image width (<code>2048</code> by default)</p>
</li>
<li>
<p><code>height</code> - image height (<code>1536</code> by default)</p>
</li>
<li>
<p><code>viewangle</code> - camera angle (higher means wider view) (<code>24</code> by default)</p>
</li>
<li>
<p><code>viewpoint</code> - position of camera (<code>Matrix([0,0,-5])</code> by default)</p>
</li>
<li>
<p><code>look_at</code> - coordinate to look at (<code>Matrix([0,0,0])</code> by defualt)</p>
</li>
<li>
<p><code>sky</code> - orientation pointing to the sky (<code>Matrix([0,1,0])</code> by default)</p>
<p>camera.sky = Matrix([0,0,1])</p>
</li>
</ul>
<p>The default settings generate a reasonable centered view of the x-y
plane.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vtk"><a class="header" href="#vtk">VTK</a></h1>
<p>The vtk module contains classes to allow I/O of meshes and fields using
the VTK Legacy Format.</p>
<h2 id="vtkexporter"><a class="header" href="#vtkexporter">VTKExporter</a></h2>
<p>This class can be used to export the field(s) and/or at a given state
to a single .vtk file. To use it, import the <code>vtk</code> module:</p>
<pre><code>import vtk
</code></pre>
<p>Initialize the <code>VTKExporter</code></p>
<pre><code>var vtkE = VTKExporter(obj)
</code></pre>
<p>where <code>obj</code> can either be</p>
<ul>
<li>A <code>Mesh</code> object: This prepares the Mesh for exporting.</li>
<li>A <code>Field</code> object: This prepares both the Field and the Mesh associated
with it for exporting.</li>
</ul>
<p>Use the <code>export</code> method to export to a VTK file.</p>
<pre><code>vtkE.export("output.vtk")
</code></pre>
<p>Optionally, use the <code>addfield</code> method to add one or more fields before
exporting:</p>
<pre><code>vtkE.addfield(f, fieldname="f")
</code></pre>
<p>where,</p>
<ul>
<li><code>f</code> is the field object to be exported</li>
<li><code>fieldname</code> is an optional argument that assigns a name to the field
in the VTK file. This name is required to be a character
string without embedded whitespace. If not provided, the name would be
either "scalars" or "vectors" depending on the field type**.</li>
</ul>
<p>** Note that this currently only supports scalar or vector (column
matrix) fields that live on the vertices ( shape <code>[1,0,0]</code>). Support for
tensorial fields and fields on cells coming soon.</p>
<p>Minimal example:</p>
<pre><code>import vtk
import meshtools

var m1 = LineMesh(fn (t) [t,0,0], -1..1:2)

var vtkE = VTKExporter(m1) // Export just the mesh 

vtkE.export("mesh.vtk")

var f1 = Field(m1, fn(x,y,z) x)

var g1 = Field(m1, fn(x,y,z) Matrix([x,2*x,3*x]))

vtkE = VTKExporter(f1, fieldname="f") // Export fields

vtkE.addfield(g1, fieldname="g")

vtkE.export("data.vtk")
</code></pre>
<h2 id="vtkimporter"><a class="header" href="#vtkimporter">VTKImporter</a></h2>
<p>This class can be used to import the field(s) and/or the  mesh at a
given state from a single .vtk file. To use it, import the <code>vtk</code> module:</p>
<pre><code>import vtk
</code></pre>
<p>Initialize the <code>VTKImporter</code> with the filename</p>
<pre><code>var vtkI = VTKImporter("output.vtk")
</code></pre>
<p>Use the <code>mesh</code> method to get the mesh:</p>
<pre><code>var mesh = vtkI.mesh()
</code></pre>
<p>Use the <code>field</code> method to get the field:</p>
<pre><code>var f = vtkI.field(fieldname)
</code></pre>
<p>Use the <code>fieldlist</code> method to get the list of the names of the fields contained in the file:</p>
<pre><code>print vtkI.fieldlist()
</code></pre>
<p>Use the <code>containsfield</code> method to check whether the file contains a field by a given <code>fieldname</code>:</p>
<pre><code>if (tkI.containsfield(fieldname)) {
    ... 
}
</code></pre>
<p>where <code>fieldname</code> is the name assigned to the field in the .vtk file</p>
<p>Minimal example:</p>
<pre><code>import vtk
import meshtools 

var vtkI = VTKImporter("data.vtk")

var m = vtkI.mesh()

var f = vtkI.field("f")

var g = vtkI.field("g")
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
